[
  {
    "procedure_info": {
      "schema": "billing",
      "name": "USP_AgenciesRetrieve",
      "definition": "CREATE PROCEDURE [billing].[USP_AgenciesRetrieve]\r\n(\r\n\t@agencyId AS INT = NULL\r\n\t,@parentAgencyId AS INT = NULL\r\n\t,@agencyCode AS VARCHAR(6) = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT AgencyId\r\n\t\t,ParentAgencyId\r\n\t\t,AgencyCodeOEC\r\n\t\t,AgencyName\r\n\t\t,AgencyDescription\r\n\t\t,Active\r\n\tFROM EC3DB.BudgetApp_vwAgencies\r\n\tWHERE AgencyId = ISNULL(@agencyId, AgencyId)\r\n\t\tAND ISNULL(ParentAgencyId, -1) = COALESCE(@parentAgencyId, ParentAgencyId, -1)\r\n\t\tAND 1 = CASE WHEN ISNULL(@agencyCode, '') <> '' THEN CASE WHEN AgencyCodeOEC = @agencyCode THEN 1 ELSE 0 END ELSE 1 END\r\n\tORDER BY AgencyCodeOEC ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.553000",
      "last_altered": "2025-08-25 15:54:05.553000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@agencyId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@parentAgencyId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyCode",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgenciesRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgenciesRetrieve` is designed to retrieve agency information from a view named `BudgetApp_vwAgencies` within the `EC3DB` database. It allows filtering based on agency ID, parent agency ID, and agency code. The procedure returns a result set containing details about agencies, such as their ID, parent ID, code, name, description, and active status.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SELECT statement with optional filtering based on input parameters. The logic is simple, with basic conditional checks and no complex operations or joins.\n\n#### 3. Input Parameters\n- `@agencyId AS INT = NULL`: Optional parameter to filter results by a specific agency ID. If not provided, all agencies are considered.\n- `@parentAgencyId AS INT = NULL`: Optional parameter to filter results by a specific parent agency ID. If not provided, all parent agencies are considered.\n- `@agencyCode AS VARCHAR(6) = NULL`: Optional parameter to filter results by a specific agency code. If not provided, all agency codes are considered.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- The transaction isolation level is set to `READ UNCOMMITTED`, allowing the query to read uncommitted changes from other transactions, which can improve performance but may result in dirty reads.\n- The SELECT statement retrieves columns from the `BudgetApp_vwAgencies` view.\n- Filtering logic:\n  - `AgencyId` is filtered using the `ISNULL` function, which defaults to the column value if the parameter is NULL.\n  - `ParentAgencyId` uses `ISNULL` and `COALESCE` to handle NULL values, defaulting to -1 if both the parameter and column are NULL.\n  - `AgencyCodeOEC` is filtered using a CASE statement to check if the parameter is non-empty and matches the column value.\n- Results are ordered by `AgencyCodeOEC` in ascending order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead but at the cost of potential dirty reads.\n- The `ISNULL` and `COALESCE` functions are used for NULL handling, which can be efficient but may affect index usage if not properly indexed.\n- The CASE statement for `AgencyCodeOEC` filtering is straightforward but could be optimized if the column is indexed.\n- The procedure's performance largely depends on the underlying view's complexity and indexing.\n\n#### 6. Potential Issues or Risks\n- The `READ UNCOMMITTED` isolation level can lead to dirty reads, where uncommitted changes from other transactions are visible, potentially leading to inconsistent data.\n- The use of `ISNULL` and `COALESCE` in the WHERE clause might prevent the use of indexes, leading to full table scans if indexes are not properly designed.\n- The procedure assumes that `AgencyCodeOEC` is unique or that duplicates are acceptable, as it orders by this column without additional sorting criteria.\n- If the view `BudgetApp_vwAgencies` is complex or involves multiple joins, the performance might degrade, especially with large datasets.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1105,
      "api_response_id": "chatcmpl-C8VNdYlzHaNKVub9KDtwNhrfsOvf7"
    },
    "analysis_timestamp": "2025-08-25 13:35:00"
  },
  {
    "procedure_info": {
      "schema": "billing",
      "name": "USP_BudgetGroupsRetrieve",
      "definition": "CREATE PROCEDURE [billing].[USP_BudgetGroupsRetrieve]\r\n(\r\n\t@budgetGroupId AS INT = NULL\r\n\t,@providerId AS INT = NULL\r\n\t,@energyType AS VARCHAR(3) = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT BudgetGroupID\r\n\t\t,BudgetGroupName\r\n\t\t,BudgetGroupDescription\r\n\t\t,EnergyType\r\n\t\t,Active\r\n\tFROM EC3DB.BudgetApp_vwBudgetGroups\r\n\tWHERE BudgetGroupID = ISNULL(@budgetGroupId, BudgetGroupID)\r\n\t\tAND BudgetGroupID IN (SELECT DISTINCT BudgetGroupDEM\r\n\t\t\tFROM EC3DB.BudgetApp_vwProviderBudgetGroups\r\n\t\t\tWHERE [Provider] = ISNULL(@providerId, [Provider]))\r\n\t\tAND CASE WHEN ISNULL(@energyType, '') <> '' THEN CASE WHEN EnergyType = @energyType THEN 1 ELSE 0 END ELSE 1 END = 1\r\n\tUNION\r\n\tSELECT  CONVERT(INT, 0) AS BudgetGroupID,\r\n\t\t'', '', '', 'TRUE' AS Active\r\n\tORDER BY BudgetGroupName ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.560000",
      "last_altered": "2025-08-25 15:54:05.560000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@providerId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@energyType",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 3,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BudgetGroupsRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BudgetGroupsRetrieve` is designed to retrieve budget group information from a database. It allows filtering based on budget group ID, provider ID, and energy type. The procedure queries a view named `BudgetApp_vwBudgetGroups` and optionally filters results based on the provided parameters. It also includes a UNION operation that appends a default row with a BudgetGroupID of 0 and an Active status of 'TRUE'.\n\n#### 2. Complexity Level: Medium\nThe procedure involves conditional logic, subqueries, and a UNION operation, which adds a moderate level of complexity. The use of multiple parameters and conditional filtering increases the complexity compared to a simple SELECT statement.\n\n#### 3. Input Parameters\n- `@budgetGroupId AS INT = NULL`: Optional parameter to filter results by a specific budget group ID. If NULL, no filtering is applied based on this parameter.\n- `@providerId AS INT = NULL`: Optional parameter to filter results by a specific provider ID. If NULL, no filtering is applied based on this parameter.\n- `@energyType AS VARCHAR(3) = NULL`: Optional parameter to filter results by a specific energy type. If NULL or an empty string, no filtering is applied based on this parameter.\n\n#### 4. Business Logic and Workflow\n1. **SET NOCOUNT ON**: Prevents the sending of DONE_IN_PROC messages to the client for each statement in a stored procedure, which can reduce network traffic.\n2. **SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED**: Allows reading uncommitted data, which can lead to dirty reads but improves performance by not acquiring shared locks.\n3. **Main Query**: \n   - Selects columns from the `BudgetApp_vwBudgetGroups` view.\n   - Filters by `BudgetGroupID` if `@budgetGroupId` is provided.\n   - Filters by `Provider` using a subquery if `@providerId` is provided.\n   - Filters by `EnergyType` if `@energyType` is provided and not an empty string.\n4. **UNION Operation**: Appends a default row with a `BudgetGroupID` of 0 and `Active` status of 'TRUE'.\n5. **ORDER BY**: Results are ordered by `BudgetGroupName` in ascending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: While it improves performance by avoiding locks, it can result in dirty reads, which may not be suitable for all applications.\n- **Subquery in WHERE Clause**: The subquery for filtering by provider ID could impact performance, especially if the `BudgetApp_vwProviderBudgetGroups` view is large or lacks proper indexing.\n- **UNION Operation**: The UNION operation inherently removes duplicates, which can add overhead. If duplicates are not a concern, using UNION ALL could improve performance.\n- **Indexing**: Ensuring that the columns used in WHERE clauses and joins are indexed can significantly improve query performance.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of READ UNCOMMITTED can lead to reading uncommitted or inconsistent data, which might not be acceptable in scenarios requiring data accuracy.\n- **NULL Handling**: The procedure relies on ISNULL to handle NULL parameters, which is appropriate but requires careful consideration to ensure it aligns with business logic.\n- **Union Default Row**: The default row with a `BudgetGroupID` of 0 might not be expected by all consumers of this procedure, potentially leading to confusion or errors if not documented.\n- **Scalability**: As data grows, the performance of subqueries and UNION operations may degrade if not optimized with appropriate indexing and query tuning.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1224,
      "api_response_id": "chatcmpl-C8VNtXEZF7Ap3BmAXfGHhLaa7YVBp"
    },
    "analysis_timestamp": "2025-08-25 13:35:13"
  },
  {
    "procedure_info": {
      "schema": "billing",
      "name": "USP_FacilitiesRetrieve",
      "definition": "CREATE PROCEDURE [billing].[USP_FacilitiesRetrieve]\r\n(\r\n\t@agencyCode\tAS VARCHAR(6) = NULL\r\n\t,@facilityId AS INT = NULL\r\n\t,@facilityNo AS VARCHAR(10) = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT FacilityID,\r\n\t\tOECFacilityNumber,\r\n\t\tFacilityName,\r\n\t\tTotalSquareFootage,\r\n\t\tTotalNumberOfFloors,\r\n\t\tAddress1,\r\n\t\tAddress2,\r\n\t\tCity,\r\n\t\t[State],\r\n\t\tZipCode,\r\n\t\tHouseNumber,\r\n\t\tStreetName,\r\n\t\tLegacyBuildingNumber,\r\n\t\tOECLegacyAddress,\r\n\t\tSecondaryAddress,\r\n\t\tBorough,\r\n\t\t[Block],\r\n\t\tLotNumber,\r\n\t\tCityPlanningBIN,\r\n\t\tIsRentalSpace,\r\n\t\tCreatedDate,\r\n\t\tCreatedBy,\r\n\t\tModifiedDate,\r\n\t\tModifiedBy,\r\n\t\tActive\r\n\tFROM EC3DB.BudgetApp_vwFacilities\r\n\tWHERE FacilityID = ISNULL(@facilityId, FacilityID)\r\n\t\tAND 1 = CASE WHEN ISNULL(@facilityNo, '') <> '' THEN CASE WHEN OECFacilityNumber = @facilityNo THEN 1 ELSE 0 END ELSE 1 END\r\n\t\tAND OecFacilityNumber IN (SELECT DISTINCT OECFacilityNumber\r\n\t\t\tFROM EC3DB.BudgetApp_vwAgencyFacilities\r\n\t\t\tWHERE CASE WHEN ISNULL(@agencyCode, '') <> '' THEN CASE WHEN AgencyCodeOEC = @agencyCode THEN 1 ELSE 0 END ELSE 1 END = 1)\r\n\tORDER BY OECFacilityNumber ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.563000",
      "last_altered": "2025-08-25 15:54:05.563000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@agencyCode",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@facilityId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@facilityNo",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 10,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_FacilitiesRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_FacilitiesRetrieve` is designed to retrieve facility information from a view named `BudgetApp_vwFacilities` within the `EC3DB` database. It allows filtering based on optional parameters such as `agencyCode`, `facilityId`, and `facilityNo`. The procedure returns a set of facility-related details, including identifiers, physical attributes, and metadata about the facilities.\n\n#### 2. Complexity Level: Medium\nThe complexity of this stored procedure is considered medium due to the following factors:\n- It involves conditional logic for filtering based on multiple optional parameters.\n- It includes a subquery to filter facilities associated with a specific agency code.\n- It uses a non-standard transaction isolation level, which requires careful consideration.\n\n#### 3. Input Parameters\n- `@agencyCode AS VARCHAR(6) = NULL`: An optional parameter used to filter facilities associated with a specific agency code.\n- `@facilityId AS INT = NULL`: An optional parameter used to filter the results to a specific facility by its ID.\n- `@facilityNo AS VARCHAR(10) = NULL`: An optional parameter used to filter the results to a specific facility by its OEC facility number.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages to the client, which can improve performance in certain scenarios.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read uncommitted changes from other transactions, which can reduce locking contention but may lead to dirty reads.\n- The main `SELECT` statement retrieves a comprehensive list of facility attributes from the `BudgetApp_vwFacilities` view.\n- Filtering logic:\n  - If `@facilityId` is provided, it filters the results to match the specified `FacilityID`.\n  - If `@facilityNo` is provided, it filters the results to match the specified `OECFacilityNumber`.\n  - It uses a subquery to ensure that the facilities returned are associated with the specified `agencyCode` if provided.\n- The results are ordered by `OECFacilityNumber` in ascending order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking but at the risk of reading uncommitted data.\n- The use of `ISNULL` and `CASE` statements for filtering can impact performance, especially if the underlying tables/views are large.\n- The subquery in the `WHERE` clause could be optimized by ensuring that `OECFacilityNumber` and `AgencyCodeOEC` are indexed, which would improve the performance of the filtering operation.\n- The procedure does not include pagination, which could lead to performance issues if the result set is large.\n\n#### 6. Potential Issues or Risks\n- The `READ UNCOMMITTED` isolation level can lead to dirty reads, which might not be acceptable in all business scenarios.\n- The procedure assumes that the input parameters are either provided or default to `NULL`, which might not handle all edge cases if the data contains unexpected values.\n- The use of `ISNULL` and `CASE` for filtering can lead to full table scans if indexes are not properly utilized, potentially degrading performance.\n- The procedure does not handle exceptions or errors, which could lead to unhandled exceptions if unexpected conditions occur during execution.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1249,
      "api_response_id": "chatcmpl-C8VO6u4LRtFJrYWESiw6gCxhu01zd"
    },
    "analysis_timestamp": "2025-08-25 13:35:27"
  },
  {
    "procedure_info": {
      "schema": "billing",
      "name": "USP_ProjectPatternRetrieve",
      "definition": "CREATE PROCEDURE [billing].[USP_ProjectPatternRetrieve]\r\n(\r\n\t@patternId AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\t\r\n\tSELECT ProjectPatternId\r\n      ,ProjectPatternName\r\n      ,ProjectPatternDescription\r\n      ,Active\r\n\tFROM input.ProjectPatternType\r\n\tWHERE ProjectPatternId = CASE WHEN @patternId IS NOT NULL THEN @patternId ELSE ProjectPatternId END;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.567000",
      "last_altered": "2025-08-25 15:54:05.567000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@patternId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectPatternRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectPatternRetrieve` is designed to retrieve records from the `input.ProjectPatternType` table within the `billing` schema. It fetches details about project patterns based on a given `ProjectPatternId`. If no specific `ProjectPatternId` is provided, it retrieves all records from the table.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a simple SELECT query with a conditional WHERE clause. It does not involve complex logic, multiple joins, or intricate data manipulations.\n\n#### 3. Input Parameters\n- `@patternId AS INT = NULL`: This is an optional input parameter. It specifies the `ProjectPatternId` for which the details are to be retrieved. If this parameter is not provided (i.e., it is NULL), the procedure defaults to retrieving all records from the `ProjectPatternType` table.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read rows that have been modified by other transactions but not yet committed. This can prevent blocking but may result in reading uncommitted or \"dirty\" data.\n- The SELECT statement retrieves four columns: `ProjectPatternId`, `ProjectPatternName`, `ProjectPatternDescription`, and `Active` from the `input.ProjectPatternType` table.\n- The WHERE clause uses a CASE statement to determine if the `@patternId` parameter is provided. If it is, the query filters the results to match the specified `ProjectPatternId`. If not, it defaults to retrieving all records.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED Isolation Level**: While this can improve performance by reducing locking and blocking, it may lead to reading uncommitted data, which can be inconsistent.\n- **Conditional Filtering**: The use of a CASE statement in the WHERE clause allows for flexible querying but may not be as efficient as separate queries for specific and all records retrieval.\n- **Index Usage**: Performance can be improved if there is an index on the `ProjectPatternId` column, especially when filtering by this column.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to dirty reads, where the data retrieved might not be consistent or accurate if other transactions are modifying the data concurrently.\n- **Parameter Sniffing**: If the procedure is executed with varying values for `@patternId`, SQL Server might cache an execution plan that is not optimal for all scenarios, potentially leading to suboptimal performance.\n- **Scalability**: As the table grows, retrieving all records without filtering could lead to performance degradation. Consider implementing pagination or limiting the number of records returned for large datasets.\n- **Security**: Ensure that users executing this procedure have appropriate permissions to access the `input.ProjectPatternType` table to prevent unauthorized data access.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 937,
      "api_response_id": "chatcmpl-C8VOLqnn6PuOmxVeWu6NuUNdAds5e"
    },
    "analysis_timestamp": "2025-08-25 13:35:47"
  },
  {
    "procedure_info": {
      "schema": "billing",
      "name": "USP_ProjectProgramRetrieve",
      "definition": "CREATE PROCEDURE [billing].[USP_ProjectProgramRetrieve]\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT projectprogramid AS ProgramSeqId\r\n\t\t,projectProgramName AS ProgramName\r\n\t\t,projectProgramDescription AS ProgramDescription\r\n\t\t,Abbreviation\r\n\t\t,Active AS IsActive\r\n\t\t,CONVERT(INT, 18) AS AddedBy\r\n\t\t,NULL AS DateAdded\r\n\t\t,CONVERT(INT, 18) AS UpdatedBy\r\n\t\t,NULL AS DateLastUpdate\r\n\tFROM input.projectprogramtype\r\n\tORDER BY ProgramSeqId;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.570000",
      "last_altered": "2025-08-25 15:54:05.570000",
      "type": "PROCEDURE"
    },
    "parameters": [],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectProgramRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectProgramRetrieve` is designed to retrieve data from the `input.projectprogramtype` table within a SQL Server database. It selects specific columns from this table, renames them for output, and orders the results by `ProgramSeqId`. The procedure is set to operate under the `READ UNCOMMITTED` transaction isolation level, which allows it to read uncommitted changes from other transactions, potentially improving performance by reducing locking overhead.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `SELECT` statement with column renaming and ordering. It does not include any complex logic, conditional statements, or joins, making it easy to understand and maintain.\n\n#### 3. Input Parameters\nThis stored procedure does not accept any input parameters. It retrieves all records from the `input.projectprogramtype` table without filtering based on any criteria.\n\n#### 4. Business Logic and Workflow\n- **Transaction Isolation Level**: The procedure sets the transaction isolation level to `READ UNCOMMITTED`, which allows dirty reads. This means the procedure can read data that might not yet be committed, potentially leading to reading uncommitted changes from other transactions.\n- **Data Retrieval**: It selects the following columns from the `input.projectprogramtype` table:\n  - `projectprogramid` is retrieved as `ProgramSeqId`.\n  - `projectProgramName` is retrieved as `ProgramName`.\n  - `projectProgramDescription` is retrieved as `ProgramDescription`.\n  - `Abbreviation` is retrieved as is.\n  - `Active` is retrieved as `IsActive`.\n  - Two columns, `AddedBy` and `UpdatedBy`, are hardcoded to the integer value `18`.\n  - `DateAdded` and `DateLastUpdate` are set to `NULL`.\n- **Ordering**: The results are ordered by `ProgramSeqId`.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: This isolation level can improve performance by reducing locking contention, but it comes at the cost of potentially reading uncommitted or dirty data.\n- **Indexing**: If `projectprogramid` is indexed, the ordering operation will be more efficient. Lack of indexing on this column could lead to slower performance as the dataset grows.\n- **No Filtering**: Since the procedure retrieves all records without filtering, performance could degrade with a large dataset. Consider adding parameters for filtering if necessary.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: Using `READ UNCOMMITTED` can lead to reading uncommitted data, which might not be suitable for all business scenarios, especially where data consistency is critical.\n- **Hardcoded Values**: The procedure uses hardcoded values for `AddedBy` and `UpdatedBy`, which might not reflect actual user actions or system processes. This could lead to misleading data if these fields are intended to track user activity.\n- **Null Values**: The `DateAdded` and `DateLastUpdate` fields are set to `NULL`, which might not be useful if the application or reporting tools rely on these timestamps for auditing or tracking changes.\n- **Scalability**: Without filtering or pagination, the procedure might not scale well with large datasets, potentially leading to performance bottlenecks.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1024,
      "api_response_id": "chatcmpl-C8VOeKcieAFzuLcQZNrj7K1vVoIrU"
    },
    "analysis_timestamp": "2025-08-25 13:36:00"
  },
  {
    "procedure_info": {
      "schema": "billing",
      "name": "USP_ProvidersRetrieve",
      "definition": "CREATE PROCEDURE [billing].[USP_ProvidersRetrieve]\r\n(\r\n\t@providerId AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT ProviderID\r\n\t\t,ProviderName\r\n\t\t,ProviderDescription\r\n\t\t,FMSIdNumber\r\n\t\t,CreatedDate\r\n\t\t,CreatedBy\r\n\t\t,ModifiedDate\r\n\t\t,ModifiedBy\r\n\t\t,Active\r\n\tFROM EC3DB.BudgetApp_vwProviders\r\n\tWHERE ProviderID = ISNULL(@providerId, ProviderID)\r\n\tORDER BY ProviderName ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.573000",
      "last_altered": "2025-08-25 15:54:05.573000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@providerId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProvidersRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProvidersRetrieve` is designed to retrieve provider information from a view named `BudgetApp_vwProviders` within the `EC3DB` database. It allows for the optional filtering of results based on a specific `ProviderID`. The procedure returns a set of columns that include provider details such as `ProviderID`, `ProviderName`, and other metadata fields. The results are ordered by `ProviderName` in ascending order.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SELECT query with an optional filter condition. It does not include complex logic, multiple operations, or intricate control flow structures, making it easy to understand and maintain.\n\n#### 3. Input Parameters\n- `@providerId AS INT = NULL`: This is an optional input parameter. If provided, it filters the results to return only the record with the matching `ProviderID`. If not provided, all records from the view are returned.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- The transaction isolation level is set to `READ UNCOMMITTED`, allowing the query to read uncommitted changes from other transactions. This can improve performance by reducing locking contention but at the risk of reading dirty data.\n- The SELECT statement retrieves columns from the `BudgetApp_vwProviders` view. The `WHERE` clause uses the `ISNULL` function to apply the filter condition only if `@providerId` is provided. If `@providerId` is NULL, the condition defaults to `ProviderID = ProviderID`, effectively returning all records.\n- The results are ordered by `ProviderName` in ascending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED Isolation Level**: This setting can improve performance by reducing locking overhead but may lead to reading uncommitted or dirty data, which could be inconsistent.\n- **Indexing**: The performance of the SELECT query can be significantly impacted by the presence of indexes on the `ProviderID` and `ProviderName` columns in the `BudgetApp_vwProviders` view. Proper indexing can enhance query performance, especially when filtering by `ProviderID` or ordering by `ProviderName`.\n- **Network Traffic**: The use of `SET NOCOUNT ON` reduces network traffic by suppressing the message that indicates the number of rows affected by the query.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of the `READ UNCOMMITTED` isolation level means that the procedure may return data that is not yet committed, leading to potential inconsistencies if other transactions are modifying the data concurrently.\n- **Null Handling**: The use of `ISNULL(@providerId, ProviderID)` in the WHERE clause ensures that all records are returned when `@providerId` is NULL. However, if the intention is to always filter by a specific `ProviderID`, this logic may need to be adjusted.\n- **Security and Permissions**: Ensure that appropriate permissions are set for accessing the `BudgetApp_vwProviders` view and executing the stored procedure to prevent unauthorized data access.\n- **Scalability**: If the view contains a large number of records, returning all records when `@providerId` is NULL could lead to performance bottlenecks. Consider implementing pagination or additional filtering criteria if necessary.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1047,
      "api_response_id": "chatcmpl-C8VOrpCdMAsWAHOdj7txcVYpF0fMR"
    },
    "analysis_timestamp": "2025-08-25 13:36:10"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "USP_BudgetRateDetailsRetrieve",
      "definition": "CREATE PROCEDURE [budget].[USP_BudgetRateDetailsRetrieve]\r\n(\r\n\t@scenarioId\tAS INT\r\n\t,@budgetGroupId\tAS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSET @budgetGroupId = NULLIF(ISNULL(@budgetGroupId, 0), 0);\r\n\r\n\t-- Aggregate the budget rates\r\n\tWITH BGBP AS (SELECT BG.BudgetGroupID\r\n\t\t\t,BG.BudgetGroupID AS BudgetGroupDEM\r\n\t\t\t,BP.BillingPeriod\r\n\t\tFROM dbo.UDF_GetBillingPeriods((SELECT FY FROM budget.Scenario WHERE ID = @scenarioId)) AS BP\r\n\t\t\t,EC3DB.BudgetApp_vwBudgetGroups AS BG)\r\n\tSELECT BASE.BudgetGroupID\r\n\t\t,BASE.BudgetGroupDEM\r\n\t\t,BASE.BillingPeriod\r\n\t\t-- Base Rates\r\n\t\t,BASE.BaseRateID\r\n\t\t,BASE.CommodityConsumption\r\n\t\t,BASE.CommodityConsumptionOffPeak\r\n\t\t,BASE.CommodityDemand\r\n\t\t,BASE.DeliveryConsumption\r\n\t\t,BASE.DeliveryDemand\r\n\t\t,BASE.DeliveryReactivePower\r\n\t\t,BASE.DeliveryFacilityPoints\r\n\t\t,BASE.CustomerCharge\r\n\t\t-- Rate Factors\r\n\t\t,BASE.CommodityAdder\r\n\t\t,BASE.CommodityMultiplier\r\n\t\t,BASE.DeliveryMultiplier\r\n\t\t,BASE.GRTMultiplier\r\n\t\t,BASE.DemandAdjustmentMultiplier\r\n\t\t-- Budget Rates\r\n\t\t,BASE.CommodityConsumption * BASE.CommodityMultiplier * BASE.GRTMultiplier AS BudgetCommodityConsumption\r\n\t\t,BASE.CommodityAdder AS BudgetCommodityConsumptionAdder\r\n\t\t,BASE.CommodityConsumptionOffPeak * BASE.CommodityMultiplier * BASE.DemandAdjustmentMultiplier AS BudgetCommodityConsumptionOffPeak\r\n\t\t,BASE.CommodityDemand * BASE.CommodityMultiplier * BASE.DemandAdjustmentMultiplier AS BudgetCommodityDemand\r\n\t\t,BASE.DeliveryConsumption * BASE.DeliveryMultiplier * BASE.GRTMultiplier AS BudgetDeliveryConsumption\r\n\t\t,BASE.DeliveryDemand * BASE.DeliveryMultiplier * BASE.GRTMultiplier * BASE.DemandAdjustmentMultiplier AS BudgetDeliveryDemand\r\n\t\t,BASE.DeliveryReactivePower * BASE.DeliveryMultiplier * BASE.GRTMultiplier * BASE.DemandAdjustmentMultiplier AS BudgetDeliveryReactivePower\r\n\t\t,BASE.DeliveryFacilityPoints * BASE.DeliveryMultiplier * BASE.GRTMultiplier AS BudgetDeliveryFacilityPoints\r\n\t\t,BASE.CustomerCharge * BASE.DeliveryMultiplier * BASE.GRTMultiplier AS BudgetCustomerCharge\r\n\tFROM (-- Aggregate the base rates and the multipliers with the budget groups and billing periods\r\n\t\tSELECT BGBP.BudgetGroupID, BGBP.BudgetGroupDEM, BGBP.BillingPeriod, ISNULL(BRDTL.BaseRateID, 0) AS BaseRateID\r\n\t\t\t,ISNULL(BRDTL.CommodityConsumption, 0) AS CommodityConsumption\r\n\t\t\t,ISNULL(BRDTL.CommodityConsumptionOffPeak, 0) AS CommodityConsumptionOffPeak\r\n\t\t\t,ISNULL(BRDTL.CommodityDemand, 0) AS CommodityDemand\r\n\t\t\t,ISNULL(BRDTL.DeliveryConsumption, 0) AS DeliveryConsumption\r\n\t\t\t,ISNULL(BRDTL.DeliveryDemand, 0) AS DeliveryDemand\r\n\t\t\t,ISNULL(BRDTL.DeliveryReactivePower, 0) AS DeliveryReactivePower\r\n\t\t\t,ISNULL(BRDTL.DeliveryFacilityPoints, 0) AS DeliveryFacilityPoints\r\n\t\t\t,ISNULL(BRDTL.CustomerCharge, 0) AS CustomerCharge\r\n\t\t\t,ISNULL(RFDTL.CommodityAdder, 0) AS [CommodityAdder]\r\n\t\t\t,ISNULL(RFDTL.CommodityMultiplier, 1) AS [CommodityMultiplier]\r\n\t\t\t,ISNULL(RFDTL.DeliveryMultiplier, 1) AS [DeliveryMultiplier]\r\n\t\t\t,ISNULL(RFDTL.GRTMultiplier, 1) AS [GRTMultiplier]\r\n\t\t\t,ISNULL(RFDTL.DemandAdjustmentMultiplier, 1) AS [DemandAdjustmentMultiplier]\r\n\t\tFROM BGBP\r\n\t\t\tINNER JOIN budget.Scenario AS SCN ON SCN.ID = @scenarioId\r\n\t\t\tLEFT JOIN input.BaseRateDetail AS BRDTL ON BRDTL.BaseRateID = SCN.BaseRateID\r\n\t\t\t\tAND BRDTL.BudgetGroupID = BGBP.BudgetGroupID AND BRDTL.BillingPeriod = BGBP.BillingPeriod\r\n\t\t\tLEFT JOIN input.RateFactorDetail AS RFDTL ON RFDTL.RateFactorID = SCN.RateFactorID\r\n\t\t\t\tAND RFDTL.BudgetGroupID = BGBP.BudgetGroupID AND RFDTL.BillingPeriod = BGBP.BillingPeriod) AS BASE\r\n\tWHERE BASE.BudgetGroupID = ISNULL(@budgetGroupId, BASE.BudgetGroupID)\r\n\tORDER BY BASE.BudgetGroupID, BASE.BudgetGroupDEM, BASE.BillingPeriod;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.580000",
      "last_altered": "2025-08-25 15:54:05.580000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@scenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BudgetRateDetailsRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BudgetRateDetailsRetrieve` is designed to retrieve detailed budget rate information for a specified scenario and optionally for a specific budget group. It aggregates base rates and rate factors to compute budget rates for various billing periods associated with a scenario. The procedure uses a common table expression (CTE) to manage billing periods and budget groups, and it performs calculations to derive budget rates based on base rates and multipliers.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple joins, a common table expression (CTE), and several calculations to derive budget rates. While the logic is straightforward, the use of CTEs and the combination of multiple data sources and calculations increase its complexity beyond a simple query.\n\n#### 3. Input Parameters\n- `@scenarioId AS INT`: This parameter is mandatory and specifies the scenario for which budget rate details are to be retrieved. It is used to filter data from the `budget.Scenario` table.\n- `@budgetGroupId AS INT = NULL`: This optional parameter allows filtering the results for a specific budget group. If not provided, it defaults to `NULL`, meaning all budget groups will be considered.\n\n#### 4. Business Logic and Workflow\n- **Transaction Isolation Level**: The procedure sets the transaction isolation level to `READ UNCOMMITTED`, allowing dirty reads. This is typically used to improve performance by avoiding locks but can lead to reading uncommitted data.\n- **Parameter Handling**: The `@budgetGroupId` is set to `NULL` if it is `0`, ensuring that the default behavior is to include all budget groups unless a specific ID is provided.\n- **Common Table Expression (CTE)**: The CTE `BGBP` is used to generate a list of budget groups and billing periods by joining the results of a user-defined function `UDF_GetBillingPeriods` with a view `EC3DB.BudgetApp_vwBudgetGroups`.\n- **Data Aggregation**: The main query aggregates base rates and rate factors by joining the CTE with the `budget.Scenario`, `input.BaseRateDetail`, and `input.RateFactorDetail` tables. It calculates budget rates using base rates and multipliers.\n- **Filtering and Ordering**: The results are filtered based on the `@budgetGroupId` and ordered by `BudgetGroupID`, `BudgetGroupDEM`, and `BillingPeriod`.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: While this improves performance by reducing locking overhead, it can lead to reading uncommitted or inconsistent data.\n- **Joins and CTE**: The use of multiple joins and a CTE can be resource-intensive, especially if the underlying tables are large. Indexes on join columns can help improve performance.\n- **ISNULL and NULLIF Functions**: These functions are used to handle null values and default parameters, which can add some overhead but are necessary for correct logic.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to reading uncommitted data, which may not be suitable for all business scenarios.\n- **Parameter Defaulting**: The logic for setting `@budgetGroupId` to `NULL` if it is `0` may not be intuitive and could lead to unexpected results if not documented properly.\n- **Scalability**: As the number of scenarios, budget groups, and billing periods increases, the performance may degrade due to the complexity of joins and calculations.\n- **Data Integrity**: The reliance on external functions and views means that changes to these components could affect the procedure's output, necessitating thorough testing when changes occur.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 2017,
      "api_response_id": "chatcmpl-C8VP1mgFpe21Ud62Iywr5bdfa2t71"
    },
    "analysis_timestamp": "2025-08-25 13:36:24"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "USP_CalculationStageResultDelete",
      "definition": "CREATE PROCEDURE [budget].[USP_CalculationStageResultDelete]\r\n(\r\n\t@scenarioId AS INT\r\n\t,@stageId AS INT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\t DELETE FROM budget.StagingBudget WHERE ScenarioId = @scenarioId AND BudgetStageID = @stageId;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.583000",
      "last_altered": "2025-08-25 15:54:05.583000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@scenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@stageId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_CalculationStageResultDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_CalculationStageResultDelete` is designed to delete records from the `StagingBudget` table within the `budget` schema. It specifically targets records that match a given `ScenarioId` and `BudgetStageID`. This procedure is typically used in scenarios where data needs to be removed from a staging area, possibly as part of a data refresh or cleanup process.\n\n#### 2. Complexity Level: Low\nThe complexity of this stored procedure is low. It performs a straightforward DELETE operation based on two input parameters. There are no conditional logic, loops, or complex operations involved.\n\n#### 3. Input Parameters\n- `@scenarioId AS INT`: This parameter represents the identifier for a specific scenario. It is used to filter the records in the `StagingBudget` table that are associated with this scenario.\n- `@stageId AS INT`: This parameter represents the identifier for a specific budget stage. It is used alongside `@scenarioId` to further filter the records to be deleted.\n\n#### 4. Business Logic and Workflow\nThe business logic of this stored procedure is simple:\n- It begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic and improve performance when executing the procedure.\n- It executes a DELETE statement on the `StagingBudget` table, removing all records where the `ScenarioId` matches `@scenarioId` and the `BudgetStageID` matches `@stageId`.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `ScenarioId` and `BudgetStageID` columns are indexed. This will improve the performance of the DELETE operation by allowing SQL Server to quickly locate the records to be deleted.\n- **Transaction Log**: Deleting records can generate a significant amount of transaction log activity, especially if the table contains a large number of records. Consider using batch deletes if the dataset is large to manage log growth and reduce locking.\n- **Locking and Blocking**: The DELETE operation will acquire locks on the rows being deleted, which could lead to blocking if other transactions are trying to access the same data. Monitor and manage concurrency to minimize impact.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Ensure that the deletion of records from the `StagingBudget` table does not violate any data integrity constraints or lead to orphaned records in related tables.\n- **Accidental Deletion**: There is a risk of accidental data loss if the parameters are not correctly specified. Implementing additional checks or logging mechanisms can help mitigate this risk.\n- **Error Handling**: The procedure lacks error handling. Consider adding TRY...CATCH blocks to handle potential errors gracefully and provide meaningful error messages.\n- **Security**: Ensure that only authorized users have permission to execute this procedure, as it involves data deletion. Implement appropriate security measures to prevent unauthorized access.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 878,
      "api_response_id": "chatcmpl-C8VPFAcCZ8m6qiCDEpoByF5VQe3IC"
    },
    "analysis_timestamp": "2025-08-25 13:36:39"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "usp_LoadAgencyChangesImportFromExcel",
      "definition": "CREATE PROCEDURE [budget].[usp_LoadAgencyChangesImportFromExcel]\r\n(\r\n\t@fy AS INT = NULL\r\n\t,@name AS VARCHAR(250) = NULL\r\n\t,@description AS VARCHAR(500) = NULL\r\n\t,@id AS INT OUTPUT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @ssispath AS VARCHAR(1000), @dtexecpath AS VARCHAR(500), @cmd AS VARCHAR(1000), @actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t\t,@maxAgencyChangeDetailEntityId AS INT, @importCounter AS INT;\r\n\tDECLARE @IdOutput TABLE (ID INT NULL);\r\n\r\n\tTRUNCATE TABLE Budget.AgencyChangesImportFromExcel;\r\n\tTRUNCATE TABLE Budget.AgencyChangesGroupedFromExcel;\r\n\r\n\t/**********************************************\r\n\t1. Load data into excel table\r\n\t**********************************************/\r\n\tSET @ssispath = 'Z:\\CSCBackup\\Agency changes FROM Survey.dtsx';\r\n\tSET @dtexecpath = '\"C:\\Program Files (x86)\\Microsoft SQL Server\\110\\DTS\\Binn\\DTExec.exe\"';\r\n\tSET @cmd = 'CMD /S /C \" ' + @dtexecpath + ' /f \"' + @ssispath + '\" \"'; -- set ssis path\r\n\t\r\n\tEXEC sp_configure 'show advanced options', 1;\r\n\tRECONFIGURE;\r\n\tEXEC sp_configure 'xp_cmdshell', 1;\r\n\tRECONFIGURE;\r\n\t\r\n\tEXEC xp_cmdshell @cmd;\r\n\t\r\n\tEXEC sp_configure 'show advanced options', 1;\r\n\tRECONFIGURE;\r\n\tEXEC sp_configure 'xp_cmdshell', 0;\r\n\tRECONFIGURE;\r\n\r\n\tDELETE FROM budget.AgencyChangesImportFromExcel WHERE agencycodeoec IS NULL;\r\n\r\n\t/**********************************************\r\n\t2. Insert into aggregate table\r\n\t**********************************************/\r\n\tINSERT INTO Budget.AgencyChangesGroupedFromExcel(PublishedBillingPeriod\r\n\t\t,BudgetGroupDEM\r\n\t\t,AgencyChangesEnergyUsage\r\n\t\t,AgencyChangesDemandUsage\r\n\t\t,AgencyCodeOEC\r\n\t\t,BillingPeriod\r\n\t\t,IsNewAddition\r\n\t\t,ShouldExclude\r\n\t\t,IsEIAP\r\n\t\t,AgencyChangesAccountReactivePowerEnergy\r\n\t\t,AgencyChangesOnPeakEnergyUsage\r\n\t\t,AgencyChangesStreetLightingFacilityPoints\r\n\t\t,AgencyChangesOffPeakEnergyUsage\r\n\t\t,BuildingID)\r\n\tSELECT PublishedBillingPeriod\r\n\t\t,BudgetGroupDEM\r\n\t\t,SUM(AgencyChangesEnergyUsage) AS AgencyChangesEnergyUsage\r\n\t\t,SUM(AgencyChangesDemandUsage) AS AgencyChangesDemandUsage\r\n\t\t,AgencyCodeOEC\r\n\t\t,BillingPeriod\r\n\t\t,MIN(IsNewAddition) AS IsNewAddition\r\n\t\t,MIN(ShouldExclude) AS ShouldExclude\r\n\t\t,MIN(isEIAP) AS isEIAP\r\n\t\t,SUM(AgencyChangesAccountReactivePowerEnergy) AS AgencyChangesAccountReactivePowerEnergy\r\n\t\t,SUM(AgencyChangesOnPeakEnergyUsage) AS AgencyChangesOnPeakEnergyUsage\r\n\t\t,SUM(AgencyChangesStreetLightingFacilityPoints) AS AgencyChangesStreetLightingFacilityPoints\r\n\t\t,SUM(AgencyChangesOffPeakEnergyUsage) AS AgencyChangesOffPeakEnergyUsage\r\n\t\t,BuildingID\r\n\tFROM Budget.AgencyChangesImportFromExcel\r\n\tGROUP BY PublishedBillingPeriod,\r\n\t\tBudgetGroupDEM,\r\n\t\tAgencyCodeOEC,\r\n\t\tBillingPeriod,\r\n\t\tBuildingID;\r\n\r\n\tSELECT @importCounter = COUNT(1) FROM Budget.AgencyChangesGroupedFromExcel;\r\n\r\n\t/**********************************************\r\n\t3. Create new collection of agency changes\r\n\t**********************************************/\r\n\tIF (@importCounter > 0)\r\n\tBEGIN\r\n\t\tset @fy = ISNULL(@fy, cast(CONVERT(VARCHAR(4), getdate(), 121) AS INT)+1)\r\n\t\tset @name = ISNULL(@name, @actionBy + ' UPLOAD ' + replace(replace(replace(CONVERT(VARCHAR(20), getdate(),120), ' ',''), ':', ''), '-',''))\r\n\t\tset @description = ISNULL(@description, @name)\r\n\r\n\t\tselect @maxAgencyChangeDetailEntityId=ISNULL(max(AgencyChangeDetailEntityId), 0)\r\n\t\tFROM [input].[AgencyChangeDetail];\r\n \r\n\t\t-- insert into agencyChange table \r\n\t\tINSERT INTO input.AgencyChange (FY, [Name], [Description], CreatedBy, ModifiedBy)\r\n\t\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\t\tVALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\t\tSELECT @id = ID FROM @IdOutput;\r\n\t   \r\n\t\tINSERT INTO input.AgencyChangeDetail(AgencyChangeID\r\n\t\t\t,AgencyCode\r\n\t\t\t,FacilityNo\r\n\t\t\t,BudgetGroupID\r\n\t\t\t,BillingPeriod\r\n\t\t\t,IsNewAddition\r\n\t\t\t,IsEIAP\r\n\t\t\t,DemandUsage\r\n\t\t\t,EnergyUsage\r\n\t\t\t,EnergyUsagePeakPercentage\r\n\t\t\t,EnergyUsageReactivePower\r\n\t\t\t,StreetLightingFacilityPoints\r\n\t\t\t,AgencyChangeDetailEntityId)\r\n\t\tSELECT @id\r\n\t\t\t,a.AgencyCodeOEC\r\n\t\t\t,CASE WHEN a.BuildingID IS NULL OR UPPER(a.BuildingID) = 'NULL' THEN '0000000' ELSE LEFT(LTRIM(a.BuildingID), 10) END\r\n\t\t\t,b.BudgetGroupID-- case when BudgetGroupDEM IS NULL then 35 else BudgetGroupDEM end\r\n\t\t\t,a.BillingPeriod\r\n\t\t\t,CASE WHEN a.IsNewAddition = 'N' THEN 0 ELSE 1 END\r\n\t\t\t,CASE WHEN a.IsEIAP = 'N' THEN 0 ELSE 1 END\r\n\t\t\t,ISNULL(a.AgencyChangesDemandUsage, 0)\r\n\t\t\t,ISNULL(a.AgencyChangesEnergyUsage, 0)\r\n\t\t\t,CASE WHEN ISNULL(a.AgencyChangesEnergyUsage, 0) = 0 THEN 0 ELSE a.AgencyChangesOnPeakEnergyUsage/a.AgencyChangesEnergyUsage END\r\n\t\t\t,ISNULL(a.AgencyChangesAccountReactivePowerEnergy, 0)\r\n\t\t\t,ISNULL(a.AgencyChangesStreetLightingFacilityPoints, 0)\r\n\t\t\t,@maxAgencyChangeDetailEntityId + (DENSE_RANK()\r\n\t\t\t\tOVER (ORDER BY a.AgencyCodeOEC\r\n\t\t\t\t\t,CASE WHEN a.BuildingID IS NULL OR UPPER(a.BuildingID) = 'NULL' THEN '0000000' ELSE LEFT(LTRIM(a.BuildingID), 10) END\r\n\t\t\t\t\t,b.BudgetGroupID))\r\n\t\tFROM Budget.AgencyChangesImportFromExcel AS a\r\n\t\t\tINNER JOIN EC3DB.BudgetApp_vwBudgetGroups AS b ON (CASE WHEN a.BudgetGroupDEM IS NULL THEN 35 ELSE a.BudgetGroupDEM END) = b.BudgetGroupID\r\n\t\tWHERE a.AgencyCodeOEC IS NULL;\r\n\tEND;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.590000",
      "last_altered": "2025-08-25 15:54:05.590000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "usp_LoadAgencyChangesImportFromExcel",
      "explanation": "#### 1. Overview\nThe stored procedure `usp_LoadAgencyChangesImportFromExcel` is designed to import and process agency change data from an Excel file into a SQL Server database. It utilizes SQL Server Integration Services (SSIS) to load data from an Excel file into temporary tables, processes and aggregates this data, and then inserts it into permanent tables for further use. The procedure involves several steps, including data truncation, SSIS package execution, data aggregation, and insertion into target tables.\n\n#### 2. Complexity Level: Medium\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: Represents the fiscal year for the agency changes. If not provided, it defaults to the next year based on the current date.\n- `@name AS VARCHAR(250) = NULL`: Represents the name of the agency change upload. If not provided, it defaults to a system-generated name based on the current date and time.\n- `@description AS VARCHAR(500) = NULL`: Represents a description of the agency change upload. Defaults to the same value as `@name` if not provided.\n- `@id AS INT OUTPUT`: An output parameter that returns the ID of the newly inserted record in the `input.AgencyChange` table.\n\n#### 4. Business Logic and Workflow\n1. **Initialization and Setup**: \n   - The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages.\n   - It declares several local variables for paths, commands, and counters.\n\n2. **Data Preparation**:\n   - Truncates the tables `Budget.AgencyChangesImportFromExcel` and `Budget.AgencyChangesGroupedFromExcel` to ensure they are empty before loading new data.\n\n3. **Data Loading**:\n   - Sets the paths for the SSIS package and the `DTExec` utility.\n   - Constructs a command to execute the SSIS package using `xp_cmdshell`.\n   - Temporarily enables `xp_cmdshell` to run the command, then disables it afterward for security reasons.\n   - Deletes any rows from `Budget.AgencyChangesImportFromExcel` where `agencycodeoec` is NULL.\n\n4. **Data Aggregation**:\n   - Aggregates data from `Budget.AgencyChangesImportFromExcel` into `Budget.AgencyChangesGroupedFromExcel` using a `GROUP BY` clause and various aggregate functions like `SUM` and `MIN`.\n\n5. **Data Insertion**:\n   - Checks if there are any records in `Budget.AgencyChangesGroupedFromExcel`.\n   - If records exist, it sets default values for `@fy`, `@name`, and `@description` if they are NULL.\n   - Inserts a new record into `input.AgencyChange` and captures the inserted ID.\n   - Inserts detailed records into `input.AgencyChangeDetail` using a `SELECT` statement with a `DENSE_RANK` function to generate unique entity IDs.\n\n#### 5. Performance Considerations\n- **Truncation and Deletion**: Truncating tables and deleting rows can be resource-intensive, especially if the tables are large.\n- **SSIS Execution**: Running SSIS packages via `xp_cmdshell` can be slow and may block other operations if not managed properly.\n- **Aggregation**: The aggregation process could be optimized by ensuring indexes are in place on the columns used in `GROUP BY` and `JOIN` operations.\n- **Concurrency**: The use of `xp_cmdshell` and table truncation may affect concurrency and should be managed carefully in a multi-user environment.\n\n#### 6. Potential Issues or Risks\n- **Security Risks**: Enabling `xp_cmdshell` poses a security risk as it allows execution of arbitrary commands on the server. It should be used with caution and disabled immediately after use.\n- **Data Integrity**: The procedure assumes that the SSIS package will always execute successfully and load data correctly. Any failure in the SSIS execution could lead to incomplete or incorrect data processing.\n- **Error Handling**: The procedure lacks error handling mechanisms. Any failure in the SSIS execution or SQL operations could cause the procedure to fail without a clear indication of the issue.\n- **Hardcoded Paths**: The SSIS package path and `DTExec` path are hardcoded, which could lead to issues if the server configuration changes.\n- **NULL Handling**: The procedure deletes rows with NULL `agencycodeoec` but does not handle other potential NULL values that might affect data integrity during aggregation and insertion.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 2592,
      "api_response_id": "chatcmpl-C8VPUpdWBFXVallgfhVJgYwXsTTSx"
    },
    "analysis_timestamp": "2025-08-25 13:37:16"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "usp_Report_BaseBudgetStagingByAgency",
      "definition": "CREATE PROCEDURE [budget].[usp_Report_BaseBudgetStagingByAgency]\r\n(\r\n\t@EmailAddress AS VARCHAR(75),\r\n\t@AgencyCodeOEC AS VARCHAR(MAX), -- * for all\r\n\t@AnnualOrMonthly AS CHAR(1) -- A - annual || M - monthly\r\n)\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n\r\n    DECLARE @BaseBudgetDataGroupByAgency TABLE(BudgetStage VARCHAR(100) NULL,\r\n\t    PublishedBillingPeriod VARCHAR(6) NULL,\r\n\t    BillingPeriod VARCHAR(6) NULL,\r\n\t    AgencyCodeOEC VARCHAR(6) NULL,\r\n\t    AgencyName VARCHAR(75) NULL,\r\n\t    EnergyDeliveryType VARCHAR(3) NULL,\r\n\t    BudgetGroupDEM INT NULL,\r\n\t    BudgetGroupDEMName VARCHAR(75) NULL,\r\n\t    GenericEnergyDeliveryType VARCHAR(24) NULL,\r\n\t    GenericEnergyDeliveryTypeUnit VARCHAR(24) NULL,\r\n\t    EnergyUsage FLOAT NULL,\r\n\t    StreetLightingFacilityPoints INT NULL,\r\n\t    FacilityPointDollars MONEY NULL,\r\n\t    EnergyDollars MONEY NULL,\r\n\t    DemandDollars MONEY NULL,\r\n\t    AgencyDivisionSeqId INT NULL,\r\n\t    AgencyOECL1 VARCHAR(6) NULL,\r\n\t    AgencyOECL2 VARCHAR(6) NULL,\r\n\t    AgencyOECL3 VARCHAR(6) NULL,\r\n\t    AgencyLevel INT NULL);\r\n\r\n    DECLARE @AgencyDivision TABLE(AgencyCodeOEC VARCHAR(6) NOT NULL PRIMARY KEY,\r\n\t    parentAgencyCode VARCHAR(6) NULL,\r\n\t    grandParantAgencyCode VARCHAR(6) NULL,\r\n\t    agencyLevel INT NULL,\r\n\t    AgencyOECL1 VARCHAR(6) NULL,\r\n\t    AgencyOECL2 VARCHAR(6) NULL,\r\n\t    AgencyOECL3 VARCHAR(6) NULL,\r\n\t    AgencyDivisionHierarchy HIERARCHYID NULL,\r\n\t    AgencyShortDesc VARCHAR(75) NULL,\r\n\t    AgencyDivisionSeqId INT NULL,\r\n\t    IsHidden CHAR(1) NULL); -- data is hidden in report \r\n\r\n    DECLARE @fy AS INT, @publishedBillingPeriod AS VARCHAR(7), @currentScenarioId AS INT;\r\n\t\r\n\tSELECT @currentScenarioId = ISNULL(MAX(ID),0), @fy = MAX(FY)\r\n\tFROM budget.Scenario WHERE IsCurrentBudget = 1;\r\n\r\n\tSELECT @publishedBillingPeriod = CAST(@fy-2 AS VARCHAR(4)) + '01';\r\n\r\n    -- ========================================================\r\n    -- 1 parepare agency division \r\n    -- ========================================================\r\n    WITH agencyRaw AS\r\n    (SELECT a.AgencyId\r\n        ,b.ParentAgencyId\r\n\t    ,CAST(b.AgencyDivisionHierarchy AS VARCHAR) AS hierarchy\r\n\t    ,LEN(CAST(b.AgencyDivisionHierarchy AS VARCHAR))-LEN(REPLACE(CAST(b.AgencyDivisionHierarchy AS VARCHAR), '/','')) AS times\r\n\t    ,b.AgencyDivisionHierarchy.GetLevel() AS agencyLevel\r\n\tFROM Preload.Agency AS a\r\n        INNER JOIN Preload.AgencyByFY AS b ON a.AgencyId = b.AgencyId\r\n\tWHERE b.FY = @fy)\r\n    ,agencyHierarchy AS\r\n    (SELECT agencyid, agencyLevel, ParentAgencyId, NULL AS GrandParentAgencyId FROM agencyRaw WHERE times IN (2,3)\r\n\tUNION\r\n\tSELECT agencyid, agencyLevel, ParentAgencyId, SUBSTRING(hierarchy,2, CHARINDEX('/',hierarchy, 2)-2) AS GrandParentAgencyId FROM agencyRaw WHERE times = 4)\r\n    ,filteredAgencies AS\r\n    (SELECT AgencyCodeOEC \r\n\tFROM billing.uftn_TableGetAllAgencyChildrenByAgencyCodeOEC(@AgencyCodeOEC, @EmailAddress))\r\n\r\n    INSERT INTO @AgencyDivision\r\n        (AgencyCodeOEC\r\n        ,parentAgencyCode\r\n        ,grandParantAgencyCode\r\n        ,agencyLevel\r\n        ,AgencyOECL1\r\n        ,AgencyOECL2\r\n        ,AgencyOECL3\r\n        ,AgencyDivisionHierarchy\r\n\t\t,AgencyShortDesc\r\n\t\t,AgencyDivisionSeqId\r\n\t\t,IsHidden)\r\n    SELECT child.AgencyCodeOEC\r\n\t\t,parent.AgencyCodeOEC AS parentAgencyCode\r\n\t\t,grandParent.AgencyCodeOEC AS grandParantAgencyCode\r\n\t\t,child.AgencyDivisionHierarchy.GetLevel() AS agencyLevel\r\n\t\t,IIF(a.agencyLevel=3, grandParent.AgencyCodeOEC, IIF(a.agencyLevel=2, parent.AgencyCodeOEC, child.AgencyCodeOEC)) AS AgencyOECL1\r\n\t\t,IIF(a.agencyLevel=3, parent.AgencyCodeOEC, IIF(a.agencyLevel=2, child.AgencyCodeOEC, '000000')) AS AgencyOECL2\r\n\t\t,IIF(a.agencyLevel=3, child.AgencyCodeOEC, '000000') AS AgencyOECL3\r\n\t\t,child.AgencyDivisionHierarchy\r\n\t\t,child.AgencyName\r\n\t\t,a.agencyId AS AgencyDivisionSeqId\r\n\t\t,'N' AS IsHidden\r\n    FROM agencyHierarchy AS a\r\n        INNER JOIN Preload.vwAgencies AS child ON child.FY = @fy AND a.AgencyId = child.AgencyId\r\n        INNER JOIN filteredAgencies AS f ON child.AgencyCodeOEC = f.AgencyCodeOEC\r\n        LEFT JOIN Preload.Agency AS parent ON a.ParentAgencyId = parent.AgencyId\r\n        LEFT JOIN Preload.Agency AS grandParent ON a.GrandParentAgencyId = grandParent.AgencyId;\r\n\r\n    -- ========================================================\r\n    -- 2 Add base budget data\r\n    -- ========================================================\r\n    INSERT INTO @BaseBudgetDataGroupByAgency\r\n        (BudgetStage,\r\n        PublishedBillingPeriod,\r\n        BillingPeriod,\r\n        AgencyCodeOEC,\r\n        AgencyName,\r\n        EnergyDeliveryType,\r\n        BudgetGroupDEM,\r\n        BudgetGroupDEMName,\r\n        GenericEnergyDeliveryType,\r\n        GenericEnergyDeliveryTypeUnit,\r\n        EnergyUsage,\r\n        StreetLightingFacilityPoints,\r\n        FacilityPointDollars,\r\n        EnergyDollars,\r\n        DemandDollars,\r\n        AgencyDivisionSeqId,\r\n        AgencyOECL1,\r\n\t\tAgencyOECL2,\r\n\t\tAgencyOECL3,\r\n\t\tAgencyLevel)\r\n    SELECT B.BudgetStage,\r\n        @publishedBillingPeriod AS PublishedBillingPeriod,\r\n        CASE WHEN @AnnualOrMonthly = 'M' THEN MAX(B.BillingPeriod) ELSE '' END,\r\n        B.AgencyCodeOEC,\r\n        B.AgencyName,\r\n        B.EnergyDeliveryType ,\r\n        B.BudgetGroupDEM ,\r\n        B.BudgetGroupDEMName ,\r\n        B.GenericEnergyDeliveryType ,\r\n        B.GenericEnergyDeliveryTypeUnit ,\r\n        SUM(B.EnergyUsage) ,\r\n        SUM(B.StreetLightingFacilityPoints) ,\r\n        SUM(B.FacilityPointDollars) ,\r\n        SUM(B.EnergyDollars) ,\r\n        SUM(B.DemandDollars) ,\r\n        A.AgencyDivisionSeqId,\r\n        A.AgencyOECL1,\r\n\t\tA.AgencyOECL2,\r\n\t\tA.AgencyOECL3,\r\n\t\tA.agencyLevel\r\n    FROM budget.vwBaseBudgetByAgencySummaryByAgencyEnergyType AS B\r\n        INNER JOIN @AgencyDivision AS A ON B.AgencyCodeOEC = A.AgencyCodeOEC\r\n    WHERE B.scenarioid=@currentScenarioId \r\n    GROUP BY B.BudgetStage ,\r\n        CASE WHEN @AnnualOrMonthly = 'M' THEN B.BillingPeriod END,\r\n        B.AgencyCodeOEC ,\r\n        B.AgencyName ,\r\n        B.EnergyDeliveryType ,\r\n        B.BudgetGroupDEM ,\r\n        B.BudgetGroupDEMName ,\r\n        B.GenericEnergyDeliveryType ,\r\n        B.GenericEnergyDeliveryTypeUnit ,\r\n        A.AgencyDivisionSeqId,\r\n        A.AgencyOECL1,\r\n\t\tA.AgencyOECL2,\r\n\t\tA.AgencyOECL3,\r\n\t\tA.agencyLevel;\r\n\r\n    -- ========================================================\r\n    -- 3 group data for parent agencies\r\n    -- ========================================================\r\n\r\n    -- level 1 data\r\n    INSERT INTO @BaseBudgetDataGroupByAgency\r\n        (BudgetStage,\r\n        PublishedBillingPeriod,\r\n        BillingPeriod,\r\n        AgencyCodeOEC,\r\n        AgencyName,\r\n        EnergyDeliveryType,\r\n        BudgetGroupDEM,\r\n        BudgetGroupDEMName,\r\n        GenericEnergyDeliveryType,\r\n        GenericEnergyDeliveryTypeUnit,\r\n        EnergyUsage,\r\n        StreetLightingFacilityPoints,\r\n        FacilityPointDollars,\r\n        EnergyDollars,\r\n        DemandDollars,\r\n        AgencyDivisionSeqId,\r\n        AgencyOECL1,\r\n\t\tAgencyOECL2,\r\n\t\tAgencyOECL3,\r\n\t\tAgencyLevel) \r\n    SELECT B.BudgetStage,\r\n        B.PublishedBillingPeriod,\r\n        B.BillingPeriod,\r\n        B.AgencyOECL1,\r\n        MAX(A.AgencyShortDesc),\r\n        B.EnergyDeliveryType,\r\n        B.BudgetGroupDEM,\r\n        B.BudgetGroupDEMName,\r\n        B.GenericEnergyDeliveryType,\r\n        B.GenericEnergyDeliveryTypeUnit,\r\n        SUM(B.EnergyUsage),\r\n        SUM(B.StreetLightingFacilityPoints),\r\n        SUM(B.FacilityPointDollars),\r\n        SUM(B.EnergyDollars),\r\n        SUM(B.DemandDollars),\r\n        MAX(A.AgencyDivisionSeqId),\r\n        B.AgencyOECL1,\r\n\t\t'000000' AS AgencyOECL2,\r\n\t\t'000000' AS AgencyOECL3,\r\n\t\tMAX(A.agencyLevel)\r\n    FROM @BaseBudgetDataGroupByAgency AS B\r\n\t    INNER JOIN @AgencyDivision AS A ON B.AgencyOECL1 = A.AgencyCodeOEC -- join for Level 1 data\r\n    WHERE B.AgencyCodeOEC <> B.AgencyOECL1\r\n\t      AND B.AgencyOECL1 <> '000000'\r\n    GROUP BY B.BudgetStage, \r\n\t\tB.AgencyOECL1, \r\n\t\tB.PublishedBillingPeriod,\r\n\t\tB.BillingPeriod,\r\n\t\tB.EnergyDeliveryType,\r\n        B.BudgetGroupDEM,\r\n        B.BudgetGroupDEMName,\r\n        B.GenericEnergyDeliveryType,\r\n        B.GenericEnergyDeliveryTypeUnit;\r\n\r\n    -- level 2 data\r\n    INSERT INTO @BaseBudgetDataGroupByAgency\r\n        (BudgetStage,\r\n        PublishedBillingPeriod,\r\n        BillingPeriod,\r\n        AgencyCodeOEC,\r\n        AgencyName,\r\n        EnergyDeliveryType,\r\n        BudgetGroupDEM,\r\n        BudgetGroupDEMName,\r\n        GenericEnergyDeliveryType,\r\n        GenericEnergyDeliveryTypeUnit,\r\n        EnergyUsage,\r\n        StreetLightingFacilityPoints,\r\n        FacilityPointDollars,\r\n        EnergyDollars,\r\n        DemandDollars,\r\n        AgencyDivisionSeqId,\r\n        AgencyOECL1,\r\n\t\tAgencyOECL2,\r\n\t\tAgencyOECL3,\r\n\t\tAgencyLevel) \r\n    SELECT B.BudgetStage,\r\n        B.PublishedBillingPeriod,\r\n        B.BillingPeriod,\r\n        B.AgencyOECL2,\r\n        MAX(A.AgencyShortDesc),\r\n        B.EnergyDeliveryType,\r\n        B.BudgetGroupDEM,\r\n        B.BudgetGroupDEMName,\r\n        B.GenericEnergyDeliveryType,\r\n        B.GenericEnergyDeliveryTypeUnit,\r\n        SUM(B.EnergyUsage),\r\n        SUM(B.StreetLightingFacilityPoints),\r\n        SUM(B.FacilityPointDollars),\r\n        SUM(B.EnergyDollars),\r\n        SUM(B.DemandDollars),\r\n        MAX(A.AgencyDivisionSeqId),\r\n        B.AgencyOECL1,\r\n\t\tB.AgencyOECL2,\r\n\t\t'000000' AS AgencyOECL3,\r\n\t\tMAX(A.agencyLevel)\r\n    FROM @BaseBudgetDataGroupByAgency AS B\r\n\t    INNER JOIN @AgencyDivision AS A ON B.AgencyOECL2 = A.AgencyCodeOEC -- join for Level 1 data\r\n    WHERE B.AgencyCodeOEC <> B.AgencyOECL2 and\r\n\t      B.AgencyOECL2 <> '000000'\r\n    GROUP BY B.BudgetStage, \r\n\t\tB.AgencyOECL1, \r\n\t\tB.AgencyOECL2,\r\n\t\tB.PublishedBillingPeriod,\r\n\t\tB.BillingPeriod,\r\n\t\tB.EnergyDeliveryType ,\r\n        B.BudgetGroupDEM ,\r\n        B.BudgetGroupDEMName ,\r\n        B.GenericEnergyDeliveryType,\r\n        B.GenericEnergyDeliveryTypeUnit;\r\n\r\n    -- ========================================================\r\n    -- 4 Group total cost\r\n    -- ========================================================\r\n    INSERT INTO @BaseBudgetDataGroupByAgency\r\n        (BudgetStage,\r\n        PublishedBillingPeriod,\r\n        BillingPeriod,\r\n        AgencyCodeOEC,\r\n        AgencyName,\r\n        EnergyDeliveryType,\r\n        BudgetGroupDEM,\r\n        BudgetGroupDEMName,\r\n        GenericEnergyDeliveryType,\r\n        GenericEnergyDeliveryTypeUnit,\r\n        EnergyUsage,\r\n        StreetLightingFacilityPoints,\r\n        FacilityPointDollars,\r\n        EnergyDollars,\r\n        DemandDollars,\r\n        AgencyDivisionSeqId,\r\n        AgencyOECL1,\r\n\t\tAgencyOECL2,\r\n\t\tAgencyOECL3,\r\n\t\tAgencyLevel) \r\n    SELECT B.BudgetStage,\r\n        B.PublishedBillingPeriod,\r\n        B.BillingPeriod,\r\n        B.AgencyCodeOEC,\r\n        MAX(B.AgencyName),\r\n        NULL,\r\n        NULL,\r\n        NULL,\r\n        NULL,\r\n        'Total Cost',\r\n        SUM(B.EnergyUsage) ,\r\n        SUM(B.StreetLightingFacilityPoints),\r\n        SUM(B.FacilityPointDollars),\r\n        SUM(B.EnergyDollars),\r\n        SUM(B.DemandDollars),\r\n        MAX(B.AgencyDivisionSeqId),\r\n        MAX(B.AgencyOECL1),\r\n\t\tMAX(B.AgencyOECL2),\r\n\t\tMAX(B.AgencyOECL3),\r\n\t\tMAX(B.agencyLevel)\r\n    FROM @BaseBudgetDataGroupByAgency AS B\r\n    WHERE B.GenericEnergyDeliveryTypeUnit = 'Cost'\r\n    GROUP BY B.BudgetStage,\r\n\t\tB.AgencyCodeOEC,\r\n\t\tB.PublishedBillingPeriod,\r\n\t\tB.BillingPeriod;\r\n\r\n    SELECT BudgetStage,\r\n        PublishedBillingPeriod,\r\n        BillingPeriod,\r\n        B.AgencyCodeOEC,\r\n        AgencyName,\r\n        EnergyDeliveryType,\r\n        BudgetGroupDEM,\r\n        BudgetGroupDEMName,\r\n        GenericEnergyDeliveryType,\r\n        GenericEnergyDeliveryTypeUnit,\r\n        SUM(EnergyUsage) AS EnergyUsage,\r\n        SUM(StreetLightingFacilityPoints) AS StreetLightingFacilityPoints,\r\n        SUM(FacilityPointDollars) AS FacilityPointDollars,\r\n        SUM(EnergyDollars) AS EnergyDollars,\r\n        SUM(DemandDollars) AS DemandDollars,\r\n        B.AgencyDivisionSeqId,\r\n        AgencyOECL1,\r\n\t    AgencyOECL2,\r\n\t    AgencyOECL3,\r\n\t    AgencyLevel \r\n    FROM @BaseBudgetDataGroupByAgency AS B\r\n    GROUP BY BudgetStage, PublishedBillingPeriod, BillingPeriod, B.AgencyCodeOEC, AgencyName\r\n        ,EnergyDeliveryType, BudgetGroupDEM, BudgetGroupDEMName, GenericEnergyDeliveryType, GenericEnergyDeliveryTypeUnit\r\n        ,B.AgencyDivisionSeqId, AgencyOECL1,  AgencyOECL2,  AgencyOECL3, AgencyLevel \r\n    ORDER BY AgencyOECL1, AgencyOECL2, AgencyOECL3, EnergyDeliveryType, B.BudgetGroupDEM,\r\n    CASE WHEN GenericEnergyDeliveryTypeUnit = 'Cost' THEN 'sss' ELSE GenericEnergyDeliveryTypeUnit END;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.643000",
      "last_altered": "2025-08-25 15:54:05.643000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@EmailAddress",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 75,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@AgencyCodeOEC",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@AnnualOrMonthly",
        "data_type": "char",
        "mode": "IN",
        "max_length": 1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "usp_Report_BaseBudgetStagingByAgency",
      "explanation": "#### 1. Overview\n\nThe stored procedure `usp_Report_BaseBudgetStagingByAgency` is designed to generate a report of base budget data grouped by agency. It processes budget data for a specified fiscal year and organizes it by agency hierarchy, allowing for both detailed and aggregated views. The procedure supports filtering by agency and can produce either annual or monthly reports. The results are grouped and aggregated at different levels of the agency hierarchy, and the final output is ordered by agency and energy delivery type.\n\n#### 2. Complexity Level: Medium\n\nThe procedure involves multiple steps, including data preparation, hierarchical data processing, and aggregation. It uses temporary tables, common table expressions (CTEs), and complex joins, which contribute to its medium complexity. The logic for handling hierarchical data and grouping at different levels adds to the complexity.\n\n#### 3. Input Parameters\n\n- `@EmailAddress AS VARCHAR(75)`: Used to identify the user requesting the report, potentially for filtering or logging purposes.\n- `@AgencyCodeOEC AS VARCHAR(MAX)`: Specifies the agency code to filter the report. A wildcard (`*`) can be used to include all agencies.\n- `@AnnualOrMonthly AS CHAR(1)`: Determines the report type, where 'A' indicates an annual report and 'M' indicates a monthly report.\n\n#### 4. Business Logic and Workflow\n\n1. **Initialization**: \n   - Disables the count of affected rows to improve performance.\n   - Declares temporary tables to store agency division data and base budget data.\n\n2. **Scenario and Period Setup**:\n   - Retrieves the current scenario ID and fiscal year from the `budget.Scenario` table.\n   - Calculates the published billing period based on the fiscal year.\n\n3. **Agency Division Preparation**:\n   - Uses CTEs to construct agency hierarchy data, identifying parent and grandparent agencies.\n   - Filters agencies based on the provided `@AgencyCodeOEC` using a user-defined function.\n   - Inserts the hierarchical agency data into the `@AgencyDivision` temporary table.\n\n4. **Base Budget Data Insertion**:\n   - Inserts detailed budget data into `@BaseBudgetDataGroupByAgency`, joining with the agency division data.\n   - Aggregates data based on the `@AnnualOrMonthly` parameter.\n\n5. **Parent Agency Grouping**:\n   - Aggregates data for parent agencies at different hierarchy levels (Level 1 and Level 2).\n   - Inserts aggregated data back into the `@BaseBudgetDataGroupByAgency` table.\n\n6. **Total Cost Grouping**:\n   - Aggregates total cost data for each agency and inserts it into the temporary table.\n\n7. **Final Output**:\n   - Selects and groups the final report data from `@BaseBudgetDataGroupByAgency`.\n   - Orders the results by agency hierarchy and energy delivery type.\n\n#### 5. Performance Considerations\n\n- **Use of Temporary Tables**: Temporary tables are used extensively, which can impact performance if the data volume is large. Indexing these tables could improve performance.\n- **Complex Joins and Aggregations**: The procedure involves multiple joins and aggregations, which can be resource-intensive.\n- **NOCOUNT Setting**: The use of `SET NOCOUNT ON` helps reduce network traffic by preventing the sending of DONE_IN_PROC messages.\n\n#### 6. Potential Issues or Risks\n\n- **Scalability**: The procedure may face performance issues with large datasets due to the use of temporary tables and complex joins.\n- **Concurrency**: If multiple users execute this procedure simultaneously, it could lead to contention on system resources.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions and unclear error messages.\n- **Security**: The procedure does not include any security checks or validation for the input parameters, which could be a risk if the inputs are not properly sanitized or validated elsewhere in the application.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 4138,
      "api_response_id": "chatcmpl-C8VQ5tnCqZ3bV4gHbchgQAisbCNie"
    },
    "analysis_timestamp": "2025-08-25 13:37:28"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "usp_Report_BaseBudgetStagingByAgency_Updated",
      "definition": "CREATE PROCEDURE [budget].[usp_Report_BaseBudgetStagingByAgency_Updated]\r\n(\r\n\t@EmailAddress AS VARCHAR(75)\r\n\t,@AgencyCodeOEC AS VARCHAR(MAX)\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @AnnualOrMonthly AS CHAR(1) = 'M';\r\n\r\n\tDECLARE @BaseBudgetDataGroupByAgency TABLE(BudgetStage VARCHAR(100) NULL\r\n\t\t,PublishedBillingPeriod VARCHAR(6) NULL\r\n\t\t,BillingPeriod VARCHAR(6) NULL\r\n\t\t,AgencyCodeOEC VARCHAR(6) NULL\r\n\t\t,AgencyName VARCHAR(75) NULL\r\n\t\t,EnergyDeliveryType VARCHAR(3) NULL\r\n\t\t,BudgetGroupDEM INT NULL\r\n\t\t,BudgetGroupDEMName VARCHAR(75) NULL\r\n\t\t,GenericEnergyDeliveryType VARCHAR(24) NULL\r\n\t\t,GenericEnergyDeliveryTypeUnit VARCHAR(24) NULL\r\n\t\t,EnergyUsage DECIMAL(18,2) NULL\r\n\t\t,StreetLightingFacilityPoints INT NULL\r\n\t\t,FacilityPointDollars MONEY NULL\r\n\t\t,EnergyDollars MONEY NULL\r\n\t\t,DemandDollars MONEY NULL\r\n\t\t,AgencyDivisionSeqId INT NULL\r\n\t\t,AgencyOECL1 VARCHAR(6) NULL\r\n\t\t,AgencyOECL2 VARCHAR(6) NULL\r\n\t\t,AgencyOECL3 VARCHAR(6) NULL\r\n\t\t,AgencyLevel INT NULL);\r\n\r\n\tDECLARE @AgencyDivision TABLE(AgencyCodeOEC VARCHAR(6) NOT NULL PRIMARY KEY\r\n\t\t,parentAgencyCode VARCHAR(6) NULL\r\n\t\t,grandParantAgencyCode VARCHAR(6) NULL\r\n\t\t,agencyLevel INT NULL\r\n\t\t,AgencyOECL1 VARCHAR(6) NULL\r\n\t\t,AgencyOECL2 VARCHAR(6) NULL\r\n\t\t,AgencyOECL3 VARCHAR(6) NULL\r\n\t\t,AgencyDivisionHierarchy HIERARCHYID NULL\r\n\t\t,AgencyShortDesc VARCHAR(75) NULL\r\n\t\t,AgencyDivisionSeqId INT NULL\r\n\t\t,IsHidden CHAR(1) NULL);\r\n\r\n\tDECLARE @fy AS INT, @publishedBillingPeriod AS VARCHAR(7), @currentScenarioId AS INT;\r\n\t\r\n\tSELECT @currentScenarioId = ISNULL(MAX(ID),0), @fy = MAX(FY)\r\n\tFROM budget.Scenario WHERE IsCurrentBudget = 1;\r\n\r\n\tSELECT @publishedBillingPeriod = CAST(@fy-2 AS VARCHAR(4)) + '01';\r\n\t--=========================================================================\r\n\t-- 1 parepare agency division\r\n\t--=========================================================================\r\n\r\n    WITH agencyRaw AS (SELECT a.AgencyID\r\n\t\t\t,b.ParentAgencyID\r\n\t\t\t,CAST(b.AgencyDivisionHierarchy AS VARCHAR(100)) AS hierarchy\r\n\t\t\t,LEN(CAST(b.AgencyDivisionHierarchy AS VARCHAR(100)))-LEN(REPLACE(CAST(b.AgencyDivisionHierarchy AS VARCHAR(100)), '/','')) AS times\r\n\t\t\t,b.AgencyDivisionHierarchy.GetLevel() AS agencyLevel\r\n\t\tFROM Preload.Agency AS a\r\n\t\t\tINNER JOIN Preload.AgencyByFY AS b ON a.AgencyId = b.AgencyId\r\n\t\tWHERE b.FY = @fy)\r\n    ,agencyHierarchy AS (SELECT AgencyID, agencyLevel, ParentAgencyId, NULL AS GrandParentAgencyId FROM agencyRaw WHERE times IN (2, 3)\r\n\t\tUNION\r\n\t\tSELECT AgencyID, agencyLevel, ParentAgencyId, SUBSTRING(hierarchy,2, CHARINDEX('/',hierarchy, 2)-2) AS GrandParentAgencyId FROM agencyRaw WHERE times = 4)\r\n    ,filteredAgencies AS (SELECT AgencyCodeOEC FROM billing.uftn_TableGetAllAgencyChildrenByAgencyCodeOEC(@AgencyCodeOEC, @EmailAddress))\r\n\r\n    INSERT INTO @AgencyDivision\r\n        (AgencyCodeOEC\r\n        ,parentAgencyCode\r\n        ,grandParantAgencyCode\r\n        ,agencyLevel\r\n        ,AgencyOECL1\r\n        ,AgencyOECL2\r\n        ,AgencyOECL3\r\n        ,AgencyDivisionHierarchy\r\n\t\t,AgencyShortDesc\r\n\t\t,AgencyDivisionSeqId\r\n\t\t,IsHidden)\r\n    SELECT DISTINCT child.AgencyCodeOEC\r\n\t\t,parent.AgencyCodeOEC AS parentAgencyCode\r\n\t\t,grandParent.AgencyCodeOEC AS grandParantAgencyCode\r\n\t\t,child.AgencyDivisionHierarchy.GetLevel() AS agencyLevel\r\n\t\t,IIF(a.agencyLevel = 3, grandParent.AgencyCodeOEC, IIF(a.agencyLevel = 2, parent.AgencyCodeOEC, child.AgencyCodeOEC)) AS AgencyOECL1\r\n\t\t,IIF(a.agencyLevel = 3, parent.AgencyCodeOEC, IIF(a.agencyLevel = 2, child.AgencyCodeOEC, '000000')) AS AgencyOECL2\r\n\t\t,IIF(a.agencyLevel = 3, child.AgencyCodeOEC, '000000') AS AgencyOECL3\r\n\t\t,child.AgencyDivisionHierarchy\r\n\t\t,child.AgencyName\r\n\t\t,a.agencyId AS AgencyDivisionSeqId\r\n\t\t,'N' AS IsHidden\r\n    FROM agencyHierarchy AS a\r\n        INNER JOIN Preload.vwAgencies AS child ON child.FY = @fy AND a.AgencyId = child.AgencyId\r\n        INNER JOIN filteredAgencies AS f ON child.AgencyCodeOEC = f.AgencyCodeOEC\r\n        LEFT JOIN Preload.Agency AS parent ON a.ParentAgencyId = parent.AgencyId\r\n        LEFT JOIN Preload.Agency AS grandParent ON a.GrandParentAgencyId = grandParent.AgencyId;\r\n\r\n    --=========================================================================\r\n    -- 2 Add base budget data\r\n    --=========================================================================\r\n    INSERT INTO @BaseBudgetDataGroupByAgency\r\n        (BudgetStage\r\n        ,PublishedBillingPeriod\r\n        ,BillingPeriod\r\n        ,AgencyCodeOEC\r\n        ,AgencyName\r\n        ,EnergyDeliveryType\r\n        ,BudgetGroupDEM\r\n        ,BudgetGroupDEMName\r\n        ,GenericEnergyDeliveryType\r\n        ,GenericEnergyDeliveryTypeUnit\r\n        ,EnergyUsage\r\n        ,StreetLightingFacilityPoints\r\n        ,FacilityPointDollars\r\n        ,EnergyDollars\r\n        ,DemandDollars\r\n        ,AgencyDivisionSeqId\r\n        ,AgencyOECL1\r\n\t\t,AgencyOECL2\r\n\t\t,AgencyOECL3\r\n\t\t,AgencyLevel)\r\n    SELECT B.BudgetStage\r\n        ,@publishedBillingPeriod AS PublishedBillingPeriod\r\n        ,CASE WHEN @AnnualOrMonthly = 'M' THEN MAX(B.BillingPeriod) ELSE '' END\r\n        ,B.AgencyCodeOEC\r\n        ,B.AgencyName\r\n        ,B.EnergyDeliveryType\r\n        ,B.BudgetGroupDEM\r\n        ,B.BudgetGroupDEMName\r\n        ,B.GenericEnergyDeliveryType\r\n        ,B.GenericEnergyDeliveryTypeUnit\r\n        ,SUM(B.EnergyUsage)\r\n        ,SUM(B.StreetLightingFacilityPoints)\r\n        ,SUM(B.FacilityPointDollars)\r\n        ,SUM(B.EnergyDollars)\r\n        ,SUM(B.DemandDollars)\r\n        ,A.AgencyDivisionSeqId\r\n        ,A.AgencyOECL1\r\n\t\t,A.AgencyOECL2\r\n\t\t,A.AgencyOECL3\r\n\t\t,A.agencyLevel\r\n    FROM budget.vwBaseBudgetByAgencySummaryByAgencyEnergyType AS B\r\n        INNER JOIN @AgencyDivision AS A ON B.AgencyCodeOEC = A.AgencyCodeOEC\r\n    WHERE B.scenarioid = @currentScenarioId\r\n    GROUP BY B.BudgetStage\r\n\t\t,CASE WHEN @AnnualOrMonthly = 'M' THEN B.BillingPeriod END\r\n\t\t,B.AgencyCodeOEC\r\n\t\t,B.AgencyName\r\n\t\t,B.EnergyDeliveryType\r\n\t\t,B.BudgetGroupDEM\r\n\t\t,B.BudgetGroupDEMName\r\n\t\t,B.GenericEnergyDeliveryType\r\n\t\t,B.GenericEnergyDeliveryTypeUnit\r\n\t\t,A.AgencyDivisionSeqId\r\n\t\t,A.AgencyOECL1\r\n\t\t,A.AgencyOECL2\r\n\t\t,A.AgencyOECL3\r\n\t\t,A.agencyLevel;\r\n\r\n    --=========================================================================\r\n    -- 3 group data for parent agencies\r\n    --=========================================================================\r\n    -- level 1 data\r\n    INSERT INTO @BaseBudgetDataGroupByAgency\r\n        (BudgetStage\r\n        ,PublishedBillingPeriod\r\n        ,BillingPeriod\r\n        ,AgencyCodeOEC\r\n        ,AgencyName\r\n        ,EnergyDeliveryType\r\n        ,BudgetGroupDEM\r\n        ,BudgetGroupDEMName\r\n        ,GenericEnergyDeliveryType\r\n        ,GenericEnergyDeliveryTypeUnit\r\n        ,EnergyUsage\r\n        ,StreetLightingFacilityPoints\r\n        ,FacilityPointDollars\r\n        ,EnergyDollars\r\n        ,DemandDollars\r\n        ,AgencyDivisionSeqId\r\n        ,AgencyOECL1\r\n\t\t,AgencyOECL2\r\n\t\t,AgencyOECL3\r\n\t\t,AgencyLevel)\r\n    SELECT B.BudgetStage\r\n        ,B.PublishedBillingPeriod\r\n        ,B.BillingPeriod\r\n        ,B.AgencyOECL1\r\n        ,MAX(A.AgencyShortDesc)\r\n        ,B.EnergyDeliveryType\r\n        ,B.BudgetGroupDEM\r\n        ,B.BudgetGroupDEMName\r\n        ,B.GenericEnergyDeliveryType\r\n        ,B.GenericEnergyDeliveryTypeUnit\r\n        ,SUM(B.EnergyUsage)\r\n        ,SUM(B.StreetLightingFacilityPoints)\r\n        ,SUM(B.FacilityPointDollars)\r\n        ,SUM(B.EnergyDollars)\r\n        ,SUM(B.DemandDollars)\r\n        ,MAX(A.AgencyDivisionSeqId)\r\n        ,B.AgencyOECL1\r\n\t\t,'000000' AS AgencyOECL2\r\n\t\t,'000000' AS AgencyOECL3\r\n\t\t,MAX(A.agencyLevel)\r\n    FROM @BaseBudgetDataGroupByAgency AS B\r\n\t    INNER JOIN @AgencyDivision AS A ON B.AgencyOECL1 = A.AgencyCodeOEC -- join for Level 1 data\r\n    WHERE B.AgencyCodeOEC <> B.AgencyOECL1\r\n\t      AND B.AgencyOECL1 <> '000000'\r\n    GROUP BY B.BudgetStage\r\n\t\t,B.AgencyOECL1\r\n\t\t,B.PublishedBillingPeriod\r\n\t\t,B.BillingPeriod\r\n\t\t,B.EnergyDeliveryType\r\n        ,B.BudgetGroupDEM\r\n        ,B.BudgetGroupDEMName\r\n        ,B.GenericEnergyDeliveryType\r\n        ,B.GenericEnergyDeliveryTypeUnit\r\n\r\n    -- level 2 data\r\n    INSERT INTO @BaseBudgetDataGroupByAgency\r\n        (BudgetStage\r\n        ,PublishedBillingPeriod\r\n        ,BillingPeriod\r\n        ,AgencyCodeOEC\r\n        ,AgencyName\r\n        ,EnergyDeliveryType\r\n        ,BudgetGroupDEM\r\n        ,BudgetGroupDEMName\r\n        ,GenericEnergyDeliveryType\r\n        ,GenericEnergyDeliveryTypeUnit\r\n        ,EnergyUsage\r\n        ,StreetLightingFacilityPoints\r\n        ,FacilityPointDollars\r\n        ,EnergyDollars\r\n        ,DemandDollars\r\n        ,AgencyDivisionSeqId\r\n        ,AgencyOECL1\r\n\t\t,AgencyOECL2\r\n\t\t,AgencyOECL3\r\n\t\t,AgencyLevel)\r\n    SELECT B.BudgetStage\r\n        ,B.PublishedBillingPeriod\r\n        ,B.BillingPeriod\r\n        ,B.AgencyOECL2\r\n        ,MAX(A.AgencyShortDesc)\r\n        ,B.EnergyDeliveryType\r\n        ,B.BudgetGroupDEM\r\n        ,B.BudgetGroupDEMName\r\n        ,B.GenericEnergyDeliveryType\r\n        ,B.GenericEnergyDeliveryTypeUnit\r\n        ,SUM(B.EnergyUsage)\r\n        ,SUM(B.StreetLightingFacilityPoints)\r\n        ,SUM(B.FacilityPointDollars)\r\n        ,SUM(B.EnergyDollars)\r\n        ,SUM(B.DemandDollars)\r\n        ,MAX(A.AgencyDivisionSeqId)\r\n        ,B.AgencyOECL1\r\n\t\t,B.AgencyOECL2\r\n\t\t,'000000' AS AgencyOECL3\r\n\t\t,MAX(A.agencyLevel)\r\n    FROM @BaseBudgetDataGroupByAgency AS B\r\n\t    INNER JOIN @AgencyDivision AS A ON B.AgencyOECL2 = A.AgencyCodeOEC -- join for Level 1 data\r\n    WHERE B.AgencyCodeOEC <> B.AgencyOECL2\r\n\t\tAND B.AgencyOECL2 <> '000000'\r\n    GROUP BY B.BudgetStage\r\n\t\t,B.AgencyOECL1\r\n\t\t,B.AgencyOECL2\r\n\t\t,B.PublishedBillingPeriod\r\n\t\t,B.BillingPeriod\r\n\t\t,B.EnergyDeliveryType\r\n        ,B.BudgetGroupDEM\r\n        ,B.BudgetGroupDEMName\r\n        ,B.GenericEnergyDeliveryType\r\n        ,B.GenericEnergyDeliveryTypeUnit;\r\n\r\n    --=========================================================================\r\n    -- 4 Group total cost\r\n    --=========================================================================\r\n    INSERT INTO @BaseBudgetDataGroupByAgency\r\n        (BudgetStage\r\n        ,PublishedBillingPeriod\r\n        ,BillingPeriod\r\n        ,AgencyCodeOEC\r\n        ,AgencyName\r\n        ,EnergyDeliveryType\r\n        ,BudgetGroupDEM\r\n        ,BudgetGroupDEMName\r\n        ,GenericEnergyDeliveryType\r\n        ,GenericEnergyDeliveryTypeUnit\r\n        ,EnergyUsage\r\n        ,StreetLightingFacilityPoints\r\n        ,FacilityPointDollars\r\n        ,EnergyDollars\r\n        ,DemandDollars\r\n        ,AgencyDivisionSeqId\r\n        ,AgencyOECL1\r\n\t\t,AgencyOECL2\r\n\t\t,AgencyOECL3\r\n\t\t,AgencyLevel)\r\n    SELECT B.BudgetStage\r\n        ,B.PublishedBillingPeriod\r\n        ,B.BillingPeriod\r\n        ,B.AgencyCodeOEC\r\n        ,MAX(B.AgencyName)\r\n        ,'N/A'\r\n        ,0\r\n        ,'N/A'\r\n        ,'N/A'\r\n        ,'Total Cost'\r\n        ,SUM(B.EnergyUsage)\r\n        ,SUM(B.StreetLightingFacilityPoints)\r\n        ,SUM(B.FacilityPointDollars)\r\n        ,SUM(B.EnergyDollars)\r\n        ,SUM(B.DemandDollars)\r\n        ,MAX(B.AgencyDivisionSeqId)\r\n        ,MAX(B.AgencyOECL1)\r\n\t\t,MAX(B.AgencyOECL2)\r\n\t\t,MAX(B.AgencyOECL3)\r\n\t\t,MAX(B.agencyLevel)\r\n    FROM @BaseBudgetDataGroupByAgency AS B\r\n    WHERE B.GenericEnergyDeliveryTypeUnit = 'Cost'\r\n    GROUP BY B.BudgetStage\r\n\t\t,B.AgencyCodeOEC\r\n\t\t,B.PublishedBillingPeriod\r\n\t\t,B.BillingPeriod;\r\n\r\n\t-- DATASETS\r\n\t-- dataset1\r\n\tSELECT 'FY' + SUBSTRING(CAST(@fy AS VARCHAR(4)),3,2)+' Heat, Light and Power Budget' AS reportTitle;\r\n\t--   maybe add billing period to the title\r\n\r\n\t-- dataset2 BudgetByEnergyType\r\n\tSELECT ds1.AgencyName\r\n\t\t,ds1.GenericEnergyDeliveryType AS EnergyType\r\n\t\t,ds1.GenericEnergyDeliveryTypeUnit AS [Type]\r\n\t\t,ISNULL(ds1.July,0) AS July\r\n\t\t,ISNULL(ds1.August,0) AS August\r\n\t\t,ISNULL(ds1.September,0) AS September\r\n\t\t,ISNULL(ds1.October,0) AS October\r\n\t\t,ISNULL(ds1.November,0) AS November\r\n\t\t,ISNULL(ds1.December,0) AS December\r\n\t\t,ISNULL(ds1.January,0) AS January\r\n\t\t,ISNULL(ds1.February,0) AS February\r\n\t\t,ISNULL(ds1.March,0) AS March\r\n\t\t,ISNULL(ds1.April,0) AS April\r\n\t\t,ISNULL(ds1.May,0) AS May\r\n\t\t,ISNULL(ds1.June,0) AS June\r\n\t\t,(ISNULL(ds1.July,0)\r\n\t\t\t+ISNULL(ds1.August,0)\r\n\t\t\t+ISNULL(ds1.September,0)\r\n\t\t\t+ISNULL(ds1.October,0)\r\n\t\t\t+ISNULL(ds1.November,0)\r\n\t\t\t+ISNULL(ds1.December,0)\r\n\t\t\t+ISNULL(ds1.January,0)\r\n\t\t\t+ISNULL(ds1.February,0)\r\n\t\t\t+ISNULL(ds1.March,0)\r\n\t\t\t+ISNULL(ds1.April,0)\r\n\t\t\t+ISNULL(ds1.May,0)\r\n\t\t\t+ISNULL(ds1.June,0)) AS Total\r\n\tFROM (SELECT * FROM (SELECT B.PublishedBillingPeriod\r\n\t\t\t,CASE SUBSTRING(B.BillingPeriod,5,2)\r\n\t\t\t\tWHEN 01 THEN 'January'\r\n\t\t\t\tWHEN 02 THEN 'February'\r\n\t\t\t\tWHEN 03 THEN 'March'\r\n\t\t\t\tWHEN 04 THEN 'April'\r\n\t\t\t\tWHEN 05 THEN 'May'\r\n\t\t\t\tWHEN 06 THEN 'June'\r\n\t\t\t\tWHEN 07 THEN 'July'\r\n\t\t\t\tWHEN 08 THEN 'August'\r\n\t\t\t\tWHEN 09 THEN 'September'\r\n\t\t\t\tWHEN 10 THEN 'October'\r\n\t\t\t\tWHEN 11 THEN 'November'\r\n\t\t\t\tWHEN 12 THEN 'December'\r\n\t\t\tEND MonthText\r\n\t\t\t,B.AgencyCodeOEC +' - '+AgencyName AgencyName\r\n\t\t\t,B.GenericEnergyDeliveryType\r\n\t\t\t,B.GenericEnergyDeliveryTypeUnit\r\n\t\t\t,SUM(B.EnergyUsage) AS EnergyUsage\r\n\t\t\t,B.AgencyDivisionSeqId\r\n\t\t\t,B.AgencyOECL1\r\n\t\tFROM @BaseBudgetDataGroupByAgency AS B\r\n\t\tGROUP BY B.BudgetStage\r\n\t\t\t,B.PublishedBillingPeriod\r\n\t\t\t,B.BillingPeriod\r\n\t\t\t,B.AgencyCodeOEC\r\n\t\t\t,B.AgencyName\r\n\t\t\t,B.GenericEnergyDeliveryType\r\n\t\t\t,B.GenericEnergyDeliveryTypeUnit\r\n\t\t\t,B.AgencyDivisionSeqId\r\n\t\t\t,B.AgencyOECL1\r\n\t\t\t,B.AgencyOECL2\r\n\t\t\t,B.AgencyOECL3\r\n\t\t\t,B.AgencyLevel\r\n\t\t\t,B.EnergyDeliveryType) AS datatable\r\n\t\t\tPIVOT (SUM(EnergyUsage) FOR MonthText IN ([July],[August],[September],[October],[November],[December],[January],[February],[March],[April],[May],[June])) AS pivottable\r\n\t\t) AS ds1\r\n\tORDER BY ds1.AgencyName, [Type];\r\n\r\n\t----dataset3 BudgetByUtilityCompany&ServiceClass\r\n\tSELECT ds2.AgencyName\r\n\t\t,ds2.GenericEnergyDeliveryType AS EnergyType\r\n\t\t,ds2.BudgetGroupDEMName AS UtilityAndServiceType\r\n\t\t,ds2.GenericEnergyDeliveryTypeUnit AS [Type]\r\n\t\t,ISNULL(ds2.July,0) AS July\r\n\t\t,ISNULL(ds2.August\t,0) AS August\r\n\t\t,ISNULL(ds2.September,0) AS September\r\n\t\t,ISNULL(ds2.October,0) AS October\r\n\t\t,ISNULL(ds2.November,0) AS November\r\n\t\t,ISNULL(ds2.December,0) AS December\r\n\t\t,ISNULL(ds2.January,0) AS January\r\n\t\t,ISNULL(ds2.February,0) AS February\r\n\t\t,ISNULL(ds2.March,0) AS March\r\n\t\t,ISNULL(ds2.April,0) AS April\r\n\t\t,ISNULL(ds2.May,0) AS May\r\n\t\t,ISNULL(ds2.June,0) AS June\r\n\t\t,(ISNULL(ds2.July,0)\r\n\t\t\t+ISNULL(ds2.August,0)\r\n\t\t\t+ISNULL(ds2.September,0)\r\n\t\t\t+ISNULL(ds2.October,0)\r\n\t\t\t+ISNULL(ds2.November,0)\r\n\t\t\t+ISNULL(ds2.December,0)\r\n\t\t\t+ISNULL(ds2.January,0)\r\n\t\t\t+ISNULL(ds2.February,0)\r\n\t\t\t+ISNULL(ds2.March,0)\r\n\t\t\t+ISNULL(ds2.April,0)\r\n\t\t\t+ISNULL(ds2.May,0)\r\n\t\t\t+ISNULL(ds2.June,0)) AS Total\r\n\tFROM (SELECT * FROM (SELECT PublishedBillingPeriod\r\n\t\t\t,CASE SUBSTRING(B.BillingPeriod,5,2)\r\n\t\t\t\tWHEN 01 THEN 'January'\r\n\t\t\t\tWHEN 02 THEN 'February'\r\n\t\t\t\tWHEN 03 THEN 'March'\r\n\t\t\t\tWHEN 04 THEN 'April'\r\n\t\t\t\tWHEN 05 THEN 'May'\r\n\t\t\t\tWHEN 06 THEN 'June'\r\n\t\t\t\tWHEN 07 THEN 'July'\r\n\t\t\t\tWHEN 08 THEN 'August'\r\n\t\t\t\tWHEN 09 THEN 'September'\r\n\t\t\t\tWHEN 10 THEN 'October'\r\n\t\t\t\tWHEN 11 THEN 'November'\r\n\t\t\t\tWHEN 12 THEN 'December'\r\n\t\t\tEND MonthText\r\n\t\t\t,B.AgencyCodeOEC +' - '+ B.AgencyName AS AgencyName\r\n\t\t\t,B.GenericEnergyDeliveryType\r\n\t\t\t,B.GenericEnergyDeliveryTypeUnit\r\n\t\t\t,B.BudgetGroupDEM\r\n\t\t\t,B.BudgetGroupDEMName\r\n\t\t\t,SUM(EnergyUsage) AS EnergyUsage\r\n\t\t\t,B.AgencyDivisionSeqId\r\n\t\t\t,B.AgencyOECL1\r\n\t\t\t,B.EnergyDeliveryType AS EnergyType\r\n\t\tFROM @BaseBudgetDataGroupByAgency AS B\r\n\t\tGROUP BY B.BudgetStage\r\n\t\t\t,B.PublishedBillingPeriod\r\n\t\t\t,B.BillingPeriod\r\n\t\t\t,B.AgencyCodeOEC\r\n\t\t\t,B.AgencyName\r\n\t\t\t,B.GenericEnergyDeliveryType\r\n\t\t\t,B.GenericEnergyDeliveryTypeUnit\r\n\t\t\t,B.BudgetGroupDEM\r\n\t\t\t,B.BudgetGroupDEMName\r\n\t\t\t,B.AgencyDivisionSeqId\r\n\t\t\t,B.AgencyOECL1\r\n\t\t\t,B.AgencyOECL2\r\n\t\t\t,B.AgencyOECL3\r\n\t\t\t,B.AgencyLevel\r\n\t\t\t,B.EnergyDeliveryType) AS datatable\r\n\t\t\tPIVOT (SUM(EnergyUsage) FOR MonthText IN ([July],[August],[September],[October],[November],[December],[January],[February],[March],[April],[May],[June])) AS pivottable\r\n\t\t) AS ds2\r\n\tORDER BY ds2.AgencyOECL1, [Type], ds2.BudgetGroupDEMName;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.660000",
      "last_altered": "2025-08-25 15:54:05.660000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@EmailAddress",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 75,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@AgencyCodeOEC",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "usp_Report_BaseBudgetStagingByAgency_Updated",
      "explanation": "#### 1. Overview\n\nThe stored procedure `usp_Report_BaseBudgetStagingByAgency_Updated` is designed to generate a report on the base budget staging by agency, specifically focusing on energy usage and costs. It aggregates and organizes budget data by agency and energy type, and it provides a detailed breakdown of energy usage and costs across different time periods and organizational levels. The procedure uses temporary tables to manage and manipulate data before producing the final datasets for reporting.\n\n#### 2. Complexity Level: High\n\nThe complexity of this stored procedure is high due to several factors:\n- It involves multiple temporary tables and Common Table Expressions (CTEs) for data manipulation.\n- It performs complex data aggregation and pivoting operations.\n- It includes hierarchical data processing and grouping by different organizational levels.\n- It generates multiple datasets for reporting purposes.\n\n#### 3. Input Parameters\n\n- `@EmailAddress AS VARCHAR(75)`: This parameter is used to identify the user or recipient of the report. It may be used for filtering or logging purposes.\n- `@AgencyCodeOEC AS VARCHAR(MAX)`: This parameter specifies the agency code(s) for which the report is generated. It is used to filter the data to include only relevant agencies.\n\n#### 4. Business Logic and Workflow\n\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the message indicating the number of rows affected by a SQL statement. It initializes several variables and temporary tables to store intermediate data.\n\n2. **Scenario and Fiscal Year Retrieval**: It retrieves the current scenario ID and fiscal year from the `budget.Scenario` table.\n\n3. **Agency Division Preparation**:\n   - It uses CTEs to construct a hierarchy of agencies based on their division levels.\n   - It filters agencies using a function `billing.uftn_TableGetAllAgencyChildrenByAgencyCodeOEC` to get all child agencies of the specified agency code.\n   - It populates the `@AgencyDivision` table with hierarchical agency data.\n\n4. **Base Budget Data Aggregation**:\n   - It inserts aggregated budget data into the `@BaseBudgetDataGroupByAgency` table, grouping by agency and energy type.\n   - It calculates sums for energy usage, facility points, and various dollar amounts.\n\n5. **Parent Agency Grouping**:\n   - It further aggregates data for parent agencies at different levels (Level 1 and Level 2) to provide a consolidated view.\n\n6. **Total Cost Grouping**:\n   - It calculates total costs for each agency and inserts this data into the temporary table.\n\n7. **Dataset Generation**:\n   - It generates three datasets: a report title, budget by energy type, and budget by utility company and service class.\n   - It uses pivot operations to transform monthly data into a tabular format for reporting.\n\n#### 5. Performance Considerations\n\n- **Data Volume**: The procedure handles potentially large datasets, which can impact performance. The use of temporary tables and CTEs may lead to increased memory and CPU usage.\n- **Indexing**: Ensure that the underlying tables, especially those involved in joins and aggregations, are properly indexed to optimize query performance.\n- **Concurrency**: The use of temporary tables may lead to contention if the procedure is executed concurrently by multiple users.\n\n#### 6. Potential Issues or Risks\n\n- **Scalability**: As data volume grows, the performance of the procedure may degrade, especially during aggregation and pivot operations.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions and incomplete data processing.\n- **Security**: Ensure that the procedure is executed with appropriate permissions to prevent unauthorized data access.\n- **Data Integrity**: The procedure assumes that the data in the source tables is accurate and consistent. Any discrepancies could affect the accuracy of the report.\n- **Maintenance**: The complexity of the procedure may make it challenging to maintain and update, especially if business requirements change.",
      "complexity": "High",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 5758,
      "api_response_id": "chatcmpl-C8VQHwmssnsmS0oYN0B8WNADIrqLq"
    },
    "analysis_timestamp": "2025-08-25 13:37:56"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "USP_ScenarioCreate",
      "definition": "CREATE PROCEDURE [budget].[USP_ScenarioCreate]\r\n(\r\n\t@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@baseYear AS INT\r\n\t,@publishedBillingPeriod AS INT\r\n\t,@agencyChangeId AS INT = NULL\r\n\t,@demChangeId AS INT = NULL\r\n\t,@projectChangeId AS INT = NULL\r\n\t,@tenantChargeId AS INT = NULL\r\n\t,@baseRateId AS INT = NULL\r\n\t,@rateFactorId AS INT = NULL\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@id AS INT OUTPUT\r\n\t,@isCurrentProjection AS BIT = 0\r\n\t,@isCurrentBudget AS BIT = 0\r\n\t,@actualDataEndMonth AS INT = 0\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO budget.Scenario ([Name], [Description], FY, BaseYear, PublishedBillingPeriod\r\n\t\t,AgencyChangeID, DEMChangeID, ProjectChangeID, TenantChargeID\r\n\t\t,BaseRateID, RateFactorID, Active\r\n\t\t,CreatedBy, ModifiedBy, IsCurrentProjection, IsCurrentBudget, ActualDataEndMonth)\r\n\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\tVALUES (@name, @description, @fy, @baseYear, @publishedBillingPeriod\r\n\t\t,@agencyChangeId, @demChangeId, @projectChangeId, @tenantChargeId\r\n\t\t,@baseRateId, @rateFactorId, 1\r\n\t\t,@actionBy, @actionBy, @isCurrentProjection, @isCurrentBudget, @actualDataEndMonth);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.670000",
      "last_altered": "2025-08-25 15:54:05.670000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@baseYear",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@publishedBillingPeriod",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@demChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 7,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@projectChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 8,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@tenantChargeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 9,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@baseRateId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 10,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@rateFactorId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 11,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 12,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 13,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@isCurrentProjection",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 14,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@isCurrentBudget",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 15,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actualDataEndMonth",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 16,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ScenarioCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ScenarioCreate` is designed to insert a new record into the `budget.Scenario` table. It captures various attributes related to a financial scenario, such as fiscal year, name, description, and several optional change identifiers. The procedure also outputs the ID of the newly inserted record, which can be used for further processing or reference.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this stored procedure is considered medium. While the procedure performs a straightforward insert operation, it involves multiple input parameters, some of which are optional, and uses an output parameter to return the newly inserted record's ID. The use of an output table variable to capture the inserted ID adds a layer of complexity.\n\n#### 3. Input Parameters\n- `@fy AS INT`: Represents the fiscal year for the scenario.\n- `@name AS VARCHAR(250)`: The name of the scenario.\n- `@description AS VARCHAR(500)`: A description of the scenario.\n- `@baseYear AS INT`: The base year for the scenario.\n- `@publishedBillingPeriod AS INT`: The billing period when the scenario is published.\n- `@agencyChangeId AS INT = NULL`: Optional ID for agency changes.\n- `@demChangeId AS INT = NULL`: Optional ID for DEM changes.\n- `@projectChangeId AS INT = NULL`: Optional ID for project changes.\n- `@tenantChargeId AS INT = NULL`: Optional ID for tenant charges.\n- `@baseRateId AS INT = NULL`: Optional ID for base rates.\n- `@rateFactorId AS INT = NULL`: Optional ID for rate factors.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user or system that performs the action, defaulting to 'SYSTEM'.\n- `@id AS INT OUTPUT`: An output parameter to capture the ID of the newly inserted scenario.\n- `@isCurrentProjection AS BIT = 0`: Indicates if the scenario is the current projection, defaulting to false.\n- `@isCurrentBudget AS BIT = 0`: Indicates if the scenario is the current budget, defaulting to false.\n- `@actualDataEndMonth AS INT = 0`: Represents the month when actual data ends, defaulting to 0.\n\n#### 4. Business Logic and Workflow\n1. The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance.\n2. A table variable `@IdOutput` is declared to temporarily store the ID of the newly inserted record.\n3. An `INSERT INTO` statement is executed to add a new record to the `budget.Scenario` table. The `OUTPUT` clause captures the `ID` of the inserted record into the `@IdOutput` table variable.\n4. The values for the insert operation are sourced from the input parameters, with default values provided for optional parameters.\n5. After the insert operation, the procedure selects the ID from `@IdOutput` and assigns it to the output parameter `@id`.\n\n#### 5. Performance Considerations\n- The use of `SET NOCOUNT ON` helps reduce network traffic by preventing the sending of unnecessary row count messages.\n- The `OUTPUT` clause efficiently captures the ID of the newly inserted record without requiring a separate query, which can enhance performance.\n- The procedure's performance is generally dependent on the underlying table's indexing and the database's overall load.\n\n#### 6. Potential Issues or Risks\n- If the `budget.Scenario` table has constraints or triggers that are not accounted for, the insert operation may fail or have unintended side effects.\n- The procedure assumes that the `@name` and `@description` parameters are unique or valid according to any business rules, but it does not enforce uniqueness or validation within the procedure itself.\n- The default values for optional parameters may not align with business requirements, leading to incorrect data being inserted if not properly managed by the calling application.\n- The procedure does not handle exceptions or errors explicitly, which means any failure during execution will not be logged or managed within the procedure itself.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1419,
      "api_response_id": "chatcmpl-C8VQj7BFJ90hv4hvgZzyJCOUcqMjH"
    },
    "analysis_timestamp": "2025-08-25 13:38:14"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "USP_ScenarioDelete",
      "definition": "CREATE PROCEDURE [budget].[USP_ScenarioDelete]\r\n(\r\n\t@id AS INT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\t-- Delete only if draft\r\n\tIF EXISTS (SELECT 1 FROM budget.Scenario WHERE ID = @id AND [Status] = 'DRAFT')\r\n\tBEGIN\r\n\t\tDELETE FROM budget.Scenario WHERE ID = @id;\r\n\tEND;\t\r\n\tELSE -- De-activate in all other circumstances\r\n\tBEGIN\r\n\t\tUPDATE budget.Scenario SET Active = 0, ModifiedBy = @actionBy, ModifiedDate = GETDATE() WHERE ID = @id;\r\n\tEND;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.673000",
      "last_altered": "2025-08-25 15:54:05.673000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ScenarioDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ScenarioDelete` is designed to manage the deletion or deactivation of records in the `budget.Scenario` table based on the status of the record. If the record is in a 'DRAFT' status, it is deleted. If the record is not in 'DRAFT' status, it is deactivated by setting its `Active` field to 0, and the modification details are updated.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving basic conditional logic to determine whether to delete or update a record. It uses simple SQL operations like `SELECT`, `DELETE`, and `UPDATE`.\n\n#### 3. Input Parameters\n- `@id AS INT`: This parameter represents the unique identifier of the scenario record in the `budget.Scenario` table that is targeted for deletion or deactivation.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter specifies the user or system process responsible for the action. It defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It checks if a record with the specified `@id` exists in the `budget.Scenario` table with a `Status` of 'DRAFT'.\n  - If such a record exists, it is deleted from the table.\n  - If no such record exists (i.e., the status is not 'DRAFT'), the procedure updates the record by setting the `Active` field to 0, indicating deactivation. It also updates the `ModifiedBy` and `ModifiedDate` fields to reflect who performed the action and when it was performed.\n\n#### 5. Performance Considerations\n- The procedure uses a simple `SELECT` statement to check for the existence of a record, which is efficient given that it only checks for the presence of a single record.\n- The `DELETE` and `UPDATE` operations are executed conditionally, ensuring that only one of these operations is performed per execution, which minimizes unnecessary database operations.\n- The use of `SET NOCOUNT ON` helps reduce the overhead of sending row count messages to the client, which can be beneficial in high-transaction environments.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Deleting records can lead to data integrity issues if there are foreign key constraints or if the record is referenced elsewhere in the database. The procedure does not handle such dependencies.\n- **Concurrency**: If multiple users attempt to delete or deactivate the same record simultaneously, it could lead to race conditions. Implementing proper transaction handling or locking mechanisms could mitigate this.\n- **Audit Trail**: While the procedure updates the `ModifiedBy` and `ModifiedDate` fields when deactivating a record, it does not log deletions. Implementing a logging mechanism for deletions could be beneficial for audit purposes.\n- **Hard Deletes**: The procedure performs hard deletes for 'DRAFT' records, which means the data is permanently removed. Consideration should be given to whether soft deletes (e.g., setting a `Deleted` flag) might be more appropriate to allow for data recovery.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1024,
      "api_response_id": "chatcmpl-C8VR1hS4i03ZqmQwS9XnFxafiZqyi"
    },
    "analysis_timestamp": "2025-08-25 13:38:29"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "USP_ScenariosRetrieve",
      "definition": "CREATE PROCEDURE [budget].[USP_ScenariosRetrieve]\r\n(\r\n\t@fy INT = NULL\r\n\t,@id INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT ID\r\n\t\t,[Name]\r\n\t\t,FY\r\n\t\t,[Description]\r\n\t\t,BaseYear\r\n\t\t,PublishedBillingPeriod\r\n\t\t,AgencyChangeID\r\n\t\t,DEMChangeID\r\n\t\t,ProjectChangeID\r\n\t\t,TenantChargeID\r\n\t\t,BaseRateID\r\n\t\t,RateFactorID\r\n\t\t,[Status]\r\n\t\t,CreatedBy\r\n\t\t,CreatedDate\r\n\t\t,ModifiedBy\r\n\t\t,ModifiedDate\r\n\t\t,Active\r\n\t\t,IsCurrentProjection\r\n\t\t,IsCurrentBudget\r\n\t\t,Locked\r\n\t\t,TotalDollars\r\n\t\t,ActualDataEndMonth\r\n\t\t,MaxPublishingDate\r\n\tFROM budget.vwScenarios\r\n\tWHERE ID = ISNULL(@id, ID) AND FY = ISNULL(@fy, FY) AND Active = 1 \r\n\tORDER BY FY DESC, [Name] ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.680000",
      "last_altered": "2025-08-25 15:54:05.680000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ScenariosRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ScenariosRetrieve` is designed to retrieve records from a view named `budget.vwScenarios`. It filters the records based on optional fiscal year (`@fy`) and scenario ID (`@id`) parameters. The procedure returns a set of columns related to scenarios, such as their name, fiscal year, description, and various identifiers. The results are ordered by fiscal year in descending order and by name in ascending order. The procedure operates under a `READ UNCOMMITTED` transaction isolation level, which allows reading uncommitted changes from other transactions.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a simple SELECT query with optional filtering based on input parameters. It does not include complex logic, conditional branching, or multiple operations that would increase complexity.\n\n#### 3. Input Parameters\n- `@fy INT = NULL`: An optional parameter representing the fiscal year. If provided, it filters the results to include only records matching this fiscal year.\n- `@id INT = NULL`: An optional parameter representing the scenario ID. If provided, it filters the results to include only records with this specific ID.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages for each statement, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read data that might not yet be committed by other transactions, potentially improving performance at the cost of data accuracy.\n- The SELECT statement retrieves various columns from the `budget.vwScenarios` view.\n- The WHERE clause applies filters based on the input parameters. If a parameter is not provided (NULL), it defaults to not filtering on that criterion.\n- The results are filtered to include only active scenarios (`Active = 1`).\n- The results are ordered by fiscal year in descending order and by name in ascending order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead, but it risks reading dirty data.\n- The procedure's performance largely depends on the underlying view `budget.vwScenarios`. If the view is complex or involves large datasets, it could impact performance.\n- The use of `ISNULL` in the WHERE clause can prevent the use of indexes on the `ID` and `FY` columns, potentially leading to full table scans.\n\n#### 6. Potential Issues or Risks\n- The `READ UNCOMMITTED` isolation level can lead to dirty reads, non-repeatable reads, and phantom reads, which might not be suitable for all business scenarios.\n- The use of `ISNULL` in the WHERE clause can hinder index utilization, affecting query performance, especially on large datasets.\n- If the `budget.vwScenarios` view is complex or involves joins, the performance might degrade, and the procedure could become a bottleneck.\n- The procedure assumes that the `Active` column is always present and correctly indicates active scenarios. If this assumption is incorrect, it could lead to incorrect data retrieval.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1095,
      "api_response_id": "chatcmpl-C8VRGVPncnm8QAJ1ZU9vhnWOKWYbf"
    },
    "analysis_timestamp": "2025-08-25 13:38:46"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "USP_ScenarioUpdate",
      "definition": "CREATE PROCEDURE [budget].[USP_ScenarioUpdate]\r\n(\r\n\t@id AS INT\r\n\t,@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@baseYear AS INT\r\n\t,@publishedBillingPeriod AS INT\r\n\t,@agencyChangeId AS INT = NULL\r\n\t,@demChangeId AS INT = NULL\r\n\t,@projectChangeId AS INT = NULL\r\n\t,@tenantChargeId AS INT = NULL\r\n\t,@baseRateId AS INT = NULL\r\n\t,@rateFactorId AS INT = NULL\r\n\t,@status AS VARCHAR(25)\r\n\t,@active AS BIT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@isCurrentProjection AS BIT = 0\r\n\t,@isCurrentBudget AS BIT = 0\r\n\t,@actualDataEndMonth AS INT = 0\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @oldAgencyChangeId AS INT, @oldDemChangeId AS INT, @oldProjectChangeId AS INT\r\n\t\t,@oldTenantChargeId AS INT, @oldBaseRateId AS INT, @oldRateFactorId AS INT, @oldIsCurrentProjection AS BIT, @oldIsCurrentBudget AS BIT;\r\n\r\n\tSELECT @oldAgencyChangeId = AgencyChangeID\r\n\t\t,@oldDemChangeId = DEMChangeID\r\n\t\t,@oldProjectChangeId = ProjectChangeID\r\n\t\t,@oldTenantChargeId = TenantChargeID\r\n\t\t,@oldBaseRateId = BaseRateID\r\n\t\t,@oldRateFactorId = RateFactorID\r\n\t\t,@oldIsCurrentProjection = IsCurrentProjection\r\n\t\t,@oldIsCurrentBudget = IsCurrentBudget\r\n\tFROM Budget.Scenario\r\n\tWHERE ID = @id;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Name] = @name\r\n\t\t,[Description] = @description\r\n\t\t,FY = @fy\r\n\t\t,BaseYear = @baseYear\r\n\t\t,PublishedBillingPeriod\t= @publishedBillingPeriod\r\n\t\t,AgencyChangeID = @agencyChangeId\r\n\t\t,DEMChangeID = @demChangeId\r\n\t\t,ProjectChangeID = @projectChangeId\r\n\t\t,TenantChargeID = @tenantChargeId\r\n\t\t,BaseRateID = @baseRateId\r\n\t\t,RateFactorID = @rateFactorId\r\n\t\t,[Status] = @status\r\n\t\t,Active = @active\r\n\t\t,ModifiedBy = @actionBy\r\n\t\t,ModifiedDate = GETDATE()\r\n\t\t,IsCurrentProjection = @isCurrentProjection\r\n\t\t,IsCurrentBudget = @isCurrentBudget\r\n\t\t,ActualDataEndMonth = @actualDataEndMonth\r\n\tWHERE ID = @id;\r\n\r\n\tIF EXISTS(SELECT 1 FROM budget.StagingBudget WHERE ScenarioId = @id)\r\n\tBEGIN\r\n\t\tIF (@oldAgencyChangeId <> @agencyChangeId OR\r\n\t\t\t@oldDemChangeId <> @demChangeId OR\r\n\t\t\t@oldProjectChangeId <> @projectChangeId OR\r\n\t\t\t@oldTenantChargeId <> @tenantChargeId OR\r\n\t\t\t@oldBaseRateId <> @baseRateId OR\r\n\t\t\t@oldRateFactorId <> @rateFactorId)\r\n\t\tBEGIN\r\n\t\t\tUPDATE budget.Scenario\r\n\t\t\tSET [Status] = 'REQUIRERECALC'\r\n\t\t\tWHERE ID = @id;\r\n\t\tEND;\r\n\t\tELSE IF (@isCurrentBudget = 1 AND @isCurrentProjection = 0)\r\n\t\tBEGIN\r\n\t\t\tUPDATE budget.Scenario\r\n\t\t\tSET [Status] = 'CRNT BDGT'\r\n\t\t\tWHERE ID = @id;\r\n\t\tEND;\r\n\t\tELSE IF (@isCurrentProjection = 1 AND @isCurrentBudget = 0)\r\n\t\tBEGIN\r\n\t\t\tUPDATE budget.Scenario\r\n\t\t\tSET [Status] = 'CRNT PROJ'\r\n\t\t\tWHERE ID = @id;\r\n\t\tEND;\r\n\t\tELSE IF (@isCurrentBudget = 1 AND @isCurrentProjection = 1)\r\n\t\tBEGIN\r\n\t\t\tUPDATE budget.Scenario\r\n\t\t\tSET [Status] = 'CRNT PROJ And CRNT BDGT'\r\n\t\t\tWHERE ID = @id;\r\n\t\tEND;\r\n\t\tELSE IF (@oldIsCurrentBudget = 1 AND @oldIsCurrentProjection = 1 AND @isCurrentBudget = 0 AND @isCurrentProjection = 0)\r\n\t\tBEGIN \r\n\t\t\tUPDATE budget.Scenario\r\n\t\t\tSET [Status] = 'PREV PROJ And PREV BDGT'\r\n\t\t\tWHERE ID = @id;\r\n\t\tEND;\r\n\t\tELSE IF (@oldIsCurrentBudget = 1 AND @isCurrentBudget = 0)\r\n\t\tBEGIN\r\n\t\t\tUPDATE budget.Scenario\r\n\t\t\tSET [Status] = REPLACE([Status], 'CRNT BDGT', 'PREV BDGT')\r\n\t\t\tWHERE ID = @id;\r\n\t\tEND;\r\n\t\tELSE IF (@oldIsCurrentProjection = 1 AND @isCurrentProjection = 0)\r\n\t\tBEGIN\r\n\t\t\tUPDATE budget.Scenario\r\n\t\t\tSET [Status] = REPLACE([Status], 'CRNT PROJ', 'PREV PROJ')\r\n\t\t\tWHERE ID = @id;\r\n\t\tEND;\r\n\tEND;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.683000",
      "last_altered": "2025-08-25 15:54:05.683000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@baseYear",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@publishedBillingPeriod",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 7,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@demChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 8,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@projectChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 9,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@tenantChargeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 10,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@baseRateId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 11,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@rateFactorId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 12,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@status",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 13,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@active",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 14,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 15,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@isCurrentProjection",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 16,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@isCurrentBudget",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 17,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actualDataEndMonth",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 18,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ScenarioUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ScenarioUpdate` is designed to update records in the `budget.Scenario` table based on the provided input parameters. It first retrieves the current values of certain fields for the specified scenario ID, updates the scenario with new values, and then conditionally updates the scenario's status based on changes to specific fields or flags. The procedure also checks for the existence of related records in the `budget.StagingBudget` table to determine if further status updates are necessary.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple conditional checks and updates, which adds to its complexity. It handles various scenarios for updating the status of a record based on changes to specific fields and flags. The complexity is further increased by the need to track old and new values for comparison.\n\n#### 3. Input Parameters\n- `@id AS INT`: The unique identifier for the scenario to be updated.\n- `@fy AS INT`: The fiscal year for the scenario.\n- `@name AS VARCHAR(250)`: The name of the scenario.\n- `@description AS VARCHAR(500)`: A description of the scenario.\n- `@baseYear AS INT`: The base year for the scenario.\n- `@publishedBillingPeriod AS INT`: The billing period when the scenario was published.\n- `@agencyChangeId AS INT = NULL`: Identifier for agency changes, default is NULL.\n- `@demChangeId AS INT = NULL`: Identifier for DEM changes, default is NULL.\n- `@projectChangeId AS INT = NULL`: Identifier for project changes, default is NULL.\n- `@tenantChargeId AS INT = NULL`: Identifier for tenant charge changes, default is NULL.\n- `@baseRateId AS INT = NULL`: Identifier for base rate changes, default is NULL.\n- `@rateFactorId AS INT = NULL`: Identifier for rate factor changes, default is NULL.\n- `@status AS VARCHAR(25)`: The status of the scenario.\n- `@active AS BIT`: Indicates if the scenario is active.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user or system making the update, default is 'SYSTEM'.\n- `@isCurrentProjection AS BIT = 0`: Flag indicating if this is the current projection, default is 0.\n- `@isCurrentBudget AS BIT = 0`: Flag indicating if this is the current budget, default is 0.\n- `@actualDataEndMonth AS INT = 0`: The month when actual data ends, default is 0.\n\n#### 4. Business Logic and Workflow\n1. **Retrieve Current Values**: The procedure starts by selecting the current values of specific fields for the scenario identified by `@id`.\n2. **Update Scenario**: It updates the scenario with new values provided through the input parameters.\n3. **Conditional Status Update**: \n   - If related records exist in `budget.StagingBudget`, it checks if any of the change identifiers have been modified. If so, it sets the status to 'REQUIRERECALC'.\n   - It updates the status based on the `@isCurrentProjection` and `@isCurrentBudget` flags, handling various combinations to set appropriate status values such as 'CRNT BDGT', 'CRNT PROJ', 'CRNT PROJ And CRNT BDGT', 'PREV PROJ And PREV BDGT', 'PREV BDGT', and 'PREV PROJ'.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `ID` column in the `budget.Scenario` table is indexed to optimize the SELECT and UPDATE operations.\n- **Conditional Logic**: The multiple conditional checks can impact performance, especially if the table contains a large number of records.\n- **Concurrency**: Consider the impact of concurrent updates to the same scenario, which could lead to race conditions or deadlocks.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: If the procedure is called with incorrect or incomplete parameters, it could lead to inconsistent data states.\n- **Concurrency Issues**: Without proper transaction handling, concurrent updates might lead to data anomalies.\n- **Error Handling**: The procedure lacks explicit error handling, which could result in unhandled exceptions and incomplete updates.\n- **Status Logic Complexity**: The logic for updating the status is complex and could lead to incorrect status updates if not thoroughly tested.\n- **Null Values**: The use of NULL default values for several parameters requires careful handling to avoid unintended updates.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 2239,
      "api_response_id": "chatcmpl-C8VRXnTNGz3OKUDinbLgLaAfsA0mX"
    },
    "analysis_timestamp": "2025-08-25 13:39:01"
  },
  {
    "procedure_info": {
      "schema": "budget",
      "name": "USP_TotalDollars_ByAgencyAndFundingSource",
      "definition": "CREATE PROCEDURE [budget].[USP_TotalDollars_ByAgencyAndFundingSource]\r\n(\r\n\t@ScenarioId AS INT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT V.AgencyCodeOEC\r\n\t\t,V.AgencyName\r\n\t\t,V.TotalDollars\r\n\t\t,COALESCE(V.FundingSourceDescription, 'N/A') AS FundingSource\r\n\t\t,@ScenarioId AS ScenarioId\r\n\tFROM budget.vwTotalBudget AS V\r\n\tWHERE V.ScenarioId = @ScenarioId\r\n\tUNION\r\n\tSELECT A.ParentAgencyCodeOEC AS AgencyCodeOEC\r\n\t\t,A.ParentAgencyName AS AgencyName\r\n\t\t,SUM(V.TotalDollars) AS TotalDollars\r\n\t\t,COALESCE(V.FundingSourceDescription, 'N/A') AS FundingSource\r\n\t\t,@ScenarioId AS ScenarioId\r\n\tFROM budget.vwTotalBudget AS V\r\n\t\tINNER JOIN Preload.vwAgencyHierarchy AS A ON A.ChildAgencyCodeOEC = V.AgencyCodeOEC\r\n\tWHERE A.ParentAgencyId IS NOT NULL AND V.ScenarioId = @ScenarioId\r\n\tGROUP BY A.ParentAgencyCodeOEC\r\n\t\t,A.ParentAgencyName\r\n\t\t,COALESCE(V.FundingSourceDescription, 'N/A');\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.697000",
      "last_altered": "2025-08-25 15:54:05.697000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@ScenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TotalDollars_ByAgencyAndFundingSource",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_TotalDollars_ByAgencyAndFundingSource` is designed to retrieve and aggregate financial data from a budget view, specifically focusing on total dollar amounts associated with different agencies and funding sources. It takes a scenario identifier as input and returns a result set that includes agency codes, agency names, total dollar amounts, funding source descriptions, and the scenario ID. The procedure combines direct data retrieval with hierarchical aggregation, providing both detailed and summarized financial information.\n\n#### 2. Complexity Level: Medium\nThe complexity of this stored procedure is considered medium due to the following factors:\n- It involves a UNION operation, which combines results from two separate SELECT queries.\n- It includes a JOIN operation to aggregate data based on hierarchical relationships between agencies.\n- It uses GROUP BY and aggregation functions to summarize data.\n\n#### 3. Input Parameters\n- `@ScenarioId AS INT`: This parameter is used to filter the data based on a specific scenario. It ensures that the procedure retrieves and processes data relevant to the given scenario context.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting the transaction isolation level to READ UNCOMMITTED, which allows reading uncommitted data, potentially improving performance by reducing locking overhead.\n- The first SELECT statement retrieves data directly from the `budget.vwTotalBudget` view, filtering by the provided `@ScenarioId`. It selects agency codes, names, total dollars, and funding source descriptions, defaulting to 'N/A' if the description is null.\n- The second SELECT statement performs a hierarchical aggregation. It joins the `budget.vwTotalBudget` view with the `Preload.vwAgencyHierarchy` view to roll up total dollars to parent agencies. It filters out records where the parent agency ID is null and groups the results by parent agency code, name, and funding source description.\n- The UNION operation combines the results of the two SELECT statements, providing a comprehensive view of both detailed and aggregated financial data.\n\n#### 5. Performance Considerations\n- The use of READ UNCOMMITTED isolation level can improve performance by reducing locking but may lead to dirty reads, where uncommitted changes are visible.\n- The UNION operation can be resource-intensive, especially if the underlying views contain large datasets.\n- The JOIN and GROUP BY operations may also impact performance, particularly if the `vwAgencyHierarchy` view is large or lacks appropriate indexing on the join columns.\n\n#### 6. Potential Issues or Risks\n- The READ UNCOMMITTED isolation level poses a risk of reading uncommitted or inconsistent data, which might not be suitable for all business scenarios.\n- If the `vwTotalBudget` or `vwAgencyHierarchy` views are not indexed properly, the JOIN and GROUP BY operations could lead to slow query performance.\n- The procedure assumes that the `ParentAgencyId` is not null for hierarchical aggregation, which might exclude some data if this assumption does not hold.\n- The use of COALESCE to default funding source descriptions to 'N/A' might mask underlying data quality issues if null values are unexpected.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1116,
      "api_response_id": "chatcmpl-C8VRnTHRbSauU0DiOSPaA54l8zYRL"
    },
    "analysis_timestamp": "2025-08-25 13:39:17"
  },
  {
    "procedure_info": {
      "schema": "Common",
      "name": "USP_GetCostPercentageByEnergyType",
      "definition": "-- =============================================================\r\n-- Get Cost Percentage By Energy Type for Scenario Not including CHW because it's too insignificant, i.e. less than 0.1% of ELECTRICITY\r\n-- =============================================================\r\nCREATE PROCEDURE [Common].[USP_GetCostPercentageByEnergyType]\r\n(\r\n    @sid AS INT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n    SELECT EnergyType AS EnergyType,\r\n        CONVERT(BIGINT, ROUND(ISNULL(SUM(TotalDollars), 0), 0)) AS TotalDollars -- Total dollars are including tenant charges\r\n    FROM budget.vwTotalBudget\r\n    WHERE ScenarioId = @sid\r\n        AND EnergyType <> 'TNC'\r\n        AND EnergyType <> 'CHW'\r\n    GROUP BY EnergyType;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.700000",
      "last_altered": "2025-08-25 15:54:05.700000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@sid",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_GetCostPercentageByEnergyType",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_GetCostPercentageByEnergyType` is designed to retrieve the total cost associated with different energy types for a given scenario, excluding certain energy types deemed insignificant or irrelevant. Specifically, it excludes 'CHW' (Chilled Water) and 'TNC' (Tenant Charges) from the results. The procedure aggregates the total dollars spent on each energy type, rounding the sum to the nearest whole number and converting it to a BIGINT data type.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a simple SELECT query with a GROUP BY clause. It performs basic data aggregation and filtering, making it relatively easy to understand and maintain.\n\n#### 3. Input Parameters\n- `@sid AS INT`: This parameter represents the Scenario ID. It is used to filter the data to include only the records relevant to the specified scenario. The procedure relies on this parameter to determine which scenario's data to process.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read data that might be in the process of being modified by other transactions. This can help improve performance by reducing locking overhead but at the risk of reading uncommitted changes.\n- The core logic involves a SELECT statement that:\n  - Retrieves the `EnergyType` and the sum of `TotalDollars` from the `budget.vwTotalBudget` view.\n  - Filters the results to include only records matching the specified `ScenarioId` and excludes energy types 'TNC' and 'CHW'.\n  - Groups the results by `EnergyType` to aggregate the total dollars for each type.\n  - Uses `ISNULL` to handle any NULL values in `TotalDollars`, ensuring the sum operation does not fail.\n  - Rounds the sum to the nearest whole number and converts it to a BIGINT for consistency and to handle large values.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking but may lead to dirty reads.\n- The procedure's performance largely depends on the size of the `vwTotalBudget` view and the efficiency of its underlying query.\n- The exclusion of certain energy types ('CHW' and 'TNC') reduces the dataset size, potentially improving query performance.\n- The conversion to BIGINT and rounding operations are computationally inexpensive but should be monitored if the dataset grows significantly.\n\n#### 6. Potential Issues or Risks\n- The use of `READ UNCOMMITTED` poses a risk of reading uncommitted or inconsistent data, which might not be suitable for all business scenarios.\n- The exclusion of 'CHW' and 'TNC' is hardcoded, which might not be flexible if business requirements change.\n- The procedure assumes that the `vwTotalBudget` view is well-optimized. If not, performance could degrade with larger datasets.\n- The rounding of `TotalDollars` might lead to a loss of precision, which could be significant depending on the business context.\n- The procedure does not handle potential exceptions or errors, such as invalid `ScenarioId` values, which could lead to unexpected results or failures.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1067,
      "api_response_id": "chatcmpl-C8VS3VBC3Jpo9KydwIpyimWJ0S4Fz"
    },
    "analysis_timestamp": "2025-08-25 13:39:29"
  },
  {
    "procedure_info": {
      "schema": "Common",
      "name": "USP_GetUsagePercentageByEnergyType",
      "definition": "-- =============================================================\r\n-- Get Cost Percentage By Energy Type for Scenario Not including CHW because it's too insignificant, i.e. less than 0.1% of ELECTRICITY\r\n-- =============================================================\r\nCREATE PROCEDURE [Common].[USP_GetUsagePercentageByEnergyType]\r\n(\r\n    @sid AS INT\r\n)\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n\r\n    DECLARE @mmBTUEleMultiplier AS FLOAT, @mmBTUGasMultiplier AS FLOAT, @mmBTUSTMMultiplier AS FLOAT\r\n\t\t,@mmBTUCHWMultiplier AS FLOAT, @calendaryear AS INT;\r\n    \r\n    SET @calendaryear = SUBSTRING((SELECT MAX(PublishedBillingPeriod) FROM EC3DB.Published_MonthlyPublishedSummaryData), 1, 4);\r\n\r\n\tIF (@calendaryear > YEAR(GETDATE()))\r\n\tBEGIN\r\n\t\tSET @calendaryear = YEAR(GETDATE());\r\n\tEND;\r\n    \r\n    SELECT @mmBTUEleMultiplier = MAX(MMBtusFactor)\r\n\tFROM EC3DB.Factors_ConversionEquivalentsForBtuAndCO2e\r\n\tWHERE CalendarYear = @calendaryear AND EnergyType= 'ELE'; --EnergyDeliveryType = 1;fac\r\n\r\n    SELECT @mmBTUGasMultiplier = MAX(MMBtusFactor)\r\n\tFROM EC3DB.Factors_ConversionEquivalentsForBtuAndCO2e\r\n\tWHERE CalendarYear = @calendaryear AND EnergyType= 'GAS'; --EnergyDeliveryType = 5;\r\n\r\n    SELECT @mmBTUSTMMultiplier = MAX(MMBtusFactor)\r\n\tFROM EC3DB.Factors_ConversionEquivalentsForBtuAndCO2e\r\n\tWHERE CalendarYear = @calendaryear AND EnergyType= 'STM'; --EnergyDeliveryType = 6;\r\n\r\n\tSELECT @mmBTUCHWMultiplier = MAX(MMBtusFactor)\r\n\tFROM EC3DB.Factors_ConversionEquivalentsForBtuAndCO2e\r\n\tWHERE CalendarYear = @calendaryear AND EnergyType= 'CHW'; --EnergyDeliveryType = 6;\r\n\r\n\tSELECT EnergyType AS EnergyType,\r\n\t\t(CASE WHEN EnergyType = 'ELE' THEN CONVERT(bigint, ROUND(ISNULL(SUM(EnergyUsage), 0) * @mmBTUEleMultiplier, 0))\r\n\t\t\t WHEN EnergyType = 'GAS' THEN CONVERT(bigint, ROUND(ISNULL(SUM(EnergyUsage), 0) * @mmBTUGasMultiplier, 0)) \r\n\t\t\t WHEN EnergyType = 'STM' THEN CONVERT(bigint, ROUND(ISNULL(SUM(EnergyUsage), 0) * @mmBTUSTMMultiplier, 0))\r\n\t\t END) AS BTU\r\n\tFROM budget.vwTotalBudget \r\n\tWHERE ScenarioId = @sid\r\n\t\tAND EnergyType <> 'TNC'\r\n\t\tAND EnergyType <> 'CHW'\r\n\tGROUP BY EnergyType;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.707000",
      "last_altered": "2025-08-25 15:54:05.707000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@sid",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_GetUsagePercentageByEnergyType",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_GetUsagePercentageByEnergyType` is designed to calculate and return the energy usage in BTUs for different energy types (Electricity, Gas, and Steam) for a given scenario, identified by a scenario ID. It excludes Chilled Water (CHW) and Transmission and Distribution (TNC) energy types from the calculation. The procedure uses conversion factors specific to the calendar year to convert energy usage into BTUs.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including data retrieval, conditional logic, and arithmetic operations. It interacts with multiple tables and uses dynamic data based on the current date, which adds to its complexity.\n\n#### 3. Input Parameters\n- `@sid AS INT`: This parameter represents the scenario ID for which the energy usage percentages are to be calculated. It is used to filter the data in the `budget.vwTotalBudget` view.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the message indicating the number of rows affected by a SQL statement from being returned. It declares several variables to store conversion multipliers and the calendar year.\n\n2. **Determine Calendar Year**: The procedure calculates the calendar year by extracting the year from the maximum `PublishedBillingPeriod` in the `EC3DB.Published_MonthlyPublishedSummaryData` table. If this year is greater than the current year, it defaults to the current year.\n\n3. **Retrieve Conversion Factors**: For each energy type (Electricity, Gas, Steam, and Chilled Water), the procedure retrieves the maximum conversion factor (`MMBtusFactor`) for the determined calendar year from the `EC3DB.Factors_ConversionEquivalentsForBtuAndCO2e` table.\n\n4. **Calculate BTUs**: The procedure calculates the total energy usage in BTUs for each energy type (excluding TNC and CHW) by:\n   - Summing the `EnergyUsage` from the `budget.vwTotalBudget` view for the given scenario ID.\n   - Multiplying the sum by the respective conversion factor.\n   - Rounding the result and converting it to a `bigint`.\n\n5. **Return Results**: The results are grouped by `EnergyType` and returned as a result set.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the columns used in the `WHERE` clause and joins (e.g., `ScenarioId`, `EnergyType`, `CalendarYear`) are indexed to improve query performance.\n- **Data Volume**: The performance may degrade with large datasets, especially if the `budget.vwTotalBudget` view or the conversion factors table contains a significant amount of data.\n- **NOCOUNT**: The use of `SET NOCOUNT ON` helps reduce network traffic by suppressing the \"rows affected\" message.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: The procedure assumes that conversion factors are available for the determined calendar year. If these factors are missing, the procedure may return incorrect results or fail.\n- **Future Dates**: If the `PublishedBillingPeriod` contains future dates, the procedure defaults to the current year, which might not be the intended behavior.\n- **Exclusion of CHW**: The exclusion of CHW is hardcoded, which may not be suitable if business requirements change.\n- **Error Handling**: The procedure lacks error handling, which could lead to unhandled exceptions if, for example, the conversion factors are not found.\n- **Type Conversion**: The conversion to `bigint` may lead to data truncation if the calculated BTU values exceed the range of a `bigint`.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1588,
      "api_response_id": "chatcmpl-C8VSEJmKF5cTNgZo1nqBWLhFOzHG8"
    },
    "analysis_timestamp": "2025-08-25 13:39:48"
  },
  {
    "procedure_info": {
      "schema": "dbo",
      "name": "USP_GetLastBillingPeriod",
      "definition": "CREATE PROCEDURE [dbo].[USP_GetLastBillingPeriod]\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT ISNULL(CAST(MAX(PublishedBillingPeriod) AS INT), 0) AS BillingPeriod\r\n\tFROM EC3DB.Published_AccountLevelRawDataForCurrentPeriod;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.710000",
      "last_altered": "2025-08-25 15:54:05.710000",
      "type": "PROCEDURE"
    },
    "parameters": [],
    "chatgpt_explanation": {
      "procedure_name": "USP_GetLastBillingPeriod",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_GetLastBillingPeriod` is designed to retrieve the most recent billing period from a specific table within a database. It queries the `Published_AccountLevelRawDataForCurrentPeriod` table in the `EC3DB` database to find the maximum value of the `PublishedBillingPeriod` column. This value is then returned as the `BillingPeriod`. If no records are found, it defaults to returning `0`.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SQL `SELECT` statement with an aggregate function. It does not involve any complex logic, conditional statements, or multiple table joins.\n\n#### 3. Input Parameters\nThis stored procedure does not take any input parameters. It operates solely on the data available in the `Published_AccountLevelRawDataForCurrentPeriod` table.\n\n#### 4. Business Logic and Workflow\n- **Transaction Isolation Level**: The procedure sets the transaction isolation level to `READ UNCOMMITTED`, which allows the query to read uncommitted changes from other transactions. This is often used to avoid locking and improve performance at the cost of potentially reading dirty data.\n- **Data Retrieval**: It executes a `SELECT` statement to find the maximum value of the `PublishedBillingPeriod` column. The `ISNULL` function ensures that if no records are found, the result defaults to `0`.\n- **Output**: The result is returned as a single integer value named `BillingPeriod`.\n\n#### 5. Performance Considerations\n- **Isolation Level**: Using `READ UNCOMMITTED` can improve performance by reducing locking overhead, but it may lead to reading uncommitted or dirty data.\n- **Indexing**: Performance can be significantly improved if the `PublishedBillingPeriod` column is indexed, especially if the table contains a large number of records.\n- **Aggregation**: The use of the `MAX` function is efficient for finding the maximum value, but its performance is dependent on the size of the dataset and indexing.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can result in dirty reads, where the procedure might return data that is not yet committed and could be rolled back.\n- **Default Value**: Returning `0` as a default when no records are found might not be appropriate for all business contexts. It could lead to misinterpretation unless `0` is a valid and expected value for a billing period.\n- **Schema Changes**: If the schema of the `Published_AccountLevelRawDataForCurrentPeriod` table changes, particularly the `PublishedBillingPeriod` column, the procedure may fail or return incorrect results.\n- **Error Handling**: The procedure lacks error handling mechanisms, which means any runtime errors will not be gracefully managed or logged.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 868,
      "api_response_id": "chatcmpl-C8VSXTBIK2dSyACY6Ayi8ZlRr8fkI"
    },
    "analysis_timestamp": "2025-08-25 13:39:57"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangeClone",
      "definition": "CREATE PROCEDURE [input].[USP_AgencyChangeClone]\r\n(\r\n    @fy AS INT,\r\n    @name AS VARCHAR(250),\r\n    @description AS VARCHAR(500),\r\n    @actionBy AS VARCHAR(25) = 'SYSTEM',\r\n    @id AS INT OUTPUT,\r\n    @originalId AS INT\r\n)\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n\r\n    DECLARE @IdOutput TABLE (ID INT);\r\n    DECLARE @DId AS INT, @AgencyChangeDetailEntityIdMaxPlusOne AS INT;\r\n\r\n    -- insert into agencyChange table \r\n    INSERT INTO input.AgencyChange (FY,\r\n        [Name],\r\n        [Description],\r\n        CreatedBy,\r\n        ModifiedBy)\r\n    OUTPUT INSERTED.ID\r\n    INTO @IdOutput\r\n    VALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n    -- get new agencyChangeId\r\n    SELECT @id = ID FROM @IdOutput;\r\n\r\n    -- get all old AgencyChangeDetailEntityId that are associated with the old AgencyChangeId\r\n    SELECT DISTINCT AgencyChangeDetailEntityId\r\n    INTO #TEMP_Detail_ID\r\n    FROM input.AgencyChangeDetail\r\n    WHERE AgencyChangeID = @originalId;\r\n\r\n    -- persist the excluded items for return -- Mei 6/30/2017\r\n    SELECT DISTINCT AgencyCode, BudgetGroupID, AgencyChangeDetailEntityId\r\n    INTO #TEMP_Obsolete\r\n    FROM input.AgencyChangeDetail\r\n    WHERE AgencyChangeDetailEntityId IN (SELECT AgencyChangeDetailEntityId FROM #TEMP_Detail_ID)\r\n        AND (AgencyCode NOT IN (SELECT a.AgencyCodeOEC\r\n                FROM Preload.Agency AS a\r\n                    INNER JOIN Preload.AgencyByFY AS abf ON a.AgencyId = abf.AgencyId\r\n                WHERE abf.FY = @fy)\r\n            OR BudgetGroupID NOT IN (SELECT BudgetGroupID FROM Preload.BudgetGroupByFY WHERE FY = @fy));\r\n\r\n    -- purge #TEMP_Detail_ID to exclude entries with obsolete agencies and budget groups\r\n    DELETE #TEMP_Detail_ID\r\n    WHERE AgencyChangeDetailEntityId IN (SELECT AgencyChangeDetailEntityId FROM #TEMP_Obsolete);\r\n\r\n    -- insert into the agencychangedetail with the new agencyChangeId and new agencyChangeDetailEntityId \r\n    WHILE ((SELECT COUNT(*) FROM #TEMP_Detail_ID) > 0)\r\n    BEGIN\r\n        SELECT TOP 1 @DId = AgencyChangeDetailEntityId FROM #TEMP_Detail_ID;\r\n\r\n        SELECT @AgencyChangeDetailEntityIdMaxPlusOne = MAX(AgencyChangeDetailEntityId) + 1\r\n        FROM input.AgencyChangeDetail;\r\n\r\n        INSERT INTO input.AgencyChangeDetail(AgencyChangeID,\r\n            AgencyCode,\r\n            FacilityNo,\r\n            FacilityName,\r\n            BudgetGroupID,\r\n            BillingPeriod,\r\n            IsNewAddition,\r\n            EntireYear,\r\n            Notes,\r\n            DemandUsage,\r\n            EnergyUsage,\r\n            EnergyUsagePeakPercentage,\r\n            EnergyUsageReactivePower,\r\n            StreetLightingFacilityPoints,\r\n            AgencyChangeDetailEntityId)\r\n        SELECT @id,\r\n            AgencyCode,\r\n            FacilityNo,\r\n            FacilityName,\r\n            BudgetGroupID,\r\n            CASE WHEN 6 < BillingPeriod % 100 THEN (@fy - 1) * 100 + BillingPeriod % 100\r\n                ELSE @fy * 100 + BillingPeriod % 100 END AS BillingPeriod,\r\n            IsNewAddition,\r\n            EntireYear,\r\n            Notes,\r\n            DemandUsage,\r\n            EnergyUsage,\r\n            EnergyUsagePeakPercentage,\r\n            EnergyUsageReactivePower,\r\n            StreetLightingFacilityPoints,\r\n            @AgencyChangeDetailEntityIdMaxPlusOne\r\n        FROM input.AgencyChangeDetail\r\n        WHERE AgencyChangeDetailEntityId = @DId;\r\n\r\n        DELETE #TEMP_Detail_ID WHERE AgencyChangeDetailEntityId = @DId;\r\n    END;\r\n\r\n    SELECT AgencyCode, BudgetGroupID FROM #TEMP_Obsolete;\r\n\t\r\n\tDROP TABLE IF EXISTS #TEMP_Obsolete;\r\n    DROP TABLE IF EXISTS #TEMP_Detail_ID;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.717000",
      "last_altered": "2025-08-25 15:54:05.717000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@originalId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangeClone",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgencyChangeClone` is designed to clone an existing agency change record and its associated details from the `input.AgencyChange` and `input.AgencyChangeDetail` tables. It creates a new agency change entry for a specified fiscal year (`FY`) and copies relevant details from an existing agency change identified by `@originalId`. The procedure also filters out obsolete agency codes and budget groups based on the current fiscal year data from the `Preload` schema.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including inserting records, handling temporary tables, and iterating over records to clone details. The complexity arises from the need to manage temporary tables, perform conditional logic, and ensure data integrity during the cloning process.\n\n#### 3. Input Parameters\n- `@fy AS INT`: The fiscal year for the new agency change record.\n- `@name AS VARCHAR(250)`: The name for the new agency change record.\n- `@description AS VARCHAR(500)`: A description for the new agency change record.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user or system identifier performing the action, with a default value of 'SYSTEM'.\n- `@id AS INT OUTPUT`: An output parameter to return the ID of the newly created agency change record.\n- `@originalId AS INT`: The ID of the existing agency change record to be cloned.\n\n#### 4. Business Logic and Workflow\n1. **Insert New Agency Change Record**: A new record is inserted into the `input.AgencyChange` table with the provided fiscal year, name, description, and actionBy. The new record's ID is captured in the `@id` output parameter.\n   \n2. **Retrieve Existing Detail IDs**: The procedure selects distinct `AgencyChangeDetailEntityId` values associated with the `@originalId` and stores them in a temporary table `#TEMP_Detail_ID`.\n\n3. **Identify Obsolete Details**: It identifies obsolete agency codes and budget groups by comparing them against current fiscal year data in the `Preload` schema. These obsolete entries are stored in another temporary table `#TEMP_Obsolete`.\n\n4. **Filter Out Obsolete Details**: The procedure deletes obsolete entries from `#TEMP_Detail_ID` to ensure only valid details are cloned.\n\n5. **Clone Agency Change Details**: Using a loop, the procedure iterates over the remaining detail IDs in `#TEMP_Detail_ID`, assigns a new `AgencyChangeDetailEntityId`, and inserts them into the `input.AgencyChangeDetail` table with the new `AgencyChangeID`.\n\n6. **Return Obsolete Details**: Finally, it selects and returns the obsolete agency codes and budget groups for further processing or logging.\n\n7. **Cleanup**: Temporary tables `#TEMP_Obsolete` and `#TEMP_Detail_ID` are dropped to clean up resources.\n\n#### 5. Performance Considerations\n- **Temporary Tables**: The use of temporary tables can impact performance, especially if the dataset is large. Indexing temporary tables or using table variables might improve performance.\n- **Looping Constructs**: The WHILE loop iterating over `#TEMP_Detail_ID` can be inefficient for large datasets. Consider using set-based operations to minimize row-by-row processing.\n- **Concurrency**: The procedure may face concurrency issues if multiple instances are executed simultaneously, especially when calculating `@AgencyChangeDetailEntityIdMaxPlusOne`.\n\n#### 6. Potential Issues or Risks\n- **Concurrency and Race Conditions**: The calculation of `@AgencyChangeDetailEntityIdMaxPlusOne` using `MAX` can lead to race conditions if multiple procedures run concurrently, potentially causing duplicate IDs.\n- **Data Integrity**: If the procedure fails midway, it may leave the database in an inconsistent state. Consider implementing transactions to ensure atomicity.\n- **Obsolete Data Handling**: The logic for identifying obsolete data relies on the `Preload` schema's accuracy. Any discrepancies in this data could lead to incorrect filtering.\n- **Scalability**: As the dataset grows, the performance of the procedure may degrade due to the use of temporary tables and row-by-row processing.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1904,
      "api_response_id": "chatcmpl-C8VSgp7ZIuCn2n8odAiFYmq1FEtNK"
    },
    "analysis_timestamp": "2025-08-25 13:40:12"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangeCreate",
      "definition": "CREATE PROCEDURE [input].[USP_AgencyChangeCreate]\r\n(\r\n\t@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@id AS INT OUTPUT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT NOT NULL);\r\n\r\n\tINSERT INTO input.AgencyChange (FY, [Name], [Description], CreatedBy, ModifiedBy)\r\n\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\tVALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.720000",
      "last_altered": "2025-08-25 15:54:05.720000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangeCreate",
      "explanation": "#### 1. Overview\n\nThe stored procedure `USP_AgencyChangeCreate` is designed to insert a new record into the `input.AgencyChange` table. It captures details about an agency change, including the fiscal year, name, description, and the user who performed the action. After inserting the record, it retrieves the newly generated ID of the inserted record and returns it as an output parameter.\n\n#### 2. Complexity Level: Low\n\nThe procedure is straightforward, involving a single insert operation with an output clause to capture the inserted record's ID. It does not involve complex logic, conditional statements, or multiple operations.\n\n#### 3. Input Parameters\n\n- `@fy AS INT`: Represents the fiscal year associated with the agency change.\n- `@name AS VARCHAR(250)`: The name of the agency change, with a maximum length of 250 characters.\n- `@description AS VARCHAR(500)`: A description of the agency change, with a maximum length of 500 characters.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system performing the action. Defaults to 'SYSTEM' if not provided.\n- `@id AS INT OUTPUT`: An output parameter that returns the ID of the newly inserted record.\n\n#### 4. Business Logic and Workflow\n\n1. **SET NOCOUNT ON**: This command prevents the sending of DONE_IN_PROC messages for each statement, which can reduce network traffic and improve performance.\n2. **Declare Table Variable**: A table variable `@IdOutput` is declared to temporarily store the ID of the newly inserted record.\n3. **Insert Operation**: The procedure inserts a new record into the `input.AgencyChange` table with the provided fiscal year, name, description, and actionBy values. The `CreatedBy` and `ModifiedBy` fields are both set to the value of `@actionBy`.\n4. **Output Clause**: The `OUTPUT` clause captures the ID of the newly inserted record and stores it in the `@IdOutput` table variable.\n5. **Select Statement**: The procedure retrieves the ID from the `@IdOutput` table variable and assigns it to the output parameter `@id`.\n\n#### 5. Performance Considerations\n\n- **SET NOCOUNT ON**: This improves performance by reducing unnecessary network traffic.\n- **Table Variable for Output**: Using a table variable to capture the output ID is efficient for this single-row insert operation.\n- **Indexing**: Ensure that the `ID` column in the `input.AgencyChange` table is indexed to optimize the retrieval of the inserted ID.\n\n#### 6. Potential Issues or Risks\n\n- **Concurrency**: While the procedure handles a single insert operation, concurrent executions could lead to contention if the table is heavily accessed. However, this is generally not a concern for single-row inserts.\n- **Error Handling**: The procedure lacks explicit error handling. Consider adding TRY...CATCH blocks to manage potential errors during the insert operation.\n- **Data Validation**: There is no validation of input parameters within the procedure. Ensure that data validation is handled at the application level or by additional database constraints.\n- **Default Value for `@actionBy`**: The default value 'SYSTEM' may not always be appropriate. Ensure that the calling application provides the correct user context when necessary.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1042,
      "api_response_id": "chatcmpl-C8VSvhtuh0qRX5FcYpDJCjxo5BfR5"
    },
    "analysis_timestamp": "2025-08-25 13:40:22"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangeDelete",
      "definition": "CREATE PROCEDURE [input].[USP_AgencyChangeDelete]\r\n(\r\n\t@id AS INT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDELETE FROM input.AgencyChangeDetail WHERE AgencyChangeID = @id;\r\n\tDELETE FROM input.AgencyChange WHERE ID = @id;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.723000",
      "last_altered": "2025-08-25 15:54:05.723000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangeDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgencyChangeDelete` is designed to delete records from two tables within the `input` schema: `AgencyChangeDetail` and `AgencyChange`. It takes an `ID` as input and removes the corresponding records from both tables. The procedure is intended to maintain referential integrity by ensuring that details associated with a specific agency change are deleted before the main record.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving two simple `DELETE` operations. There are no complex joins, conditional logic, or transactions, which keeps the complexity low.\n\n#### 3. Input Parameters\n- `@id AS INT`: This parameter is the primary key or identifier for the records to be deleted. It is used to locate and remove the specific entries in both the `AgencyChangeDetail` and `AgencyChange` tables.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter defaults to 'SYSTEM' and is intended to record who initiated the deletion. However, it is not utilized within the procedure, which suggests it might be intended for logging or auditing purposes outside the current scope.\n\n#### 4. Business Logic and Workflow\n1. **SET NOCOUNT ON**: This command is used to prevent the SQL Server from sending messages about the number of rows affected by the SQL statements. This can reduce network traffic and improve performance slightly.\n2. **Delete Operations**:\n   - The first `DELETE` statement removes records from the `AgencyChangeDetail` table where the `AgencyChangeID` matches the provided `@id`. This ensures that all related detail records are removed before the main record.\n   - The second `DELETE` statement removes the record from the `AgencyChange` table where the `ID` matches the provided `@id`. This ensures that the main record is deleted after its associated details have been removed.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `AgencyChangeID` column in `AgencyChangeDetail` and the `ID` column in `AgencyChange` are indexed. This will improve the performance of the `DELETE` operations by allowing faster lookups.\n- **Batch Deletions**: If this procedure is called in a loop or for multiple records, consider batching deletions to reduce transaction overhead and improve performance.\n- **NOCOUNT**: The use of `SET NOCOUNT ON` is beneficial in reducing unnecessary network traffic, especially if the procedure is called frequently.\n\n#### 6. Potential Issues or Risks\n- **Referential Integrity**: If there are foreign key constraints between `AgencyChange` and `AgencyChangeDetail`, ensure that the constraints are set to cascade deletes or are managed appropriately to prevent orphaned records.\n- **Concurrency**: If multiple users or processes might attempt to delete the same record simultaneously, consider implementing locking mechanisms or handling concurrency to prevent conflicts.\n- **Unused Parameter**: The `@actionBy` parameter is not used within the procedure. If logging or auditing is required, consider implementing a mechanism to record who performed the deletion.\n- **Data Loss**: This procedure permanently deletes data. Ensure that there are appropriate backups or that the procedure is only accessible to authorized users to prevent accidental data loss.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 954,
      "api_response_id": "chatcmpl-C8VT5LAVtoTk7m1NjvhKmL0rZpOg0"
    },
    "analysis_timestamp": "2025-08-25 13:40:31"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangeDetailsCreate",
      "definition": "CREATE PROCEDURE [input].[USP_AgencyChangeDetailsCreate]\r\n(\r\n\t@details AS input.UDT_AgencyChangeDetail READONLY\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n    SET nocount ON; \r\n\r\n    DECLARE @AgencyChangeDetailEntityID AS INT, @AgencyChangeID AS INT, @AgencyCode AS VARCHAR(6), @FacilityNo AS VARCHAR(10)\r\n        ,@FacilityName AS VARCHAR(100), @IsNewAddition AS BIT = 0, @EntireYear AS BIT = 0, @ActionDescription AS VARCHAR(100)\r\n        ,@AddRemoveFacility AS VARCHAR(100), @EffectiveDate AS DATETIME, @Notes AS VARCHAR(200), @BudgetGroupID AS INT, @BillingPeriod AS INT\r\n        ,@DemandUsage AS DECIMAL(18, 5) = 0.0, @EnergyUsage AS DECIMAL(18, 5) = 0.0, @EnergyUsagePeakPercentage AS DECIMAL(18, 5) = 0.0\r\n        ,@EnergyUsageReactivePower AS DECIMAL(18, 5) = 0.0, @StreetLightingFacilityPoints AS DECIMAL(18, 5) = 0.0;\r\n\r\n    SELECT @AgencyChangeDetailEntityID = MAX(agencychangedetailentityid) + 1 FROM input.agencychangedetail;\r\n\r\n    DECLARE @detailCursor AS CURSOR;\r\n    SET @detailCursor =  CURSOR FOR SELECT agencychangeid,\r\n        agencycode,\r\n        facilityno,\r\n\t\tfacilityname,\r\n        isnewaddition,\r\n\t\tentireyear,\r\n\t\tactionDescription,\r\n\t\taddRemoveFacility,\r\n        effectivedate,\r\n\t\tnotes,\r\n        budgetgroupid,\r\n        billingperiod,\r\n        demandusage,\r\n        energyusage,\r\n        energyusagepeakpercentage,\r\n        energyusagereactivepower,\r\n        streetlightingfacilitypoints\r\n    FROM @details;\r\n    OPEN @detailCursor; \r\n    FETCH NEXT FROM  @detailCursor INTO @AgencyChangeID, \r\n        @AgencyCode, \r\n        @FacilityNo, \r\n\t    @FacilityName,\r\n        @IsNewAddition, \r\n\t    @EntireYear,\r\n\t    @ActionDescription,\r\n\t    @AddRemoveFacility,\r\n        @EffectiveDate,\r\n\t    @Notes,\r\n        @BudgetGroupID, \r\n        @BillingPeriod, \r\n        @DemandUsage, \r\n        @EnergyUsage, \r\n        @EnergyUsagePeakPercentage, \r\n        @EnergyUsageReactivePower, \r\n        @StreetLightingFacilityPoints;\r\n\r\n    WHILE (@@FETCH_STATUS = 0)\r\n    BEGIN\r\n        INSERT INTO input.agencychangedetail \r\n            (agencychangedetailentityid,\r\n            agencychangeid,\r\n            agencycode,\r\n            facilityno,\r\n\t\t    facilityname,\r\n            budgetgroupid,\r\n            isnewaddition,\r\n\t\t    entireyear,\r\n\t\t    actionDescription,\r\n\t\t    addRemoveFacility,\r\n            effectivedate,\r\n\t\t    notes,\r\n            billingperiod,\r\n            demandusage,\r\n            energyusage,\r\n            energyusagepeakpercentage,\r\n            energyusagereactivepower,\r\n            streetlightingfacilitypoints) \r\n        VALUES (@AgencyChangeDetailEntityID,\r\n            @AgencyChangeID,\r\n            @AgencyCode,\r\n            @FacilityNo,\r\n\t        @FacilityName,\r\n\t        @BudgetGroupID,\r\n            @IsNewAddition,\r\n\t        @EntireYear,\r\n\t        @ActionDescription,\r\n\t        @AddRemoveFacility,\r\n            @EffectiveDate,\r\n\t        @Notes,\r\n            @BillingPeriod,\r\n            @DemandUsage,\r\n            @EnergyUsage,\r\n            @EnergyUsagePeakPercentage,\r\n            @EnergyUsageReactivePower,\r\n            @StreetLightingFacilityPoints);\r\n        FETCH NEXT FROM  @detailCursor INTO  @AgencyChangeID, \r\n           @AgencyCode, \r\n           @FacilityNo,\r\n\t       @FacilityName, \r\n           @IsNewAddition,\r\n\t       @EntireYear,\r\n\t       @ActionDescription,\r\n\t       @AddRemoveFacility,\r\n           @EffectiveDate,\r\n\t       @Notes,  \r\n           @BudgetGroupID, \r\n           @BillingPeriod, \r\n           @DemandUsage, \r\n           @EnergyUsage, \r\n           @EnergyUsagePeakPercentage, \r\n           @EnergyUsageReactivePower, \r\n           @StreetLightingFacilityPoints\r\n    END;\r\n\r\n    CLOSE @detailCursor;\r\n    DEALLOCATE @detailCursor;\r\n\t\r\n    UPDATE input.AgencyChange SET ModifiedDate=GETDATE(), ModifiedBy=@actionBy WHERE id=@AgencyChangeID;\r\n\r\n    UPDATE budget.Scenario SET [Status] = 'REQUIRERECALC' WHERE AgencyChangeID=@AgencyChangeID AND [Status] IN ('CALCULATED');\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.730000",
      "last_altered": "2025-08-25 15:54:05.730000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@details",
        "data_type": "UDT_AgencyChangeDetail",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangeDetailsCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgencyChangeDetailsCreate` is designed to insert records into the `input.agencychangedetail` table based on the data provided in a user-defined table type parameter. It processes each row of the input data, assigns a new `agencychangedetailentityid`, and inserts the data into the table. After processing all rows, it updates the `ModifiedDate` and `ModifiedBy` fields in the `input.AgencyChange` table and sets the status of related records in the `budget.Scenario` table to 'REQUIRERECALC' if they are currently 'CALCULATED'.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple operations, including cursor-based iteration over input data, conditional updates, and handling of multiple tables. While the logic is straightforward, the use of cursors and multiple table updates increases the complexity.\n\n#### 3. Input Parameters\n- `@details AS input.UDT_AgencyChangeDetail READONLY`: A table-valued parameter that contains the details of agency changes. This parameter is expected to be a structured data type that includes fields corresponding to the columns in the `input.agencychangedetail` table.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: An optional parameter that specifies who performed the action. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure starts by setting `nocount` to ON to prevent the sending of DONE_IN_PROC messages to the client, which can improve performance.\n2. **Variable Declaration**: It declares variables to hold data for each column in the `input.agencychangedetail` table.\n3. **Entity ID Calculation**: It calculates the next `agencychangedetailentityid` by finding the maximum current ID and adding one.\n4. **Cursor Setup**: A cursor is declared and opened to iterate over the rows in the `@details` table-valued parameter.\n5. **Data Insertion**: For each row fetched by the cursor, an INSERT operation is performed to add the data to the `input.agencychangedetail` table.\n6. **Cursor Cleanup**: The cursor is closed and deallocated after processing all rows.\n7. **Update Operations**: \n   - The `input.AgencyChange` table is updated to set the `ModifiedDate` and `ModifiedBy` fields.\n   - The `budget.Scenario` table is updated to change the status to 'REQUIRERECALC' for records related to the `AgencyChangeID` that are currently 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **Cursor Usage**: The use of a cursor can lead to performance issues, especially with large datasets, as it processes rows one at a time. Consider using set-based operations if possible.\n- **Entity ID Calculation**: The calculation of `agencychangedetailentityid` using `MAX` can be a bottleneck if the table is large, as it requires a full scan.\n- **Concurrency**: The procedure does not handle concurrency issues that might arise from multiple simultaneous executions, which could lead to duplicate `agencychangedetailentityid` values.\n\n#### 6. Potential Issues or Risks\n- **Concurrency and Race Conditions**: The calculation of the next `agencychangedetailentityid` is not protected against concurrent executions, which could result in duplicate IDs if two instances of the procedure run simultaneously.\n- **Error Handling**: The procedure lacks error handling, which means any failure during execution (e.g., due to data type mismatches or constraint violations) will not be gracefully managed.\n- **Scalability**: The use of a cursor may not scale well with large datasets, potentially leading to long execution times.\n- **Hardcoded Defaults**: The default value for `@actionBy` is hardcoded as 'SYSTEM', which may not be appropriate for all use cases and could lead to incorrect audit trails if not explicitly set by the caller.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1969,
      "api_response_id": "chatcmpl-C8VTFpVL4Rzz4EsXVhv81XFYiAWpB"
    },
    "analysis_timestamp": "2025-08-25 13:40:48"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangeDetailsDelete",
      "definition": "CREATE PROCEDURE [input].[USP_AgencyChangeDetailsDelete]\r\n(\r\n      @agencyChangeDetailEntityId AS INT\r\n\t  ,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @AgencyChangeID AS INT;\r\n\r\n\tSELECT @AgencyChangeID = MAX(AgencyChangeID)\r\n\tFROM input.AgencyChangeDetail\r\n\tWHERE agencyChangeDetailEntityId = @agencyChangeDetailEntityId;\r\n\r\n\tDELETE FROM input.AgencyChangeDetail\r\n\tWHERE agencyChangeDetailEntityId = @agencyChangeDetailEntityId;\r\n\t\r\n\tUPDATE input.AgencyChange\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @AgencyChangeID;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE AgencyChangeID=@AgencyChangeID AND [Status] IN ('CALCULATED');\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.733000",
      "last_altered": "2025-08-25 15:54:05.733000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@agencyChangeDetailEntityId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangeDetailsDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgencyChangeDetailsDelete` is designed to delete records from the `input.AgencyChangeDetail` table based on a given `agencyChangeDetailEntityId`. It also updates related records in the `input.AgencyChange` and `budget.Scenario` tables. Specifically, it updates the modification details in the `AgencyChange` table and changes the status in the `Scenario` table if certain conditions are met.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple operations across different tables, including a selection, deletion, and updates. The logic is straightforward but involves multiple steps and conditions, which elevates its complexity above a simple CRUD operation.\n\n#### 3. Input Parameters\n- `@agencyChangeDetailEntityId AS INT`: This parameter identifies the specific record(s) in the `AgencyChangeDetail` table that need to be deleted.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter records who performed the action, defaulting to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can improve performance by reducing network traffic.\n2. **Retrieve AgencyChangeID**: It selects the maximum `AgencyChangeID` from the `AgencyChangeDetail` table where the `agencyChangeDetailEntityId` matches the input parameter. This ID is stored in the `@AgencyChangeID` variable.\n3. **Delete Operation**: It deletes records from the `AgencyChangeDetail` table where the `agencyChangeDetailEntityId` matches the input parameter.\n4. **Update AgencyChange Table**: It updates the `ModifiedDate` and `ModifiedBy` fields in the `AgencyChange` table for the record with the `id` equal to `@AgencyChangeID`.\n5. **Update Scenario Table**: It updates the `Status` field in the `Scenario` table to 'REQUIRERECALC' for records where `AgencyChangeID` matches `@AgencyChangeID` and the current `Status` is 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that `agencyChangeDetailEntityId` and `AgencyChangeID` are indexed to optimize the SELECT and DELETE operations.\n- **Concurrency**: The procedure does not include transaction handling, which could lead to issues in a high-concurrency environment.\n- **Batch Processing**: If the `AgencyChangeDetail` table contains a large number of records, the DELETE operation could be resource-intensive. Consider batching or archiving strategies if performance issues arise.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: The procedure assumes that the maximum `AgencyChangeID` is the correct one to update, which may not always be the case if there are multiple records with the same `agencyChangeDetailEntityId`.\n- **Error Handling**: There is no error handling in place. If any operation fails, it could leave the database in an inconsistent state.\n- **Hardcoded Status**: The procedure relies on specific status values ('CALCULATED' and 'REQUIRERECALC'), which could lead to issues if these values change or are not consistent across the application.\n- **Security**: The procedure does not include any checks for user permissions, which could lead to unauthorized data modifications if not properly managed at the database level.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1112,
      "api_response_id": "chatcmpl-C8VTV5yM11BBVVKZ7h9yrwGkX3jnq"
    },
    "analysis_timestamp": "2025-08-25 13:41:00"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangeDetailsRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_AgencyChangeDetailsRetrieve]\r\n(\r\n\t @agencyChangeId AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n    SELECT AgencyChangeDetailEntityID,\r\n        AgencyChangeID,\r\n        AgencyCode,\r\n        FacilityNo,\r\n        FacilityName,\r\n        BudgetGroupID,\r\n        IsNewAddition,\r\n\t    Entireyear,\r\n\t\tActionDescription,\r\n\t\tAddRemoveFacility,\r\n        EffectiveDate,\r\n\t    Notes\r\n    FROM input.vwAgencyChangeDetailsDistinct\r\n    WHERE AgencyChangeID = ISNULL(@agencyChangeId, AgencyChangeID)\r\n    ORDER BY AgencyCode ASC,\r\n        FacilityNo ASC,\r\n        BudgetGroupID ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.740000",
      "last_altered": "2025-08-25 15:54:05.740000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@agencyChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangeDetailsRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgencyChangeDetailsRetrieve` is designed to retrieve details about agency changes from a view named `vwAgencyChangeDetailsDistinct` within the `input` schema. It accepts an optional parameter, `@agencyChangeId`, which filters the results based on the specified agency change ID. If no ID is provided, it retrieves all records. The results are ordered by `AgencyCode`, `FacilityNo`, and `BudgetGroupID`.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SELECT statement with an optional filtering condition. It does not include complex logic, multiple joins, or subqueries, which keeps its complexity low.\n\n#### 3. Input Parameters\n- `@agencyChangeId AS INT = NULL`: This is an optional integer parameter. It is used to filter the results to only include records with a specific `AgencyChangeID`. If the parameter is not provided (i.e., it is NULL), the procedure retrieves all records from the view.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the procedure to read uncommitted changes from other transactions. This can help avoid locking issues but may result in reading dirty data.\n- The main operation is a SELECT query that retrieves columns from the `vwAgencyChangeDetailsDistinct` view.\n- The WHERE clause uses the `ISNULL` function to apply a filter based on `@agencyChangeId`. If `@agencyChangeId` is NULL, it defaults to retrieving all records.\n- The results are ordered by `AgencyCode`, `FacilityNo`, and `BudgetGroupID` in ascending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED Isolation Level**: This can improve performance by reducing locking overhead but at the risk of reading uncommitted or dirty data.\n- **Indexing**: Performance can be significantly affected by the presence or absence of indexes on the columns used in the WHERE clause and ORDER BY clause (`AgencyChangeID`, `AgencyCode`, `FacilityNo`, `BudgetGroupID`). Proper indexing can enhance query performance.\n- **Network Traffic**: Setting `NOCOUNT ON` reduces network traffic by suppressing the message that indicates the number of rows affected by a T-SQL statement.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to dirty reads, where the data read might not be committed and could change if the transaction is rolled back.\n- **NULL Handling**: The use of `ISNULL` in the WHERE clause ensures that all records are retrieved if `@agencyChangeId` is NULL. However, this could lead to large result sets if not intended, potentially impacting performance.\n- **Scalability**: If the view `vwAgencyChangeDetailsDistinct` involves complex joins or aggregations, performance might degrade as the dataset grows, especially without proper indexing.\n- **Security**: Ensure that the view and the procedure are secured appropriately to prevent unauthorized access, especially given the use of `READ UNCOMMITTED`.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1031,
      "api_response_id": "chatcmpl-C8VThtvaFyXOGBnIaU7eamw0OjK4i"
    },
    "analysis_timestamp": "2025-08-25 13:41:16"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangeDetailsRetrieveBillingPeriodDetails",
      "definition": "CREATE PROCEDURE [input].[USP_AgencyChangeDetailsRetrieveBillingPeriodDetails]\r\n(\r\n     @AgencyChangeDetailEntityId AS INT = -1\r\n\t ,@agencyChangeId AS INT = -1\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tIF (@AgencyChangeDetailEntityId > -1)\r\n\tBEGIN\r\n\t\tSELECT AgencyChangeDetailEntityID, \r\n\t\t    AgencyChangeID, \r\n\t\t\tAgencyCode, \r\n\t\t\tFacilityNo, \r\n\t\t\tFacilityName,\r\n\t\t\tBudgetGroupID, \r\n\t\t\tIsNewAddition, \r\n\t\t\tEntireyear,\r\n\t\t\tActionDescription,\r\n\t\t\tAddRemoveFacility,\r\n\t\t\tEffectiveDate,\r\n\t        Notes, \r\n\t\t\tBillingPeriod, \r\n\t\t\tDemandUsage, \r\n\t\t\tEnergyUsage, \r\n\t\t\tEnergyUsagePeakPercentage, \r\n\t\t\tEnergyUsagePeak, \r\n\t\t\tEnergyUsageOffPeak, \r\n\t\t\tEnergyUsageReactivePower, \r\n\t\t\tStreetLightingFacilityPoints\r\n\t\tFROM input.vwAgencyChangeDetails\r\n\t\tWHERE AgencyChangeDetailEntityID = @AgencyChangeDetailEntityId\r\n\t\tORDER BY AgencyCode ASC, FacilityNo ASC, BudgetGroupID ASC, BillingPeriod ASC;\r\n\tEND;\r\n\tELSE IF  (@agencyChangeId > -1)\r\n\tBEGIN\r\n\t\tSELECT AgencyChangeDetailEntityID, \r\n\t\t    AgencyChangeID, \r\n\t\t\tAgencyCode, \r\n\t\t\tFacilityNo, \r\n\t\t\tFacilityName,\r\n\t\t\tBudgetGroupID, \r\n\t\t\tIsNewAddition,\r\n\t\t\tEntireyear,\r\n\t\t\tActionDescription,\r\n\t\t\tAddRemoveFacility,\r\n\t\t\tEffectiveDate,\r\n\t        Notes, \r\n\t\t\tBillingPeriod, \r\n\t\t\tDemandUsage, \r\n\t\t\tEnergyUsage, \r\n\t\t\tEnergyUsagePeakPercentage, \r\n\t\t\tEnergyUsagePeak, \r\n\t\t\tEnergyUsageOffPeak, \r\n\t\t\tEnergyUsageReactivePower, \r\n\t\t\tStreetLightingFacilityPoints\r\n\t\tFROM input.vwAgencyChangeDetails\r\n\t\tWHERE  AgencyChangeID = @agencyChangeId\r\n\t\tORDER BY AgencyChangeDetailEntityID ASC, AgencyCode ASC, FacilityNo ASC, BudgetGroupID ASC, BillingPeriod ASC;\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t    SELECT AgencyChangeDetailEntityID, \r\n\t\t    AgencyChangeID, \r\n\t\t\tAgencyCode, \r\n\t\t\tFacilityNo, \r\n\t\t\tFacilityName,\r\n\t\t\tBudgetGroupID, \r\n\t\t\tIsNewAddition, \r\n\t\t\tEntireyear,\r\n\t\t\tActionDescription,\r\n\t\t\tAddRemoveFacility,\r\n\t\t\tEffectiveDate,\r\n\t        Notes, \r\n\t\t\tBillingPeriod, \r\n\t\t\tDemandUsage, \r\n\t\t\tEnergyUsage, \r\n\t\t\tEnergyUsagePeakPercentage, \r\n\t\t\tEnergyUsagePeak, \r\n\t\t\tEnergyUsageOffPeak, \r\n\t\t\tEnergyUsageReactivePower, \r\n\t\t\tStreetLightingFacilityPoints\r\n\t\tFROM input.vwAgencyChangeDetails\r\n\t\tORDER BY AgencyChangeID ASC, AgencyChangeDetailEntityID ASC, AgencyCode ASC, FacilityNo ASC, BudgetGroupID ASC, BillingPeriod ASC;\r\n\tEND;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.750000",
      "last_altered": "2025-08-25 15:54:05.750000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@AgencyChangeDetailEntityId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangeDetailsRetrieveBillingPeriodDetails",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgencyChangeDetailsRetrieveBillingPeriodDetails` is designed to retrieve billing period details related to agency changes from a view named `vwAgencyChangeDetails` within the `input` schema. It allows filtering based on either `AgencyChangeDetailEntityId` or `agencyChangeId`, and if neither is provided, it retrieves all records. The results are ordered by various columns depending on the filtering criteria.\n\n#### 2. Complexity Level: Medium\nThe procedure is of medium complexity due to its conditional logic that handles different filtering scenarios and the ordering of results based on multiple columns. The complexity is also influenced by the number of columns selected and the potential size of the dataset being queried.\n\n#### 3. Input Parameters\n- `@AgencyChangeDetailEntityId AS INT = -1`: This parameter is used to filter the results by a specific `AgencyChangeDetailEntityID`. The default value of `-1` indicates that this filter is not applied unless explicitly set.\n- `@agencyChangeId AS INT = -1`: This parameter is used to filter the results by a specific `AgencyChangeID`. Similarly, the default value of `-1` indicates that this filter is not applied unless explicitly set.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the message indicating the number of rows affected by a T-SQL statement from being returned.\n- It checks if `@AgencyChangeDetailEntityId` is greater than `-1`. If true, it retrieves records where `AgencyChangeDetailEntityID` matches the provided ID, ordering the results by `AgencyCode`, `FacilityNo`, `BudgetGroupID`, and `BillingPeriod`.\n- If `@AgencyChangeDetailEntityId` is not greater than `-1`, it checks if `@agencyChangeId` is greater than `-1`. If true, it retrieves records where `AgencyChangeID` matches the provided ID, ordering the results by `AgencyChangeDetailEntityID`, `AgencyCode`, `FacilityNo`, `BudgetGroupID`, and `BillingPeriod`.\n- If neither parameter is greater than `-1`, it retrieves all records from the view, ordering them by `AgencyChangeID`, `AgencyChangeDetailEntityID`, `AgencyCode`, `FacilityNo`, `BudgetGroupID`, and `BillingPeriod`.\n\n#### 5. Performance Considerations\n- The use of `NOCOUNT ON` improves performance slightly by reducing network traffic.\n- The procedure's performance is heavily dependent on the indexing of the `vwAgencyChangeDetails` view. Proper indexing on columns used in the `WHERE` clause and `ORDER BY` clause can significantly enhance query performance.\n- The procedure retrieves a large number of columns, which could impact performance if the dataset is large. Consider selecting only necessary columns if performance becomes an issue.\n\n#### 6. Potential Issues or Risks\n- If the view `vwAgencyChangeDetails` is not indexed appropriately, the procedure could suffer from slow performance, especially when retrieving large datasets.\n- The default values of `-1` for both parameters mean that if neither parameter is set, the procedure will return all records, which could lead to performance issues if the dataset is large.\n- There is no error handling within the procedure. If the view does not exist or there are permission issues, the procedure will fail without providing a meaningful error message.\n- The procedure does not handle cases where both parameters are provided with valid IDs. It defaults to checking `@AgencyChangeDetailEntityId` first, which might not be the intended behavior in all scenarios.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1565,
      "api_response_id": "chatcmpl-C8VTxSWqlHBOKjpW3M3er7xpprOyZ"
    },
    "analysis_timestamp": "2025-08-25 13:41:27"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangeDetailsSave",
      "definition": "\r\nCREATE PROCEDURE [input].[USP_AgencyChangeDetailsSave]\r\n(\r\n\t@details AS input.UDT_AgencyChangeDetail READONLY\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @AgencyChangeDetailEntityIdMaxPlusOne AS INT, @AgencyChangeDetailEntityId AS INT, @AgencyChangeID AS INT\r\n\t\t,@AgencyCode AS VARCHAR(6), @FacilityNo AS VARCHAR(10), @FacilityName AS VARCHAR(100), @IsNewAddition AS BIT = 0\r\n\t\t,@EntireYear AS BIT = 0, @ActionDescription AS VARCHAR(100), @AddRemoveFacility AS VARCHAR(100), @EffectiveDate AS DATETIME\r\n\t\t,@Notes AS VARCHAR(200), @BudgetGroupID AS INT, @BillingPeriod AS INT, @DemandUsage AS DECIMAL(18, 5) = 0.0\r\n\t\t,@EnergyUsage AS DECIMAL(18, 5) = 0.0, @EnergyUsagePeakPercentage AS DECIMAL(18, 5) = 0.0, @EnergyUsageReactivePower AS DECIMAL(18, 5) = 0.0\r\n\t\t,@StreetLightingFacilityPoints AS DECIMAL(18, 5) = 0.0;\r\n\r\n\tSELECT @AgencyChangeDetailEntityIdMaxPlusOne = Max(agencychangedetailentityid) + 1 FROM input.agencychangedetail;\r\n\r\n\tDECLARE @detailCursor CURSOR;    \r\n    SET @detailCursor =  CURSOR FOR SELECT AgencyChangeDetailEntityId,\r\n\t\tagencychangeid,\r\n\t\tagencycode, \r\n\t\tfacilityno, \r\n\t\tfacilityname,\r\n\t\tisnewaddition,\r\n\t\tentireyear,\r\n\t\tactionDescription,\r\n\t\taddRemoveFacility,\r\n\t\teffectivedate,\r\n\t\tnotes,  \r\n\t\tbudgetgroupid, \r\n\t\tbillingperiod, \r\n\t\tdemandusage, \r\n\t\tenergyusage, \r\n\t\tenergyusagepeakpercentage, \r\n\t\tenergyusagereactivepower, \r\n\t\tstreetlightingfacilitypoints \r\n\tFROM @details;\r\n\r\n\tOPEN @detailCursor; \r\n\tFETCH NEXT FROM @detailCursor INTO @AgencyChangeDetailEntityId\r\n\t\t,@AgencyChangeID\r\n\t\t,@AgencyCode\r\n\t\t,@FacilityNo\r\n\t\t,@FacilityName\r\n\t\t,@IsNewAddition\r\n\t\t,@EntireYear\r\n\t\t,@ActionDescription\r\n\t\t,@AddRemoveFacility\r\n\t\t,@EffectiveDate\r\n\t    ,@Notes\r\n\t\t,@BudgetGroupID\r\n\t\t,@BillingPeriod\r\n\t\t,@DemandUsage\r\n\t\t,@EnergyUsage\r\n\t\t,@EnergyUsagePeakPercentage\r\n\t\t,@EnergyUsageReactivePower\r\n\t\t,@StreetLightingFacilityPoints;\r\n\r\n\tWHILE (@@FETCH_STATUS = 0)\r\n\tBEGIN\r\n\t\tIF (@AgencyChangeDetailEntityId > -1)\r\n\t\tBEGIN\r\n\t\t\tUPDATE input.agencychangedetail\r\n\t\t\tSET AgencyCode = @AgencyCode\r\n\t\t\t\t,FacilityNo = @FacilityNo\r\n\t\t\t\t,FacilityName = @FacilityName\r\n\t\t\t\t,IsNewAddition = @IsNewAddition\r\n\t\t\t\t,EntireYear = @EntireYear\r\n\t\t\t\t,ActionDescription = @ActionDescription\r\n\t\t\t\t,AddRemoveFacility = @AddRemoveFacility\r\n\t\t\t\t,EffectiveDate = @EffectiveDate\r\n\t            ,Notes = @Notes\r\n\t\t\t\t,BudgetGroupID = @BudgetGroupID\r\n\t\t\t\t,DemandUsage = @DemandUsage\r\n\t\t\t\t,EnergyUsage = @EnergyUsage\r\n\t\t\t\t,EnergyUsagePeakPercentage = @EnergyUsagePeakPercentage\r\n\t\t\t\t,EnergyUsageReactivePower = @EnergyUsageReactivePower\r\n\t\t\t\t,StreetLightingFacilityPoints = @StreetLightingFacilityPoints\r\n\t\t\tWHERE AgencyChangeDetailEntityId = @AgencyChangeDetailEntityId\r\n\t\t\t\tAND BillingPeriod = @BillingPeriod;\r\n\t\tEND;\r\n\t\tELSE\r\n\t\tBEGIN\r\n\t\t\tINSERT INTO input.agencychangedetail(agencychangedetailentityid\r\n\t\t\t\t,agencychangeid\r\n\t\t\t\t,agencycode\r\n\t\t\t\t,facilityno\r\n\t\t\t\t,facilityname\r\n\t\t\t\t,budgetgroupid\r\n\t\t\t\t,isnewaddition\r\n\t\t\t\t,entireyear\r\n\t\t\t\t,actionDescription\r\n\t\t\t\t,addRemoveFacility\r\n\t\t\t\t,effectivedate\r\n\t\t\t\t,notes\r\n\t\t\t\t,billingperiod\r\n\t\t\t\t,demandusage\r\n\t\t\t\t,energyusage\r\n\t\t\t\t,energyusagepeakpercentage\r\n\t\t\t\t,energyusagereactivepower\r\n\t\t\t\t,streetlightingfacilitypoints)\r\n\t\t\tVALUES (@AgencyChangeDetailEntityIdMaxPlusOne\r\n\t\t\t\t,@AgencyChangeID\r\n\t\t\t\t,@AgencyCode\r\n\t\t\t\t,@FacilityNo\r\n\t\t\t\t,@FacilityName\r\n\t\t\t\t,@BudgetGroupID\r\n\t\t\t\t,@IsNewAddition\r\n\t\t\t\t,@EntireYear\r\n\t\t\t\t,@ActionDescription\r\n\t\t\t\t,@AddRemoveFacility\r\n\t\t\t\t,@EffectiveDate\r\n\t\t\t\t,@Notes\r\n\t\t\t\t,@BillingPeriod\r\n\t\t\t\t,@DemandUsage\r\n\t\t\t\t,@EnergyUsage\r\n\t\t\t\t,@EnergyUsagePeakPercentage\r\n\t\t\t\t,@EnergyUsageReactivePower\r\n\t\t\t\t,@StreetLightingFacilityPoints);\r\n\t\t END;\r\n\r\n\t\tFETCH NEXT FROM  @detailCursor INTO @AgencyChangeDetailEntityId\r\n\t\t    ,@AgencyChangeID\r\n\t\t    ,@AgencyCode\r\n\t\t\t,@FacilityNo\r\n\t\t\t,@FacilityName\r\n\t\t\t,@IsNewAddition\r\n\t\t\t,@EntireYear\r\n\t\t\t,@ActionDescription\r\n\t\t\t,@AddRemoveFacility\r\n\t\t\t,@EffectiveDate\r\n\t        ,@Notes\r\n\t\t\t,@BudgetGroupID\r\n\t\t\t,@BillingPeriod\r\n\t\t\t,@DemandUsage\r\n\t\t\t,@EnergyUsage\r\n\t\t\t,@EnergyUsagePeakPercentage\r\n\t\t\t,@EnergyUsageReactivePower\r\n\t\t\t,@StreetLightingFacilityPoints;\r\n\tEND;\r\n\tCLOSE @detailCursor;\r\n\tDEALLOCATE @detailCursor;\r\n\r\n\tUPDATE input.AgencyChange\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE ID = @AgencyChangeID;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE AgencyChangeID = @AgencyChangeID AND [Status] IN ('CALCULATED');\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.757000",
      "last_altered": "2025-08-25 15:54:05.757000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@details",
        "data_type": "UDT_AgencyChangeDetail",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangeDetailsSave",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgencyChangeDetailsSave` is designed to handle the insertion and updating of agency change details within a SQL Server database. It processes a set of records provided as a table-valued parameter and updates or inserts them into the `input.agencychangedetail` table. Additionally, it updates the `ModifiedDate` and `ModifiedBy` fields in the `input.AgencyChange` table and changes the status of related records in the `budget.Scenario` table to 'REQUIRERECALC' if they are currently 'CALCULATED'.\n\n#### 2. Complexity Level: Medium\nThe complexity of this stored procedure is medium due to the use of a cursor for row-by-row processing, conditional logic for determining whether to update or insert records, and the involvement of multiple tables. The procedure also includes updates to related tables, which adds to its complexity.\n\n#### 3. Input Parameters\n- `@details AS input.UDT_AgencyChangeDetail READONLY`: A table-valued parameter that contains the details of agency changes. This parameter is expected to be a user-defined table type that includes columns corresponding to the fields in the `input.agencychangedetail` table.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: An optional parameter that specifies who is performing the action. It defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance.\n2. **Variable Declaration**: Several variables are declared to hold data from the cursor and to manage the insertion of new records.\n3. **Determine Next Entity ID**: The procedure calculates the next available `agencychangedetailentityid` by selecting the maximum current ID and adding one.\n4. **Cursor Setup**: A cursor is declared and opened to iterate over the records in the `@details` table-valued parameter.\n5. **Row Processing**:\n   - For each row, the procedure checks if `AgencyChangeDetailEntityId` is greater than -1.\n   - If true, it updates the existing record in `input.agencychangedetail`.\n   - If false, it inserts a new record using the calculated `AgencyChangeDetailEntityIdMaxPlusOne`.\n6. **Cursor Cleanup**: The cursor is closed and deallocated after processing all rows.\n7. **Update Related Tables**:\n   - The `input.AgencyChange` table is updated with the current date and the action performer.\n   - The `budget.Scenario` table is updated to set the status to 'REQUIRERECALC' for records related to the processed `AgencyChangeID` that are currently 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **Cursor Usage**: The use of a cursor can lead to performance issues, especially with large datasets, as it processes rows one at a time. Consider using set-based operations if possible.\n- **Concurrency**: The procedure does not include explicit transaction handling, which could lead to concurrency issues if multiple instances of the procedure are run simultaneously.\n- **Indexing**: Ensure that the `agencychangedetailentityid`, `AgencyChangeID`, and `BillingPeriod` columns are indexed to improve the performance of update and insert operations.\n\n#### 6. Potential Issues or Risks\n- **Concurrency and Locking**: Without explicit transaction management, there is a risk of data inconsistency if the procedure is executed concurrently by multiple users.\n- **Error Handling**: The procedure lacks error handling, which could lead to unhandled exceptions and partial data updates in case of failures.\n- **Scalability**: The use of a cursor may not scale well with large datasets, potentially leading to long execution times.\n- **Data Integrity**: The procedure assumes that the `agencychangedetailentityid` is unique and correctly managed, which may not hold true if there are concurrent inserts or updates outside this procedure.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 2323,
      "api_response_id": "chatcmpl-C8VU8olUV70uCJcab6agZM2va9P0i"
    },
    "analysis_timestamp": "2025-08-25 13:41:53"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangesRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_AgencyChangesRetrieve]\r\n(\r\n\t@fy AS INT = NULL\r\n\t,@id AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @used AS BIT = 0;\r\n\r\n\tIF (@id IS NOT NULL)\r\n\tBEGIN\r\n\t   SELECT @used= CASE WHEN EXISTS (SELECT 1 FROM budget.Scenario WHERE [Status] = 'CALCULATED' AND AgencyChangeID = @id) THEN 1 ELSE 0 END;\r\n\tEND;\r\n\r\n\tSELECT ID\r\n\t\t,[Name]\r\n\t\t,[Description]\r\n\t\t,FY\r\n\t\t,CreatedBy\r\n\t\t,CreatedDate\r\n\t\t,ModifiedBy\r\n\t\t,ModifiedDate\r\n\t\t,Active\r\n\t\t,Locked\r\n\t\t,@used AS UsedByOtherCalculatedScenario\r\n\tFROM input.vwAgencyChanges\r\n\tWHERE ID = ISNULL(@id, ID) AND FY = ISNULL(@fy, FY)\r\n\tORDER BY FY DESC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.760000",
      "last_altered": "2025-08-25 15:54:05.760000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangesRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgencyChangesRetrieve` is designed to retrieve records from the `input.vwAgencyChanges` view based on optional filtering criteria provided by fiscal year (`@fy`) and agency change ID (`@id`). It also checks if a specific agency change ID is used in any calculated scenarios within the `budget.Scenario` table. The procedure returns a set of columns from the view along with an additional column indicating whether the agency change is used by any calculated scenario.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving basic SQL operations such as conditional logic, a simple subquery, and a SELECT statement with optional filtering. It does not involve complex joins, aggregations, or advanced SQL features.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: An optional parameter representing the fiscal year. If provided, it filters the results to include only records matching this fiscal year.\n- `@id AS INT = NULL`: An optional parameter representing the agency change ID. If provided, it filters the results to include only records matching this ID and checks if this ID is used in any calculated scenarios.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n2. **Transaction Isolation Level**: It sets the transaction isolation level to `READ UNCOMMITTED`, allowing dirty reads. This can improve performance by not acquiring shared locks but at the risk of reading uncommitted data.\n3. **Usage Check**: If `@id` is provided, it checks if the agency change ID is used in any calculated scenarios in the `budget.Scenario` table. The result is stored in the `@used` variable.\n4. **Data Retrieval**: It retrieves records from the `input.vwAgencyChanges` view, applying filters based on the provided `@fy` and `@id` parameters. The result set includes an additional column `UsedByOtherCalculatedScenario`, indicating whether the agency change is used by other calculated scenarios.\n5. **Ordering**: The results are ordered by fiscal year in descending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: While this isolation level can improve performance by reducing locking overhead, it may lead to reading uncommitted or inconsistent data.\n- **Indexing**: Performance can be improved if the `budget.Scenario` table and `input.vwAgencyChanges` view are properly indexed on the columns used in the WHERE clause (`AgencyChangeID`, `ID`, `FY`).\n- **Conditional Logic**: The use of `ISNULL` in the WHERE clause allows for flexible filtering but may prevent the use of indexes effectively, potentially leading to full table scans.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to reading uncommitted data, which might not be suitable for all business scenarios, especially where data consistency is critical.\n- **Index Utilization**: The use of `ISNULL` in the WHERE clause can hinder index utilization, impacting performance negatively if the dataset is large.\n- **Scalability**: As the dataset grows, the performance of the subquery checking for existence in the `budget.Scenario` table might degrade if not properly indexed.\n- **Concurrency**: While the procedure itself does not modify data, concurrent modifications by other transactions might lead to inconsistent reads due to the chosen isolation level.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1160,
      "api_response_id": "chatcmpl-C8VUYUEJLAAJkpLGH00iqklRWQplH"
    },
    "analysis_timestamp": "2025-08-25 13:42:08"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_AgencyChangeUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_AgencyChangeUpdate]\r\n(\r\n\t@id AS INT\r\n\t,@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@active AS BIT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tUPDATE input.AgencyChange\r\n\tSET FY = @fy\r\n\t\t,[Name] = @name\r\n\t\t,[Description] = @description\r\n\t\t,Active\t= @active\r\n\t\t,ModifiedBy\t= @actionBy\r\n\t\t,ModifiedDate = GETDATE()\r\n\tWHERE ID = @id;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.767000",
      "last_altered": "2025-08-25 15:54:05.767000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@active",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AgencyChangeUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AgencyChangeUpdate` is designed to update records in the `input.AgencyChange` table. It modifies specific fields of a record identified by a unique `ID`. The procedure updates the fiscal year, name, description, active status, and records the user who performed the update along with the current timestamp.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `UPDATE` statement that modifies a record based on a primary key. There are no complex joins, conditional logic, or transactions, making it low in complexity.\n\n#### 3. Input Parameters\n- `@id AS INT`: The unique identifier for the record to be updated. This is a critical parameter as it determines which record will be modified.\n- `@fy AS INT`: Represents the fiscal year to be updated in the record.\n- `@name AS VARCHAR(250)`: The new name for the agency, limited to 250 characters.\n- `@description AS VARCHAR(500)`: A description of the agency, limited to 500 characters.\n- `@active AS BIT`: A boolean flag indicating whether the agency is active (1) or inactive (0).\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or system identifier of the person or process making the update. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance in certain scenarios.\n- It performs an `UPDATE` operation on the `input.AgencyChange` table, setting the fiscal year, name, description, active status, and updating the `ModifiedBy` and `ModifiedDate` fields.\n- The `WHERE` clause ensures that only the record with the specified `ID` is updated.\n- The `ModifiedDate` is set to the current date and time using `GETDATE()`, capturing when the update occurred.\n\n#### 5. Performance Considerations\n- The procedure's performance is generally efficient due to its simplicity and the use of a primary key (`ID`) in the `WHERE` clause, which should be indexed for optimal performance.\n- The use of `SET NOCOUNT ON` can reduce network traffic by suppressing the \"n rows affected\" message, which is beneficial in high-volume environments.\n- The procedure assumes that the `ID` is unique and indexed, which is crucial for maintaining performance.\n\n#### 6. Potential Issues or Risks\n- If the `ID` provided does not exist in the table, the procedure will execute without error but will not update any records. This could lead to silent failures if not handled at the application level.\n- There is no validation of input parameters within the procedure. Invalid or malicious input could lead to data integrity issues if not properly sanitized before being passed to the procedure.\n- The default value for `@actionBy` is 'SYSTEM', which might not always be appropriate. It is important to ensure that the correct user or process identifier is passed to maintain accurate audit trails.\n- The procedure does not handle concurrency issues. If multiple updates occur simultaneously, it could lead to race conditions or lost updates without additional mechanisms like row versioning or locking.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1023,
      "api_response_id": "chatcmpl-C8VUnSoD69YdsfCV1vJHSWqmMX7zF"
    },
    "analysis_timestamp": "2025-08-25 13:42:20"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_BaseRateClone",
      "definition": "CREATE PROCEDURE [input].[USP_BaseRateClone]\r\n    @fy INT,\r\n    @name VARCHAR(250),\r\n    @description VARCHAR(500),\r\n    @actionBy VARCHAR(25) = 'SYSTEM',\r\n    @id INT OUTPUT,\r\n    @originalId INT\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n\r\n    DECLARE @IdOutput TABLE (ID INT);\r\n\r\n    INSERT INTO input.BaseRate\r\n        (FY,\r\n        [Name],\r\n        [Description],\r\n        CreatedBy,\r\n        ModifiedBy)\r\n    OUTPUT INSERTED.ID\r\n    INTO @IdOutput\r\n    VALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n    SELECT @id = ID\r\n    FROM @IdOutput;\r\n\r\n    SELECT DISTINCT [BudgetGroupID]\r\n    INTO #TEMP_Detail_ID\r\n    FROM [input].[BaseRateDetail]\r\n    WHERE [BaseRateID] = @originalId;\r\n\r\n    SELECT DISTINCT\r\n        '' AS [AgencyCode],\r\n        [BudgetGroupID]\r\n    INTO #TEMP_Obsolete\r\n    FROM input.BaseRateDetail\r\n    WHERE [BudgetGroupID] IN\r\n          (SELECT [BudgetGroupID] FROM #TEMP_Detail_ID)\r\n          AND [BudgetGroupID] NOT IN\r\n              (SELECT [BudgetGroupID] FROM [Preload].BudgetGroupByFY WHERE FY = @fy);\r\n\r\n    DELETE #TEMP_Detail_ID\r\n    WHERE BudgetGroupID IN (SELECT [BudgetGroupID] FROM #TEMP_Obsolete);\r\n\r\n    INSERT INTO input.BaseRateDetail\r\n        (BaseRateID,\r\n        BudgetGroupID,\r\n        BillingPeriod,\r\n        CommodityConsumption,\r\n        CommodityConsumptionOffPeak,\r\n        CommodityDemand,\r\n        DeliveryConsumption,\r\n        DeliveryDemand,\r\n        DeliveryFacilityPoints,\r\n        DeliveryReactivePower,\r\n        CustomerCharge)\r\n    SELECT @id,\r\n        BudgetGroupID,\r\n        CASE\r\n            WHEN 6 < BillingPeriod % 100 THEN\r\n        (@fy - 1) * 100 + BillingPeriod % 100\r\n            ELSE\r\n                @fy * 100 + BillingPeriod % 100\r\n        END AS BillingPeriod,\r\n        CommodityConsumption,\r\n        CommodityConsumptionOffPeak,\r\n        CommodityDemand,\r\n        DeliveryConsumption,\r\n        DeliveryDemand,\r\n        DeliveryFacilityPoints,\r\n        DeliveryReactivePower,\r\n        CustomerCharge\r\n    FROM input.BaseRateDetail\r\n    WHERE BaseRateID = @originalId\r\n        AND BudgetGroupID IN (SELECT BudgetGroupID FROM #TEMP_Detail_ID);\r\n\r\n    SELECT [AgencyCode],\r\n        [BudgetGroupID]\r\n    FROM #TEMP_Obsolete;\r\n\r\n    DROP TABLE #TEMP_Obsolete,\r\n        #TEMP_Detail_ID;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.770000",
      "last_altered": "2025-08-25 15:54:05.770000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@originalId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BaseRateClone",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BaseRateClone` is designed to clone a base rate record from the `input.BaseRate` table and its associated details from the `input.BaseRateDetail` table for a specified fiscal year (`FY`). It creates a new base rate entry with a new ID and copies relevant details from an existing base rate identified by `@originalId`. The procedure also filters out obsolete budget groups that are not present in the `Preload.BudgetGroupByFY` table for the specified fiscal year.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including inserting data, handling temporary tables, and performing conditional logic for data transformation. It also includes filtering and validation logic, which adds to its complexity.\n\n#### 3. Input Parameters\n- `@fy INT`: The fiscal year for which the base rate is being cloned.\n- `@name VARCHAR(250)`: The name of the new base rate.\n- `@description VARCHAR(500)`: A description for the new base rate.\n- `@actionBy VARCHAR(25) = 'SYSTEM'`: The user or system identifier performing the action, defaulting to 'SYSTEM'.\n- `@id INT OUTPUT`: An output parameter that returns the ID of the newly created base rate.\n- `@originalId INT`: The ID of the original base rate to be cloned.\n\n#### 4. Business Logic and Workflow\n1. **Insert New Base Rate**: A new record is inserted into the `input.BaseRate` table with the provided fiscal year, name, description, and actionBy. The new ID is captured using the `OUTPUT` clause into a table variable `@IdOutput` and assigned to the output parameter `@id`.\n\n2. **Identify Relevant Budget Groups**: The procedure selects distinct `BudgetGroupID`s from `input.BaseRateDetail` associated with the original base rate (`@originalId`) and stores them in a temporary table `#TEMP_Detail_ID`.\n\n3. **Filter Obsolete Budget Groups**: It identifies budget groups that are not present in the `Preload.BudgetGroupByFY` table for the specified fiscal year and stores them in another temporary table `#TEMP_Obsolete`.\n\n4. **Remove Obsolete Budget Groups**: The procedure deletes entries from `#TEMP_Detail_ID` that are marked as obsolete.\n\n5. **Clone Base Rate Details**: It inserts new records into `input.BaseRateDetail` for the new base rate ID, transforming the `BillingPeriod` based on the fiscal year logic, and copying other fields from the original base rate details.\n\n6. **Return Obsolete Budget Groups**: The procedure selects and returns the obsolete budget groups.\n\n7. **Cleanup**: Temporary tables `#TEMP_Obsolete` and `#TEMP_Detail_ID` are dropped.\n\n#### 5. Performance Considerations\n- **Temporary Tables**: The use of temporary tables can impact performance, especially if the tables grow large. Indexing these tables could improve performance if necessary.\n- **Conditional Logic**: The transformation of `BillingPeriod` involves conditional logic, which may affect performance if the dataset is large.\n- **Concurrency**: The procedure does not include explicit transaction handling, which might lead to concurrency issues if multiple instances are executed simultaneously.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: The procedure assumes that the `@originalId` exists and is valid. If not, the procedure will fail.\n- **Obsolete Data Handling**: The logic for identifying and handling obsolete budget groups relies on the `Preload.BudgetGroupByFY` table being accurate and up-to-date.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions and incomplete operations.\n- **Scalability**: As the volume of data grows, the performance of the procedure may degrade, particularly due to the use of temporary tables and the lack of indexing.\n- **Security**: The procedure does not include any security checks or validations on the input parameters, which could lead to SQL injection if not properly handled at the application level.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1591,
      "api_response_id": "chatcmpl-C8VUzTBLTpuJXUg5eADL3W9Jk9PBt"
    },
    "analysis_timestamp": "2025-08-25 13:42:33"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_BaseRateCreate",
      "definition": "CREATE PROCEDURE [input].[USP_BaseRateCreate]\r\n\t@fy\t\t\t\t\tINT\r\n\t, @name\t\t\t\tVARCHAR(250)\r\n\t, @description\t\tVARCHAR(500)\r\n\t, @actionBy\t\t\tVARCHAR(25) = 'SYSTEM'\r\n\t, @id\t\t\t\tINT OUTPUT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO input.BaseRate (FY, Name, [Description], CreatedBy, ModifiedBy)\r\n\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\tVALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.777000",
      "last_altered": "2025-08-25 15:54:05.777000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BaseRateCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BaseRateCreate` is designed to insert a new record into the `input.BaseRate` table. It captures details such as fiscal year, name, description, and the user performing the action. After inserting the record, it retrieves the newly generated ID of the inserted record and outputs it through an output parameter.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single insert operation and the retrieval of the inserted record's ID. It does not involve complex logic, conditional statements, or multiple operations, making it low in complexity.\n\n#### 3. Input Parameters\n- `@fy INT`: Represents the fiscal year for which the base rate is being created.\n- `@name VARCHAR(250)`: The name of the base rate entry.\n- `@description VARCHAR(500)`: A textual description of the base rate.\n- `@actionBy VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system performing the action. Defaults to 'SYSTEM' if not provided.\n- `@id INT OUTPUT`: An output parameter that returns the ID of the newly inserted base rate record.\n\n#### 4. Business Logic and Workflow\n1. **SET NOCOUNT ON**: This command prevents the SQL Server from sending messages about the number of rows affected by the SQL statements, which can reduce network traffic.\n2. **DECLARE @IdOutput TABLE (ID INT)**: A table variable is declared to temporarily store the ID of the newly inserted record.\n3. **INSERT INTO input.BaseRate**: The procedure inserts a new record into the `input.BaseRate` table with the provided fiscal year, name, description, and actionBy values. Both `CreatedBy` and `ModifiedBy` fields are set to the `@actionBy` parameter.\n4. **OUTPUT INSERTED.ID INTO @IdOutput**: The `OUTPUT` clause captures the ID of the newly inserted record and stores it in the `@IdOutput` table variable.\n5. **SELECT @id = ID FROM @IdOutput**: The ID from the `@IdOutput` table variable is assigned to the `@id` output parameter, making it available to the caller of the procedure.\n\n#### 5. Performance Considerations\n- The use of `SET NOCOUNT ON` is beneficial for performance as it reduces unnecessary network traffic by suppressing row count messages.\n- The procedure is efficient for its purpose, as it performs a single insert operation and uses a table variable to capture the output, which is suitable for handling a small number of rows (in this case, just one).\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: If multiple users execute this procedure simultaneously, there is no inherent risk of data inconsistency since each execution is independent. However, if the `input.BaseRate` table has constraints or triggers, those could introduce issues.\n- **Error Handling**: The procedure lacks error handling. If the insert operation fails (e.g., due to a constraint violation), the procedure will terminate with an error, and the caller will not receive a meaningful error message or the output ID.\n- **Default Value for `@actionBy`**: The default value 'SYSTEM' might not be appropriate for all use cases. If the action is performed by a specific user, it should be explicitly provided to ensure accurate audit trails.\n- **Data Type Limitations**: The size of the `@actionBy` parameter is limited to 25 characters, which might be insufficient for some usernames or identifiers.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1082,
      "api_response_id": "chatcmpl-C8VVDORQzG5TXHZj2JphXvwlfFqie"
    },
    "analysis_timestamp": "2025-08-25 13:42:52"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_BaseRateDelete",
      "definition": "CREATE PROCEDURE [input].[USP_BaseRateDelete]\r\n\t@id\t\t\t\t\tINT\r\n\t,@actionBy\t\t\tVARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDELETE FROM input.BaseRateDetail WHERE BaseRateID = @id;\r\n\tDELETE FROM input.BaseRate WHERE ID = @id;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.780000",
      "last_altered": "2025-08-25 15:54:05.780000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BaseRateDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BaseRateDelete` is designed to delete records from two tables within the `input` schema: `BaseRateDetail` and `BaseRate`. It takes an identifier for the base rate and removes the corresponding entries from both tables. This procedure is typically used to maintain data integrity by ensuring that related records in both tables are deleted when a base rate is no longer needed.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving only two DELETE operations. It does not include any conditional logic, loops, or complex operations, making it relatively simple in terms of complexity.\n\n#### 3. Input Parameters\n- `@id INT`: This parameter represents the unique identifier of the base rate to be deleted. It is used to locate and remove the specific records from the `BaseRateDetail` and `BaseRate` tables.\n- `@actionBy VARCHAR(25) = 'SYSTEM'`: This optional parameter defaults to 'SYSTEM' and is intended to record or track the user or system process that initiated the deletion. However, in this procedure, it is not utilized within the SQL code.\n\n#### 4. Business Logic and Workflow\n1. **SET NOCOUNT ON**: This command is used to prevent the SQL Server from sending messages about the number of rows affected by the DELETE operations. This can help reduce network traffic and improve performance slightly.\n2. **DELETE Operations**:\n   - The first DELETE statement removes records from the `BaseRateDetail` table where the `BaseRateID` matches the provided `@id`. This ensures that all detail records associated with the base rate are deleted first.\n   - The second DELETE statement removes the record from the `BaseRate` table where the `ID` matches the provided `@id`. This deletes the main base rate record after its associated details have been removed.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `BaseRateID` column in the `BaseRateDetail` table and the `ID` column in the `BaseRate` table are indexed. This will improve the performance of the DELETE operations by allowing SQL Server to quickly locate the records to be deleted.\n- **Batch Deletion**: If the tables contain a large number of records, consider implementing batch deletions to avoid locking issues and reduce transaction log growth.\n\n#### 6. Potential Issues or Risks\n- **Foreign Key Constraints**: If there are foreign key constraints between `BaseRateDetail` and other tables, or between `BaseRate` and other tables, the DELETE operations may fail unless those constraints are handled appropriately.\n- **Data Integrity**: Deleting records from these tables could lead to data integrity issues if there are dependent records in other tables that are not addressed. Ensure that all related data is considered before deletion.\n- **Error Handling**: The procedure lacks error handling. Consider adding TRY...CATCH blocks to manage exceptions and log errors for troubleshooting.\n- **Unused Parameter**: The `@actionBy` parameter is not used within the procedure. If tracking the user or process is necessary, consider implementing logging or auditing mechanisms to utilize this parameter effectively.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 929,
      "api_response_id": "chatcmpl-C8VVVAnJPWeqeVKfMSCBLUanEMtvM"
    },
    "analysis_timestamp": "2025-08-25 13:43:05"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_BaseRateDetailsDelete",
      "definition": "CREATE PROCEDURE [input].[USP_BaseRateDetailsDelete]\r\n\t@baseRateId\t\t\t\t\t\t\tINT\r\n\t, @budgetGroupId\t\t\t\t\tINT = NULL\r\n\t, @billingPeriod\t\t\t\t\tINT = NULL\r\n\t, @actionBy\t\t\t\t\t\t\tVARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDELETE FROM input.BaseRateDetail\r\n\tWHERE BaseRateID\t\t\t= @baseRateId\r\n\t\tAND BudgetGroupID\t\t= ISNULL(@budgetGroupId, BudgetGroupID)\r\n\t\tAND BillingPeriod\t\t= ISNULL(@billingPeriod, BillingPeriod)\r\n\r\n\tUPDATE input.BaseRate\r\n\tSET ModifiedDate=GETDATE(), ModifiedBy=@actionBy\r\n\tWHERE ID = @baseRateId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE BaseRateID=@baseRateId AND [Status] IN ('CALCULATED');\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.787000",
      "last_altered": "2025-08-25 15:54:05.787000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@baseRateId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@billingPeriod",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BaseRateDetailsDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BaseRateDetailsDelete` is designed to perform a deletion operation on the `BaseRateDetail` table based on specific criteria, update the `BaseRate` table to reflect the modification, and adjust the status of related records in the `Scenario` table. This procedure is part of a database schema that appears to manage financial or budgetary data, specifically dealing with base rates and their associated details.\n\n#### 2. Complexity Level: Medium\nThe complexity of this stored procedure is considered medium. It involves conditional logic using `ISNULL` to handle optional parameters, performs operations on multiple tables, and includes both DELETE and UPDATE statements. The procedure also manages transactional data integrity by updating related records in different tables.\n\n#### 3. Input Parameters\n- `@baseRateId INT`: Mandatory. Identifies the specific base rate record to be targeted for deletion and updates.\n- `@budgetGroupId INT = NULL`: Optional. Specifies the budget group to filter the deletion operation. If not provided, all records matching the other criteria are affected.\n- `@billingPeriod INT = NULL`: Optional. Specifies the billing period to filter the deletion operation. If not provided, all records matching the other criteria are affected.\n- `@actionBy VARCHAR(25) = 'SYSTEM'`: Optional. Indicates the user or system process responsible for the action, used for auditing purposes in the `BaseRate` table.\n\n#### 4. Business Logic and Workflow\n1. **Deletion Operation**: The procedure deletes records from the `BaseRateDetail` table where the `BaseRateID` matches `@baseRateId`. It uses `ISNULL` to handle optional filtering by `BudgetGroupID` and `BillingPeriod`, allowing for flexible deletion criteria.\n   \n2. **Update BaseRate Table**: After deletion, the procedure updates the `ModifiedDate` and `ModifiedBy` fields in the `BaseRate` table for the record identified by `@baseRateId`. This step ensures that the modification is logged with a timestamp and the responsible entity.\n\n3. **Update Scenario Table**: The procedure updates the `Scenario` table, setting the `Status` to 'REQUIRERECALC' for records where `BaseRateID` matches `@baseRateId` and the current `Status` is 'CALCULATED'. This indicates that recalculation is necessary due to the changes made.\n\n#### 5. Performance Considerations\n- **Index Usage**: Ensure that `BaseRateID`, `BudgetGroupID`, and `BillingPeriod` are indexed to optimize the DELETE and UPDATE operations. Lack of proper indexing could lead to table scans and degrade performance.\n- **Transaction Management**: Although not explicitly mentioned, consider wrapping the operations in a transaction to maintain atomicity and consistency, especially if the procedure is part of a larger transactional workflow.\n- **Concurrency**: The procedure could potentially lead to locking issues if executed concurrently on the same `BaseRateID`. Implementing appropriate isolation levels or using row versioning could mitigate this.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Deleting records from `BaseRateDetail` without corresponding checks or constraints could lead to orphaned records or data inconsistencies if there are dependencies not accounted for.\n- **Error Handling**: The procedure lacks explicit error handling. Consider adding TRY...CATCH blocks to manage exceptions and ensure graceful failure or rollback.\n- **Security**: Ensure that only authorized users can execute this procedure, as it involves data deletion and modification. Implement appropriate permissions and auditing.\n- **Parameter Validation**: The procedure does not validate input parameters. Adding checks for valid `@baseRateId`, `@budgetGroupId`, and `@billingPeriod` values could prevent unintended data modifications.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1173,
      "api_response_id": "chatcmpl-C8VViGbXwFKAdRIE0jLO7Wa2gsTMq"
    },
    "analysis_timestamp": "2025-08-25 13:43:16"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_BaseRateDetailsRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_BaseRateDetailsRetrieve]\r\n\t@baseRateId\t\t\t\tINT = NULL\r\n\t,@budgetGroupId\t\tINT = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSELECT BaseRateID, BudgetGroupID\r\n\tFROM input.vwBaseRateDetailsDistinct\r\n\tWHERE BaseRateID\t= ISNULL(@baseRateId, BaseRateID)\r\n\t\tAND BudgetGroupID\t= ISNULL(@budgetGroupId, BudgetGroupID)\r\n\tORDER BY BaseRateID ASC, BudgetGroupID ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.790000",
      "last_altered": "2025-08-25 15:54:05.790000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@baseRateId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BaseRateDetailsRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BaseRateDetailsRetrieve` is designed to retrieve records from the view `input.vwBaseRateDetailsDistinct`. It filters the results based on optional input parameters, `@baseRateId` and `@budgetGroupId`, which correspond to the columns `BaseRateID` and `BudgetGroupID` in the view. If these parameters are not provided, the procedure returns all records. The results are ordered by `BaseRateID` and `BudgetGroupID` in ascending order.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a simple SELECT query with optional filtering based on input parameters. It does not involve complex logic, joins, or subqueries, making it easy to understand and maintain.\n\n#### 3. Input Parameters\n- `@baseRateId INT = NULL`: This parameter is used to filter the results by the `BaseRateID` column. If not provided, the procedure defaults to selecting all `BaseRateID` values.\n- `@budgetGroupId INT = NULL`: This parameter is used to filter the results by the `BudgetGroupID` column. If not provided, the procedure defaults to selecting all `BudgetGroupID` values.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It executes a SELECT query on the view `input.vwBaseRateDetailsDistinct`.\n- The WHERE clause uses the `ISNULL` function to apply filters based on the input parameters. If a parameter is NULL, the corresponding column is not filtered.\n- The results are ordered by `BaseRateID` and `BudgetGroupID` in ascending order, ensuring a consistent output order.\n\n#### 5. Performance Considerations\n- The use of `ISNULL` in the WHERE clause allows for flexible filtering but can impact performance if the view contains a large number of records. This is because SQL Server may not be able to use indexes effectively when `ISNULL` is applied to columns in the WHERE clause.\n- The performance is also dependent on the underlying view `input.vwBaseRateDetailsDistinct`. If this view is complex or involves multiple joins, it could affect the execution time of the procedure.\n- Ensuring that `BaseRateID` and `BudgetGroupID` are indexed in the underlying tables can help improve performance.\n\n#### 6. Potential Issues or Risks\n- If the view `input.vwBaseRateDetailsDistinct` is modified or if its structure changes, it could affect the procedure's functionality or performance.\n- The use of `ISNULL` for filtering can lead to full table scans if indexes are not used effectively, which might degrade performance on large datasets.\n- The procedure does not handle exceptions or errors, such as invalid input types, which could lead to runtime errors if unexpected values are passed.\n- There is no logging or auditing mechanism to track the usage of this procedure, which might be a concern in environments where tracking data access is important.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 950,
      "api_response_id": "chatcmpl-C8VVu1geW049kPn8wuFKEM5QUdWBH"
    },
    "analysis_timestamp": "2025-08-25 13:43:29"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_BaseRateDetailsRetrieveBillingPeriodDetails",
      "definition": "CREATE PROCEDURE [input].[USP_BaseRateDetailsRetrieveBillingPeriodDetails]\r\n(\r\n\t@baseRateId AS INT = NULL\r\n\t,@budgetGroupId AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT a.BaseRateID\r\n\t\t,a.BudgetGroupID\r\n\t\t,a.BillingPeriod\r\n\t\t,a.CommodityConsumption\r\n\t\t,a.CommodityConsumptionOffPeak\r\n\t\t,a.CommodityDemand\r\n\t\t,a.DeliveryConsumption\r\n\t\t,a.DeliveryDemand\r\n\t\t,a.DeliveryReactivePower\r\n\t\t,a.DeliveryFacilityPoints\r\n\t\t,a.CustomerCharge\r\n\t\t,b.BudgetGroupName\r\n\tFROM input.vwBaseRateDetails AS a\r\n\t\tINNER JOIN Preload.BudgetGroup AS b ON a.BudgetGroupID = b.BudgetGroupID\r\n\tWHERE a.BaseRateID = ISNULL(@baseRateId, a.BaseRateID)\r\n\t\tAND a.BudgetGroupID\t= ISNULL(@budgetGroupId, a.BudgetGroupID)\r\n\tORDER BY a.BaseRateID ASC, a.BudgetGroupID ASC, a.BillingPeriod ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.793000",
      "last_altered": "2025-08-25 15:54:05.793000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@baseRateId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BaseRateDetailsRetrieveBillingPeriodDetails",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BaseRateDetailsRetrieveBillingPeriodDetails` is designed to retrieve billing period details related to base rates from a view named `vwBaseRateDetails` and a table named `BudgetGroup`. It joins these two data sources to provide a comprehensive set of information about base rates, including various consumption and demand metrics, along with customer charges and budget group names. The procedure allows filtering based on `BaseRateID` and `BudgetGroupID`, and it orders the results by `BaseRateID`, `BudgetGroupID`, and `BillingPeriod`.\n\n#### 2. Complexity Level: Low\nThe procedure is relatively straightforward, involving a single SELECT statement with a JOIN operation and optional filtering based on input parameters. The use of `ISNULL` for parameter handling and the setting of transaction isolation level are simple operations, contributing to a low complexity level.\n\n#### 3. Input Parameters\n- `@baseRateId AS INT = NULL`: This parameter allows filtering the results by a specific `BaseRateID`. If not provided (NULL), the procedure retrieves records for all `BaseRateID` values.\n- `@budgetGroupId AS INT = NULL`: This parameter allows filtering the results by a specific `BudgetGroupID`. If not provided (NULL), the procedure retrieves records for all `BudgetGroupID` values.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read uncommitted changes from other transactions, which can reduce locking and blocking but may result in dirty reads.\n- The main logic is a SELECT statement that retrieves columns from the `vwBaseRateDetails` view and joins it with the `BudgetGroup` table to include the `BudgetGroupName`.\n- The WHERE clause uses `ISNULL` to handle optional filtering based on the input parameters, allowing for flexible querying.\n- The results are ordered by `BaseRateID`, `BudgetGroupID`, and `BillingPeriod` to ensure a consistent and logical output order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead, but it may lead to dirty reads.\n- The procedure's performance largely depends on the underlying indexes on `vwBaseRateDetails` and `BudgetGroup`. Proper indexing on `BaseRateID` and `BudgetGroupID` can significantly enhance query performance.\n- The use of `ISNULL` in the WHERE clause can prevent the use of indexes effectively, potentially leading to full table scans if not handled properly by the query optimizer.\n\n#### 6. Potential Issues or Risks\n- The `READ UNCOMMITTED` isolation level can lead to dirty reads, where the data read might not be consistent or committed, which could be problematic in scenarios requiring data accuracy.\n- If the `vwBaseRateDetails` view or `BudgetGroup` table lacks appropriate indexing, the query could perform poorly, especially with large datasets.\n- The use of `ISNULL` in the WHERE clause might lead to suboptimal query plans if not optimized correctly, affecting performance.\n- The procedure does not handle exceptions or errors, which could lead to unhandled exceptions if issues arise during execution.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1144,
      "api_response_id": "chatcmpl-C8VW6j88iNvFFizDW8yS701pHb190"
    },
    "analysis_timestamp": "2025-08-25 13:43:43"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_BaseRateDetailsSave",
      "definition": "CREATE PROCEDURE [input].[USP_BaseRateDetailsSave]\r\n\t@details\t\tinput.UDT_BaseRateDetail READONLY\r\n\t, @budgetGroupId\tINT = NULL\r\n\t, @actionBy\t\tVARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @baseRateId INT;\r\n\r\n\tSELECT @baseRateId=MAX(BaseRateID)\r\n\tFROM @details;\r\n\r\n\tIf @budgetGroupId<>35 --Edit, then delete old first\r\n\t\tDELETE FROM input.BaseRateDetail\r\n\t\tWHERE BaseRateID = (SELECT DISTINCT BaseRateID FROM @details)\r\n\t\t\t  AND BudgetGroupID = @budgetGroupId;\r\n\r\n\t-- Create temp table with existing base rates for given base rate\r\n\tSELECT BaseRateID, BudgetGroupID, BillingPeriod\r\n\t\t,CommodityConsumption, CommodityConsumptionOffPeak, CommodityDemand\r\n\t\t,DeliveryConsumption, DeliveryDemand, DeliveryReactivePower, DeliveryFacilityPoints\r\n\t\t,CustomerCharge\r\n\tINTO #tmpBaseRates\r\n\tFROM input.BaseRateDetail\r\n\tWHERE BaseRateID = (SELECT DISTINCT BaseRateID FROM @details)\r\n\t\tAND BudgetGroupID = (SELECT DISTINCT BudgetGroupID FROM @details);\r\n\r\n\t-- Merge changes FROM input base rates table\r\n\tMERGE #tmpBaseRates AS TARGET\r\n\tUSING @details AS SOURCE\r\n\tON TARGET.BaseRateID\t\t\t= SOURCE.BaseRateID\r\n\t\tAND TARGET.BudgetGroupID\t= SOURCE.BudgetGroupID\r\n\t\tAND TARGET.BillingPeriod\t= SOURCE.BillingPeriod\r\n\tWHEN MATCHED THEN\r\n\t\tUPDATE SET\r\n\t\t\tTARGET.CommodityConsumption\t\t\t\t= SOURCE.CommodityConsumption\r\n\t\t\t, TARGET.CommodityConsumptionOffPeak\t= SOURCE.CommodityConsumptionOffPeak\r\n\t\t\t, TARGET.CommodityDemand\t\t\t\t= SOURCE.CommodityDemand\r\n\t\t\t, TARGET.DeliveryConsumption\t\t\t= SOURCE.DeliveryConsumption\r\n\t\t\t, TARGET.DeliveryDemand\t\t\t\t\t= SOURCE.DeliveryDemand\r\n\t\t\t, TARGET.DeliveryReactivePower\t\t\t= SOURCE.DeliveryReactivePower\r\n\t\t\t, TARGET.DeliveryFacilityPoints\t\t\t= SOURCE.DeliveryFacilityPoints\r\n\t\t\t, TARGET.CustomerCharge\t\t\t\t\t= SOURCE.CustomerCharge\r\n\tWHEN NOT MATCHED BY TARGET THEN\r\n\t\tINSERT (BaseRateID, BudgetGroupID\r\n\t\t\t, BillingPeriod\r\n\t\t\t, CommodityConsumption, CommodityConsumptionOffPeak, CommodityDemand\r\n\t\t\t, DeliveryConsumption, DeliveryDemand, DeliveryReactivePower, DeliveryFacilityPoints\r\n\t\t\t, CustomerCharge)\r\n\t\tVALUES (SOURCE.BaseRateID, SOURCE.BudgetGroupID, SOURCE.BillingPeriod\r\n\t\t\t, SOURCE.CommodityConsumption, SOURCE.CommodityConsumptionOffPeak, SOURCE.CommodityDemand\r\n\t\t\t, SOURCE.DeliveryConsumption, SOURCE.DeliveryDemand, SOURCE.DeliveryReactivePower, SOURCE.DeliveryFacilityPoints\r\n\t\t\t, SOURCE.CustomerCharge)\r\n\tWHEN NOT MATCHED BY SOURCE THEN\r\n\t\tDELETE;\r\n\r\n\tDELETE FROM input.BaseRateDetail\r\n\tWHERE BaseRateID = (SELECT DISTINCT BaseRateID FROM @details)\r\n\t\tAND BudgetGroupID = (SELECT DISTINCT BudgetGroupID FROM @details);\r\n\r\n\tINSERT INTO input.BaseRateDetail (BaseRateID, BudgetGroupID, BillingPeriod\r\n\t\t\t, CommodityConsumption, CommodityConsumptionOffPeak, CommodityDemand\r\n\t\t\t, DeliveryConsumption, DeliveryDemand, DeliveryFacilityPoints, DeliveryReactivePower\r\n\t\t\t, CustomerCharge)\r\n\t\tSELECT BaseRateID, BudgetGroupID, BillingPeriod\r\n\t\t\t, CommodityConsumption, CommodityConsumptionOffPeak, CommodityDemand\r\n\t\t\t, DeliveryConsumption, DeliveryDemand, DeliveryFacilityPoints, DeliveryReactivePower\r\n\t\t\t, CustomerCharge\r\n\t\tFROM #tmpBaseRates;\r\n\r\n\tUPDATE input.BaseRate\r\n\tSET ModifiedDate=GETDATE(), ModifiedBy=@actionBy\r\n\tWHERE ID = @baseRateId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE BaseRateID=@baseRateId AND [Status] IN ('CALCULATED');\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.800000",
      "last_altered": "2025-08-25 15:54:05.800000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@details",
        "data_type": "UDT_BaseRateDetail",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BaseRateDetailsSave",
      "explanation": "#### 1. Overview\n\nThe stored procedure `USP_BaseRateDetailsSave` is designed to manage the saving of base rate details into the `input.BaseRateDetail` table. It takes a set of base rate details as input, processes them, and updates the database accordingly. The procedure handles both updates to existing records and the insertion of new records, as well as the deletion of records that are no longer needed. It also updates metadata in related tables to reflect changes.\n\n#### 2. Complexity Level: Medium\n\nThe procedure involves several SQL operations, including conditional logic, temporary table creation, and a `MERGE` statement, which adds to its complexity. The use of a table-valued parameter and the need to handle different scenarios (insert, update, delete) also contribute to the medium complexity level.\n\n#### 3. Input Parameters\n\n- `@details`: A table-valued parameter of type `input.UDT_BaseRateDetail`. It contains the base rate details to be processed. This parameter is used to pass multiple rows of data into the procedure.\n- `@budgetGroupId`: An optional integer parameter with a default value of `NULL`. It specifies the budget group ID for which the base rate details are being processed.\n- `@actionBy`: A string parameter with a default value of `'SYSTEM'`. It indicates the user or system responsible for the action, used for auditing purposes.\n\n#### 4. Business Logic and Workflow\n\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance.\n\n2. **Determine Base Rate ID**: It retrieves the maximum `BaseRateID` from the input details to identify the relevant base rate.\n\n3. **Conditional Deletion**: If the `@budgetGroupId` is not 35, it deletes existing records in `input.BaseRateDetail` that match the `BaseRateID` and `BudgetGroupID` from the input details.\n\n4. **Temporary Table Creation**: A temporary table `#tmpBaseRates` is created to hold existing base rate details for the specified `BaseRateID` and `BudgetGroupID`.\n\n5. **Merge Operation**: The procedure uses a `MERGE` statement to synchronize the temporary table with the input details:\n   - **Matched Rows**: Updates existing records in the temporary table with values from the input details.\n   - **Not Matched by Target**: Inserts new records into the temporary table.\n   - **Not Matched by Source**: Deletes records from the temporary table that are not present in the input details.\n\n6. **Final Update and Insert**: Deletes all records from `input.BaseRateDetail` for the specified `BaseRateID` and `BudgetGroupID`, then inserts the processed records from the temporary table back into `input.BaseRateDetail`.\n\n7. **Metadata Update**: Updates the `ModifiedDate` and `ModifiedBy` fields in the `input.BaseRate` table for the relevant `BaseRateID`.\n\n8. **Scenario Status Update**: Updates the status of related scenarios in the `budget.Scenario` table to `'REQUIRERECALC'` if their current status is `'CALCULATED'`.\n\n#### 5. Performance Considerations\n\n- **Use of Temporary Table**: The creation and use of a temporary table can be resource-intensive, especially if the dataset is large. Indexing the temporary table could improve performance.\n- **MERGE Statement**: While powerful, the `MERGE` statement can be complex and may have performance implications if not optimized properly.\n- **DELETE and INSERT Operations**: The procedure performs a full delete and insert operation, which can be costly in terms of performance. Consideration should be given to optimizing these operations, especially for large datasets.\n\n#### 6. Potential Issues or Risks\n\n- **Concurrency**: The procedure does not include explicit transaction handling, which could lead to issues in a concurrent environment. Implementing transactions could help maintain data integrity.\n- **Error Handling**: There is no error handling in place. Adding `TRY...CATCH` blocks could help manage exceptions and ensure the procedure fails gracefully.\n- **Assumptions on Uniqueness**: The use of `SELECT DISTINCT` assumes that `BaseRateID` and `BudgetGroupID` are unique within the input details. If this assumption is violated, it could lead to unexpected behavior.\n- **Hardcoded Logic**: The check for `@budgetGroupId<>35` is hardcoded, which reduces flexibility. If business rules change, the procedure will need to be updated.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1968,
      "api_response_id": "chatcmpl-C8VWKhm4Vai4NWyHP9ZtPnoMiunB1"
    },
    "analysis_timestamp": "2025-08-25 13:44:10"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_BaseRatesRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_BaseRatesRetrieve]\r\n\t@fy\t\t\t\t\tINT = NULL\r\n\t, @id\t\t\t\tINT = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tDECLARE @used bit = 0;\r\n\r\n\tIF @id IS NOT NULL\r\n\t   SELECT @used= CASE WHEN EXISTS (SELECT 1 FROM budget.Scenario s WHERE s.Status = 'CALCULATED' AND s.BaseRateID = @id) THEN 1 ELSE 0 END \r\n\r\n\tSELECT ID, Name, [Description], FY\r\n\t\t, CreatedBy, CreatedDate, ModifiedBy, ModifiedDate\r\n\t\t, Active\r\n\t\t, Locked\r\n\t\t, @used AS UsedByOtherCalculatedScenario \r\n\tFROM input.vwBaseRates\r\n\tWHERE ID = ISNULL(@id, ID) AND FY = ISNULL(@fy, FY)\r\n\tORDER BY FY DESC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.807000",
      "last_altered": "2025-08-25 15:54:05.807000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BaseRatesRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BaseRatesRetrieve` is designed to retrieve base rate information from a view named `input.vwBaseRates`. It optionally filters the results based on fiscal year (`@fy`) and/or a specific base rate ID (`@id`). Additionally, it checks if a given base rate ID is used in any calculated scenarios within the `budget.Scenario` table and includes this information in the result set.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a simple SELECT query with optional filtering and a conditional check using an EXISTS clause. The logic is easy to follow and does not involve complex operations or multiple steps.\n\n#### 3. Input Parameters\n- `@fy INT = NULL`: This parameter allows filtering the results by fiscal year. If not provided, the procedure retrieves records for all fiscal years.\n- `@id INT = NULL`: This parameter allows filtering by a specific base rate ID. If not provided, the procedure retrieves records for all IDs.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages to the client, which can improve performance in certain scenarios.\n2. **Declare Variable**: A bit variable `@used` is declared and initialized to 0. This variable is used to determine if the specified base rate ID is used in any calculated scenarios.\n3. **Check Usage**: If `@id` is not NULL, the procedure checks if the base rate ID is used in any scenarios with the status 'CALCULATED' in the `budget.Scenario` table. If such a scenario exists, `@used` is set to 1.\n4. **Select Query**: The procedure retrieves columns from the `input.vwBaseRates` view, including the `@used` variable as `UsedByOtherCalculatedScenario`. The results are filtered based on the provided `@fy` and `@id` parameters, using `ISNULL` to handle NULL values, and are ordered by fiscal year in descending order.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `budget.Scenario` table and `input.vwBaseRates` view are properly indexed on columns used in the WHERE clause (`BaseRateID`, `Status`, `ID`, `FY`) to optimize query performance.\n- **NOCOUNT**: The use of `SET NOCOUNT ON` can reduce network traffic between the server and client, which is beneficial in high-transaction environments.\n- **Conditional Logic**: The use of `EXISTS` is efficient for checking the existence of rows and is generally faster than using a COUNT function.\n\n#### 6. Potential Issues or Risks\n- **NULL Handling**: The use of `ISNULL` in the WHERE clause can lead to full table scans if indexes are not used effectively, potentially impacting performance.\n- **Concurrency**: If the `budget.Scenario` table is frequently updated, there might be concurrency issues or blocking when checking for the existence of calculated scenarios.\n- **Security**: Ensure that appropriate permissions are set for accessing the `input.vwBaseRates` view and `budget.Scenario` table to prevent unauthorized data access.\n- **Data Integrity**: The procedure assumes that the `vwBaseRates` view and `Scenario` table are consistently maintained. Any discrepancies in data integrity could lead to incorrect results.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1098,
      "api_response_id": "chatcmpl-C8VWlrMXBg68CUoNfZQEMh52XeYR1"
    },
    "analysis_timestamp": "2025-08-25 13:44:20"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_BaseRateUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_BaseRateUpdate]\r\n\t@id\t\t\t\t\tINT\r\n\t,@fy\t\t\t\tINT\r\n\t,@name\t\t\t\tVARCHAR(250)\r\n\t,@description\t\tVARCHAR(500)\r\n\t,@active\t\t\tBIT\r\n\t,@actionBy\t\t\tVARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tUPDATE input.BaseRate\r\n\tSET FY\t\t\t\t= @fy\r\n\t\t,[Name]\t\t\t= @name\r\n\t\t,[Description]\t= @description\r\n\t\t,Active\t\t= @active\r\n\t\t,ModifiedBy\t= @actionBy\r\n\t\t,ModifiedDate\t= GETDATE()\r\n\tWHERE ID = @id;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.810000",
      "last_altered": "2025-08-25 15:54:05.810000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@active",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_BaseRateUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_BaseRateUpdate` is designed to update records in the `input.BaseRate` table. It modifies the fiscal year, name, description, active status, and metadata fields such as the user who performed the action and the modification date for a specific record identified by its ID.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `UPDATE` statement that modifies a record based on a primary key. It does not involve complex logic, conditional statements, or transactions, making it low in complexity.\n\n#### 3. Input Parameters\n- `@id INT`: The unique identifier for the record to be updated in the `BaseRate` table. This is a critical parameter as it determines which record will be modified.\n- `@fy INT`: Represents the fiscal year to be updated in the record.\n- `@name VARCHAR(250)`: The new name for the record, allowing up to 250 characters.\n- `@description VARCHAR(500)`: A textual description of the record, with a maximum length of 500 characters.\n- `@active BIT`: A boolean flag indicating whether the record is active (1) or inactive (0).\n- `@actionBy VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system making the update. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It executes an `UPDATE` statement on the `input.BaseRate` table, setting the fiscal year, name, description, active status, and metadata fields (`ModifiedBy` and `ModifiedDate`) for the record with the specified `ID`.\n- The `ModifiedDate` is automatically set to the current date and time using `GETDATE()`, ensuring the record reflects the latest update timestamp.\n\n#### 5. Performance Considerations\n- The procedure's performance is primarily dependent on the indexing of the `ID` column in the `BaseRate` table. Assuming `ID` is a primary key or has an index, the update operation should be efficient.\n- The use of `SET NOCOUNT ON` is a good practice to reduce unnecessary network traffic, especially in environments where the procedure might be called frequently.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: If multiple users attempt to update the same record simultaneously, it could lead to race conditions. Implementing row-level locking or using transactions might be necessary in high-concurrency environments.\n- **Data Integrity**: There is no validation of input parameters within the procedure. Invalid or malicious data could be passed, potentially leading to data integrity issues. Input validation should be handled at the application level or by adding constraints.\n- **Default Value for `@actionBy`**: The default value of 'SYSTEM' for `@actionBy` might not always be appropriate. It could lead to confusion if not explicitly set by the caller, especially in environments where audit trails are critical.\n- **Error Handling**: The procedure lacks error handling. If the `UPDATE` fails (e.g., due to a non-existent `ID`), the caller will not receive any feedback. Implementing TRY...CATCH blocks could improve robustness by capturing and handling exceptions.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1046,
      "api_response_id": "chatcmpl-C8VWvVZ4WgPLCnoEMfZoHGUjfC6bR"
    },
    "analysis_timestamp": "2025-08-25 13:44:36"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ChargebackBreakdownListUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_ChargebackBreakdownListUpdate] \r\n(\r\n\t@NewBreakdownList AS input.UDT_ChargebackBreakdown READONLY\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\t \r\n\tDECLARE @tmpbreakdown TABLE (ID INT NULL,\r\n\t\tSummaryId INT NOT NULL,\r\n\t\tAgencyNo VARCHAR(6) NOT NULL,\r\n\t\tDemBudgetGroup INT NULL,\r\n\t\tAgencyShare DECIMAL(18, 2) NULL,\r\n\t\tIsTemporary BIT NOT NULL);\r\n\t \r\n\tINSERT INTO @tmpbreakdown (ID, SummaryId, AgencyNo, DemBudgetGroup, AgencyShare, IsTemporary)\r\n\tSELECT ID, SummaryId, AgencyNo, DemBudgetGroup, AgencyShare, IsTemporary\r\n\tFROM input.ChargebackBreakdown\r\n\tWHERE SummaryId IN (SELECT DISTINCT SummaryId FROM @NewBreakdownList);\r\n\r\n\tMERGE input.ChargebackBreakdown AS T\r\n\tUSING @tmpbreakdown AS S ON T.ID = S.ID AND T.SummaryId IN (SELECT DISTINCT SummaryId FROM @NewBreakdownList)\r\n\tWHEN MATCHED THEN\r\n\t\tUPDATE SET SummaryId = S.SummaryId\r\n\t\t,AgencyNo = S.AgencyNo\r\n\t\t,DemBudgetGroup = S.DemBudgetGroup\r\n\t\t,AgencyShare = S.AgencyShare\r\n\t\t,IsTemporary = S.IsTemporary;\r\n\r\n\tDELETE FROM input.ChargebackBreakdown\r\n\tWHERE SummaryId IN (SELECT DISTINCT SummaryId FROM @NewBreakdownList)\r\n\t\tAND ID NOT IN (SELECT DISTINCT ID FROM @NewBreakdownList);\r\n\r\n\tINSERT INTO input.ChargebackBreakdown (SummaryId, AgencyNo, DemBudgetGroup, AgencyShare, IsTemporary)\r\n\tSELECT SummaryId,  AgencyNo, DemBudgetGroup, AgencyShare, IsTemporary\r\n\tFROM @NewBreakdownList\r\n\tWHERE ID = 0;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.820000",
      "last_altered": "2025-08-25 15:54:05.820000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@NewBreakdownList",
        "data_type": "UDT_ChargebackBreakdown",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ChargebackBreakdownListUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ChargebackBreakdownListUpdate` is designed to update the `ChargebackBreakdown` table in the `input` schema based on a new set of data provided through a user-defined table type parameter. It performs a series of operations: it first creates a temporary table to store existing records that match the new data's `SummaryId`, then uses a `MERGE` statement to update existing records, deletes records that are no longer present in the new data, and finally inserts new records where the `ID` is zero.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple operations including data selection, temporary table usage, a `MERGE` statement, and conditional logic for deletion and insertion. These operations require a good understanding of SQL, particularly the `MERGE` statement and handling of table variables, making it moderately complex.\n\n#### 3. Input Parameters\n- `@NewBreakdownList`: This is a table-valued parameter of type `input.UDT_ChargebackBreakdown`. It is used to pass a set of new or updated chargeback breakdown records to the procedure. The parameter is read-only and is expected to contain columns that match the structure of the `ChargebackBreakdown` table.\n\n#### 4. Business Logic and Workflow\n1. **Temporary Table Creation**: A temporary table `@tmpbreakdown` is created to store existing records from `ChargebackBreakdown` that have a `SummaryId` matching any in the new data.\n2. **Data Insertion into Temporary Table**: The procedure populates `@tmpbreakdown` with records from `ChargebackBreakdown` where `SummaryId` matches those in `@NewBreakdownList`.\n3. **Data Update with MERGE**: The `MERGE` statement updates records in `ChargebackBreakdown` that match on `ID` and `SummaryId`, setting their fields to the values from `@tmpbreakdown`.\n4. **Data Deletion**: Records in `ChargebackBreakdown` with a `SummaryId` in `@NewBreakdownList` but an `ID` not present in `@NewBreakdownList` are deleted.\n5. **Data Insertion**: New records from `@NewBreakdownList` where `ID` is zero are inserted into `ChargebackBreakdown`.\n\n#### 5. Performance Considerations\n- **Temporary Table Usage**: The use of a temporary table can be efficient for managing intermediate data, but it may consume memory and affect performance if the dataset is large.\n- **MERGE Statement**: While powerful, the `MERGE` statement can be resource-intensive, especially if the tables involved are large or lack proper indexing.\n- **Indexing**: Ensuring that `ChargebackBreakdown` has appropriate indexes on `ID` and `SummaryId` can significantly improve the performance of the `MERGE`, `DELETE`, and `INSERT` operations.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: The procedure does not include explicit transaction handling, which could lead to data inconsistencies if multiple instances run concurrently.\n- **Data Integrity**: The procedure assumes that `ID` values in `@NewBreakdownList` are correctly set to zero for new records. Incorrect data could lead to unintended deletions or insertions.\n- **Error Handling**: There is no error handling mechanism in place. Any runtime errors could cause the procedure to fail without logging or rollback, potentially leaving the database in an inconsistent state.\n- **Scalability**: As the volume of data grows, the performance of the `MERGE` and `DELETE` operations may degrade if not properly indexed or optimized.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1369,
      "api_response_id": "chatcmpl-C8VXBRZYrKpId1OYSUAPeHOd8wdqm"
    },
    "analysis_timestamp": "2025-08-25 13:45:00"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ChargebackFlattenedListForExport",
      "definition": "CREATE PROCEDURE [input].[USP_ChargebackFlattenedListForExport]\r\n(\r\n\t@fy AS INT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\t \r\n\tSELECT IsTemporary,\r\n        AgencyShare,\r\n        FY,\r\n        AcceptanceDate,\r\n        InvoiceNumber,\r\n        TotalChargeback,\r\n        UtilityCompany,\r\n        ContractNumber,\r\n        TotalPayment,\r\n        BillingPeriod,\r\n        IsManual,\r\n        Note,\r\n        AgencyCodeOEC,\r\n        AgencyName,\r\n        BudgetGroupID,\r\n        BudgetGroupName\r\n\tFROM input.vwFlatChargebackExport\r\n\tWHERE FY = @fy;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.820000",
      "last_altered": "2025-08-25 15:54:05.820000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ChargebackFlattenedListForExport",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ChargebackFlattenedListForExport` is designed to retrieve a list of chargeback records for a specified fiscal year from a view named `vwFlatChargebackExport`. The procedure is intended for exporting chargeback data, potentially for reporting or data analysis purposes. It selects various fields related to chargebacks, such as financial details, agency information, and contract specifics.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `SELECT` statement with a `WHERE` clause to filter records based on the fiscal year. It does not involve complex logic, joins, or conditional statements, making it low in complexity.\n\n#### 3. Input Parameters\n- `@fy AS INT`: This parameter represents the fiscal year for which the chargeback data is to be retrieved. It is used to filter the records in the `vwFlatChargebackExport` view to only include those that match the specified fiscal year.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages to the client, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the procedure to read data without acquiring locks, which can improve performance but at the risk of reading uncommitted or \"dirty\" data.\n- The core logic is a `SELECT` statement that retrieves a set of columns from the `vwFlatChargebackExport` view, filtered by the fiscal year (`FY`) provided as an input parameter.\n- The selected columns include various attributes related to chargebacks, such as financial metrics, agency details, and contract information.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED Isolation Level**: This setting can improve performance by reducing locking overhead, but it may lead to reading uncommitted data, which could be inconsistent or incorrect.\n- **Indexing**: The performance of the `SELECT` statement depends on the indexing of the `vwFlatChargebackExport` view, particularly on the `FY` column. Proper indexing can significantly enhance query performance.\n- **Network Traffic**: The use of `SET NOCOUNT ON` helps reduce unnecessary network traffic by suppressing the message that indicates the number of rows affected by the `SELECT` statement.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to dirty reads, where the data retrieved might not be committed and could change, leading to potential inconsistencies in the exported data.\n- **Data Integrity**: If the underlying data in `vwFlatChargebackExport` is being modified concurrently, there is a risk of retrieving partial or inconsistent data due to the lack of locking.\n- **Scalability**: As the dataset grows, the performance of the `SELECT` statement may degrade if appropriate indexes are not in place, particularly on the `FY` column.\n- **Error Handling**: The procedure lacks error handling mechanisms, which means any runtime errors during execution will not be gracefully managed, potentially leading to abrupt failures without informative feedback.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 991,
      "api_response_id": "chatcmpl-C8VXZGB5o9YeDavaMTJDP3npVCAH4"
    },
    "analysis_timestamp": "2025-08-25 13:45:16"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_CheckInputUniqueness",
      "definition": "\r\nCREATE PROCEDURE [input].[USP_CheckInputUniqueness]\r\n\t @AgencyChangeId\t\tINT\r\n\t,@AgencyCode\t\t\tVARCHAR(6)\r\n\t,@BudgetGroupId\t\t\tINT\r\n\t,@FacilityNo\t\t\tVARCHAR(10)\r\n\t,@DetailCount\t\t\tINT OUTPUT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSELECT @DetailCount = COUNT(*)\r\n\tFROM input.AgencyChangeDetail\r\n\tWHERE agencyChangeId = @AgencyChangeId AND agencyCode = @AgencyCode\r\n\t\tAND budgetGroupId = @BudgetGroupId AND facilityNo = @FacilityNo \r\nEND\r\n",
      "created": "2025-08-25 15:54:05.827000",
      "last_altered": "2025-08-25 15:54:05.827000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@AgencyChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@AgencyCode",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@BudgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@FacilityNo",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 10,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@DetailCount",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_CheckInputUniqueness",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_CheckInputUniqueness` is designed to determine the uniqueness of a specific combination of input parameters within the `input.AgencyChangeDetail` table. It counts the number of records that match the given criteria and returns this count through an output parameter. This procedure is useful for checking if a particular set of attributes already exists in the table, which can be crucial for maintaining data integrity and preventing duplicate entries.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `SELECT` statement with a `COUNT` function. It does not include any complex logic, conditional branching, or iterative processes, which keeps its complexity low.\n\n#### 3. Input Parameters\n- `@AgencyChangeId INT`: Represents the unique identifier for an agency change. It is used to filter records in the `AgencyChangeDetail` table.\n- `@AgencyCode VARCHAR(6)`: A code representing the agency. It is used as a filter criterion.\n- `@BudgetGroupId INT`: Identifies the budget group associated with the agency change. It is another filter criterion.\n- `@FacilityNo VARCHAR(10)`: Represents the facility number related to the agency change. It is used to further refine the search.\n- `@DetailCount INT OUTPUT`: An output parameter that returns the count of records matching the input criteria.\n\n#### 4. Business Logic and Workflow\n1. The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic and improve performance.\n2. It executes a `SELECT` statement that counts the number of rows in the `input.AgencyChangeDetail` table where the columns `agencyChangeId`, `agencyCode`, `budgetGroupId`, and `facilityNo` match the provided input parameters.\n3. The result of the `COUNT` function is assigned to the `@DetailCount` output parameter, which can be used by the calling application or process to determine if the input combination is unique.\n\n#### 5. Performance Considerations\n- The performance of this procedure largely depends on the indexing of the `input.AgencyChangeDetail` table. If the columns used in the `WHERE` clause are indexed, the query will execute more efficiently.\n- The use of `SET NOCOUNT ON` is a good practice as it reduces unnecessary network traffic by suppressing the message indicating the number of rows affected by the `SELECT` statement.\n- The procedure's performance is optimal for small to moderately sized tables. However, as the table grows, the efficiency of the query will depend on the database's indexing strategy.\n\n#### 6. Potential Issues or Risks\n- If the `input.AgencyChangeDetail` table lacks appropriate indexes on the columns used in the `WHERE` clause, the procedure may perform poorly, especially with large datasets.\n- The procedure does not handle any exceptions or errors that might occur during execution, such as database connectivity issues or data type mismatches.\n- The procedure assumes that the combination of input parameters is sufficient to determine uniqueness. If additional columns are needed for uniqueness, the procedure will need to be modified.\n- The procedure does not validate the input parameters, which could lead to unexpected results if invalid or null values are provided.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 999,
      "api_response_id": "chatcmpl-C8VXqHahfEJSaXD5MZBvw7KOuzeCJ"
    },
    "analysis_timestamp": "2025-08-25 13:45:28"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangeClone",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangeClone]\r\n\t@fy\t\t\t\t\tINT\r\n\t, @name\t\t\t\tVARCHAR(250)\r\n\t, @description\t\tVARCHAR(500)\r\n\t, @actionBy\t\t\tVARCHAR(25) = 'SYSTEM'\r\n\t, @id\t\t\t\tINT OUTPUT\r\n\t, @originalId\t\tINT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\tDECLARE @DId INT\r\n\tDECLARE @DEMChangeDetailEntityIdMaxPlusOne   INT\r\n\r\n\tINSERT INTO input.DEMChange (FY, Name, [Description], CreatedBy, ModifiedBy)\r\n\t\t\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\t\tVALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\n\r\n\tSELECT DISTINCT DEMChangeDetailEntityId\r\n\tINTO #TEMP_Detail_ID\r\n\tFROM [input].[DEMChangeDetail]\r\n    WHERE DEMChangeID = @originalId\r\n\r\n    SELECT DISTINCT [AgencyCode],\r\n        [BudgetGroupID],\r\n        DEMChangeDetailEntityId\r\n    INTO #TEMP_Obsolete\r\n    FROM [input].[DEMChangeDetail]\r\n    WHERE DEMChangeDetailEntityId IN (SELECT DEMChangeDetailEntityId FROM #TEMP_Detail_ID)\r\n        AND (AgencyCode NOT IN (SELECT a.AgencyCodeOEC\r\n            FROM Preload.Agency AS a\r\n                INNER JOIN Preload.AgencyByFY AS abf ON a.AgencyId = abf.AgencyId\r\n            WHERE abf.FY = @fy)\r\n            OR BudgetGroupID NOT IN (SELECT BudgetGroupID FROM Preload.BudgetGroupByFY WHERE FY = @fy));\r\n\r\n    DELETE #TEMP_Detail_ID\r\n    WHERE DEMChangeDetailEntityId IN (SELECT DEMChangeDetailEntityId FROM #TEMP_Obsolete);\r\n\r\n\tWHILE (SELECT COUNT(*) FROM #TEMP_Detail_ID) > 0\r\n\tBEGIN\r\n\tSELECT TOP 1 @DId = DEMChangeDetailEntityId FROM #TEMP_Detail_ID\r\n    SELECT @DEMChangeDetailEntityIdMaxPlusOne = MAX(DEMChangeDetailEntityId) + 1  FROM input.DEMChangeDetail\r\n\t   \r\n\tINSERT INTO [input].[DEMChangeDetail]\r\n        ([DEMChangeID]\r\n        ,[AgencyCode]\r\n        ,[BudgetGroupID]\r\n        ,[BillingPeriod]\r\n        ,[DistinctAccountCount]\r\n        ,[DemandUsage]\r\n        ,[EnergyUsage]\r\n        ,[EnergyUsagePeakPercentage]\r\n        ,[EnergyUsageReactivePower]\r\n        ,[StreetLightingFacilityPoints]\r\n        ,[DEMChangeDetailEntityId]\r\n\t\t,[Notes])\r\n     SELECT @id\r\n        ,AgencyCode\r\n        ,BudgetGroupID\r\n        , CASE\r\n            WHEN 6 < BillingPeriod % 100 THEN\r\n        (@fy - 1) * 100 + BillingPeriod % 100\r\n            ELSE\r\n                @fy * 100 + BillingPeriod % 100\r\n        END AS BillingPeriod\r\n        ,DistinctAccountCount\r\n        ,DemandUsage\r\n        ,EnergyUsage\r\n        ,EnergyUsagePeakPercentage\r\n        ,EnergyUsageReactivePower\r\n        ,StreetLightingFacilityPoints\r\n        ,@DEMChangeDetailEntityIdMaxPlusOne\r\n\t\t,Notes\r\n    FROM input.DEMChangeDetail\r\n\tWHERE  DEMChangeDetailEntityId = @DId\r\n\r\n\tDELETE #TEMP_Detail_ID WHERE DEMChangeDetailEntityId = @DId\r\n\tEND\r\n\r\n\tSELECT [AgencyCode],\r\n        [BudgetGroupID]\r\n    FROM #TEMP_Obsolete;\r\n\t\r\n\tDROP TABLE IF EXISTS #TEMP_Obsolete, #TEMP_Detail_ID;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.830000",
      "last_altered": "2025-08-25 15:54:05.830000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@originalId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangeClone",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangeClone` is designed to clone a record from the `DEMChange` table and its associated details from the `DEMChangeDetail` table in the `input` schema. It creates a new entry in the `DEMChange` table with the provided fiscal year, name, and description, and then duplicates related records from the `DEMChangeDetail` table, adjusting certain fields based on the fiscal year. The procedure also filters out obsolete records based on agency and budget group criteria before cloning.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including inserting records, filtering data, handling temporary tables, and iterating over records to clone details. The complexity arises from the need to manage temporary tables, perform conditional logic, and ensure data integrity during the cloning process.\n\n#### 3. Input Parameters\n- `@fy INT`: The fiscal year for the new `DEMChange` record.\n- `@name VARCHAR(250)`: The name for the new `DEMChange` record.\n- `@description VARCHAR(500)`: The description for the new `DEMChange` record.\n- `@actionBy VARCHAR(25) = 'SYSTEM'`: The user or system identifier performing the action, defaulting to 'SYSTEM'.\n- `@id INT OUTPUT`: An output parameter to capture the ID of the newly created `DEMChange` record.\n- `@originalId INT`: The ID of the original `DEMChange` record to be cloned.\n\n#### 4. Business Logic and Workflow\n1. **Insert New DEMChange Record**: A new record is inserted into the `DEMChange` table with the provided fiscal year, name, description, and actionBy. The ID of this new record is captured using the `OUTPUT` clause.\n\n2. **Identify Related DEMChangeDetail Records**: The procedure selects distinct `DEMChangeDetailEntityId` values from the `DEMChangeDetail` table where the `DEMChangeID` matches the `@originalId`. These IDs are stored in a temporary table `#TEMP_Detail_ID`.\n\n3. **Filter Obsolete Records**: It identifies obsolete records by checking if the `AgencyCode` and `BudgetGroupID` are not valid for the given fiscal year. These obsolete records are stored in another temporary table `#TEMP_Obsolete`.\n\n4. **Remove Obsolete Records**: The procedure deletes obsolete records from `#TEMP_Detail_ID`.\n\n5. **Clone DEMChangeDetail Records**: It iterates over the remaining `DEMChangeDetailEntityId` values in `#TEMP_Detail_ID`, cloning each record into the `DEMChangeDetail` table with adjustments to the `BillingPeriod` and a new `DEMChangeDetailEntityId`.\n\n6. **Return Obsolete Records**: Finally, it selects and returns the `AgencyCode` and `BudgetGroupID` of the obsolete records.\n\n7. **Cleanup**: Temporary tables `#TEMP_Obsolete` and `#TEMP_Detail_ID` are dropped if they exist.\n\n#### 5. Performance Considerations\n- **Temporary Tables**: The use of temporary tables can impact performance, especially if the tables grow large. Indexing these tables could improve performance but is not implemented here.\n- **Iterative Cloning**: The procedure uses a loop to clone records, which can be inefficient for large datasets. A set-based approach might be more performant.\n- **Concurrency**: The procedure does not use explicit transaction management, which could lead to concurrency issues if multiple instances run simultaneously.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Without explicit transaction handling, partial updates could occur if an error interrupts the procedure.\n- **Scalability**: The iterative approach to cloning details may not scale well with large numbers of records.\n- **Obsolete Record Handling**: The logic for identifying obsolete records relies on external tables (`Preload.Agency` and `Preload.BudgetGroupByFY`), which could lead to issues if these tables are not maintained correctly.\n- **Hardcoded Logic**: The logic for adjusting `BillingPeriod` is hardcoded and may not accommodate future changes in business rules without modification.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1812,
      "api_response_id": "chatcmpl-C8VY1IU1KslPwhtCjOLq8Dvv0rEWz"
    },
    "analysis_timestamp": "2025-08-25 13:45:46"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangeCreate",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangeCreate]\r\n\t@fy\t\t\t\t\tINT\r\n\t, @name\t\t\t\tVARCHAR(250)\r\n\t, @description\t\tVARCHAR(500)\r\n\t, @actionBy\t\t\tVARCHAR(25) = 'SYSTEM'\r\n\t, @id\t\t\t\tINT OUTPUT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO input.DEMChange (FY, Name, [Description], CreatedBy, ModifiedBy)\r\n\t\t\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\t\tVALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.837000",
      "last_altered": "2025-08-25 15:54:05.837000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangeCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangeCreate` is designed to insert a new record into the `DEMChange` table within the `input` schema. It captures details about a change, including the fiscal year, name, description, and the user who performed the action. After inserting the record, it outputs the newly generated ID of the inserted record.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single insert operation with an output clause to capture the inserted record's ID. It does not include complex logic, conditional statements, or loops.\n\n#### 3. Input Parameters\n- `@fy INT`: Represents the fiscal year associated with the change. It is an integer value.\n- `@name VARCHAR(250)`: The name of the change, with a maximum length of 250 characters.\n- `@description VARCHAR(500)`: A description of the change, with a maximum length of 500 characters.\n- `@actionBy VARCHAR(25) = 'SYSTEM'`: The user who performed the action. It defaults to 'SYSTEM' if not provided, with a maximum length of 25 characters.\n- `@id INT OUTPUT`: An output parameter that returns the ID of the newly inserted record.\n\n#### 4. Business Logic and Workflow\n1. The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n2. It declares a table variable `@IdOutput` to temporarily store the ID of the newly inserted record.\n3. An `INSERT` statement is executed to add a new record to the `DEMChange` table. The `OUTPUT` clause captures the `ID` of the inserted record into the `@IdOutput` table variable.\n4. The procedure then selects the ID from `@IdOutput` and assigns it to the output parameter `@id`, making it available to the caller.\n\n#### 5. Performance Considerations\n- The use of `SET NOCOUNT ON` is a good practice to reduce unnecessary network traffic by suppressing the message indicating the number of rows affected by the `INSERT` statement.\n- The procedure is efficient for its purpose, as it performs a single insert operation and uses a table variable to capture the output, which is suitable for handling a small number of rows.\n\n#### 6. Potential Issues or Risks\n- The procedure does not include any error handling. If the `INSERT` operation fails (e.g., due to a constraint violation), the procedure will terminate without providing a meaningful error message to the caller.\n- The default value for `@actionBy` is 'SYSTEM', which may not always be appropriate. If the procedure is called without specifying this parameter, it could lead to inaccurate audit trails.\n- The procedure assumes that the `DEMChange` table has an `ID` column that is auto-incremented or otherwise generated upon insertion. If this assumption is incorrect, the procedure will fail.\n- There is no validation of input parameters, which could lead to issues if invalid data is passed (e.g., fiscal year as a negative number or excessively long strings).",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 999,
      "api_response_id": "chatcmpl-C8VYJCtnh5SHkbcstSqicsbhHzWqL"
    },
    "analysis_timestamp": "2025-08-25 13:46:06"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangeDelete",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangeDelete]\r\n(\r\n\t@id AS INT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDELETE FROM input.DEMChangeDetail WHERE DEMChangeID = @id;\r\n\tDELETE FROM input.DEMChange WHERE ID = @id;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.840000",
      "last_altered": "2025-08-25 15:54:05.840000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangeDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangeDelete` is designed to delete records from two tables within the `input` schema: `DEMChangeDetail` and `DEMChange`. It takes an identifier as input and removes the corresponding entries from these tables. The procedure ensures that any details associated with a specific change are deleted before the change itself is removed.\n\n#### 2. Complexity Level: Low\nThe complexity level of this stored procedure is low. It performs straightforward delete operations on two tables based on a single input parameter. There are no complex joins, conditional logic, or transactions involved.\n\n#### 3. Input Parameters\n- `@id AS INT`: This parameter represents the unique identifier for the records to be deleted. It is used to match and delete entries in both the `DEMChangeDetail` and `DEMChange` tables.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter defaults to 'SYSTEM' and is intended to record or track the user or system component initiating the delete operation. However, in the current implementation, it is not utilized within the procedure.\n\n#### 4. Business Logic and Workflow\n1. **Set NOCOUNT ON**: This command is used to prevent the SQL Server from sending messages indicating the number of rows affected by the SQL statements. This can reduce network traffic and improve performance slightly.\n2. **Delete from `DEMChangeDetail`**: The procedure first deletes records from the `DEMChangeDetail` table where the `DEMChangeID` matches the provided `@id`. This ensures that all related detail records are removed before the main record is deleted.\n3. **Delete from `DEMChange`**: After removing the detail records, the procedure deletes the main record from the `DEMChange` table where the `ID` matches the provided `@id`.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `DEMChangeID` column in the `DEMChangeDetail` table and the `ID` column in the `DEMChange` table are indexed. This will improve the performance of the delete operations by allowing faster lookups.\n- **Batch Deletion**: If the tables contain a large number of records, consider implementing batch deletions to avoid locking issues and reduce transaction log growth.\n- **NOCOUNT**: The use of `SET NOCOUNT ON` helps reduce unnecessary network traffic by suppressing the \"rows affected\" message.\n\n#### 6. Potential Issues or Risks\n- **Foreign Key Constraints**: If there are foreign key constraints between `DEMChangeDetail` and `DEMChange`, ensure that the order of deletion respects these constraints to avoid errors.\n- **Data Integrity**: Deleting records without proper validation or logging can lead to data integrity issues. Consider implementing logging or archiving mechanisms to track deletions.\n- **Unused Parameter**: The `@actionBy` parameter is not used within the procedure. If tracking the initiator of the delete operation is necessary, consider implementing logging or auditing to utilize this parameter effectively.\n- **Error Handling**: The procedure lacks error handling. Consider adding TRY...CATCH blocks to handle potential errors gracefully and ensure that the application using this procedure can respond appropriately to failures.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 949,
      "api_response_id": "chatcmpl-C8VYdHxGrYDtSa70ogngGdF7Fklg0"
    },
    "analysis_timestamp": "2025-08-25 13:46:24"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangeDetailsCreate",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangeDetailsCreate]\r\n(\r\n\t@details AS input.UDT_DEMChangeDetail READONLY\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @DEMChangeDetailEntityID INT\r\n\tDECLARE @DEMChangeID INT  \r\n\tDECLARE @AgencyCode VARCHAR(6) \r\n\tDECLARE @DistinctAccountCount INT = 0\r\n\tDECLARE @BudgetGroupID INT \r\n\tDECLARE @BillingPeriod INT\r\n\tDECLARE @DemandUsage DECIMAL(18, 5) = 0\r\n\tDECLARE @EnergyUsage DECIMAL(18, 5) = 0\r\n\tDECLARE @EnergyUsagePeakPercentage [decimal](10, 5) = 0\r\n\tDECLARE @EnergyUsageReactivePower DECIMAL(18, 5) = 0\r\n\tDECLARE @StreetLightingFacilityPoints DECIMAL(18, 5) = 0\r\n\tDECLARE @Notes VARCHAR(200)\r\n\r\n\tSELECT @DEMChangeDetailEntityID = Max(DEMChangeDetailEntityID) + 1\r\n\tFROM   input.DEMChangeDetail\r\n\r\n\tDECLARE @detailCursor CURSOR; \r\n\tSET @detailCursor =  CURSOR FOR\r\n\tSELECT  DEMChangeID,\r\n\t\tAgencyCode,\r\n\t\tDistinctAccountCount,\r\n\t\tBudgetGroupID,\r\n\t\tBillingPeriod,\r\n\t\tDemandUsage,\r\n\t\tEnergyUsage,\r\n\t\tEnergyUsagePeakPercentage,\r\n\t\tEnergyUsageReactivePower,\r\n\t\tStreetLightingFacilityPoints,\r\n\t\tNotes\r\n\t FROM @details\r\n\r\n\t OPEN @detailCursor; \r\n\t FETCH next \r\n\t FROM  @detailCursor\r\n\t INTO @DEMChangeID,\r\n\t\t  @AgencyCode,\r\n\t\t  @DistinctAccountCount,\r\n\t\t  @BudgetGroupID,\r\n\t\t  @BillingPeriod,\r\n\t\t  @DemandUsage,\r\n\t\t  @EnergyUsage,\r\n\t\t  @EnergyUsagePeakPercentage,\r\n\t\t  @EnergyUsageReactivePower,\r\n\t\t  @StreetLightingFacilityPoints,\r\n\t\t  @Notes\r\n\r\n\tWHILE @@FETCH_STATUS = 0\r\n\tBEGIN\r\n\t\tINSERT INTO [input].[DEMChangeDetail]\r\n\t\t   ([DEMChangeID]\r\n\t\t   ,[AgencyCode]\r\n\t\t   ,[BudgetGroupID]\r\n\t\t   ,[BillingPeriod]\r\n\t\t   ,[DistinctAccountCount]\r\n\t\t   ,[DemandUsage]\r\n\t\t   ,[EnergyUsage]\r\n\t\t   ,[EnergyUsagePeakPercentage]\r\n\t\t   ,[EnergyUsageReactivePower]\r\n\t\t   ,[StreetLightingFacilityPoints]\r\n\t\t   ,[DEMChangeDetailEntityID]\r\n\t\t   ,[Notes])\r\n\t\tVALUES\r\n\t\t   (@DEMChangeID,\r\n\t\t\t@AgencyCode,\r\n\t\t\t@BudgetGroupID,\r\n\t\t\t@BillingPeriod,\r\n\t\t\t@DistinctAccountCount,\r\n\t\t\t@DemandUsage,\r\n\t\t\t@EnergyUsage,\r\n\t\t\t@EnergyUsagePeakPercentage,\r\n\t\t\t@EnergyUsageReactivePower,\r\n\t\t\t@StreetLightingFacilityPoints,\r\n\t\t\t@DEMChangeDetailEntityID,\r\n\t\t\t@Notes)\r\n\r\n\t\t FETCH NEXT \r\n\t\t FROM  @detailCursor\r\n\t\t INTO @DEMChangeID,\r\n\t\t\t  @AgencyCode,\r\n\t\t\t  @DistinctAccountCount,\r\n\t\t\t  @BudgetGroupID,\r\n\t\t\t  @BillingPeriod,\r\n\t\t\t  @DemandUsage,\r\n\t\t\t  @EnergyUsage,\r\n\t\t\t  @EnergyUsagePeakPercentage,\r\n\t\t\t  @EnergyUsageReactivePower,\r\n\t\t\t  @StreetLightingFacilityPoints,\r\n\t\t\t  @Notes\t  \r\n\tEND;\r\n\r\n\tCLOSE @detailCursor;\r\n\tDEALLOCATE @detailCursor;\r\n\r\n\tUPDATE input.DEMChange\r\n\tSET ModifiedDate=GETDATE(), ModifiedBy=@actionBy\r\n\tWHERE id=@DEMChangeID;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE DEMChangeID=@DEMChangeID AND [Status] IN ('CALCULATED');\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.843000",
      "last_altered": "2025-08-25 15:54:05.843000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@details",
        "data_type": "UDT_DEMChangeDetail",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangeDetailsCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangeDetailsCreate` is designed to insert records into the `input.DEMChangeDetail` table from a user-defined table type parameter `@details`. It processes each row of the input table, assigns a new `DEMChangeDetailEntityID`, and updates related records in the `input.DEMChange` and `budget.Scenario` tables. The procedure is used to manage and update demand change details, likely in an energy management or billing system.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including cursor operations, data insertion, and updates to related tables. The use of a cursor adds complexity, as it requires careful management of resources and can impact performance. The logic is straightforward but involves multiple database operations, which elevates its complexity.\n\n#### 3. Input Parameters\n- `@details AS input.UDT_DEMChangeDetail READONLY`: A table-valued parameter that contains the details to be inserted into the `DEMChangeDetail` table. This parameter is read-only and is expected to be a structured collection of data.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: An optional parameter that defaults to 'SYSTEM'. It records who performed the action, used in the update of the `input.DEMChange` table to track modifications.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure starts by declaring several local variables to store data from the input table and to manage the cursor.\n2. **Determine New Entity ID**: It calculates the next `DEMChangeDetailEntityID` by finding the maximum existing ID in the `DEMChangeDetail` table and adding one.\n3. **Cursor Setup and Iteration**: A cursor is declared and opened to iterate over each row in the `@details` table. For each row:\n   - The data is fetched into local variables.\n   - An `INSERT` operation is performed to add the row into the `DEMChangeDetail` table with the new `DEMChangeDetailEntityID`.\n4. **Cursor Cleanup**: After processing all rows, the cursor is closed and deallocated.\n5. **Update Operations**: \n   - The `input.DEMChange` table is updated to set the `ModifiedDate` and `ModifiedBy` fields for the relevant `DEMChangeID`.\n   - The `budget.Scenario` table is updated to change the status to 'REQUIRERECALC' for scenarios associated with the `DEMChangeID` that are currently 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **Cursor Usage**: The use of a cursor can lead to performance bottlenecks, especially with large datasets, as it processes rows one at a time. Consider using set-based operations if possible.\n- **Entity ID Calculation**: The calculation of `DEMChangeDetailEntityID` using `Max` can be a point of contention in a highly concurrent environment, potentially leading to race conditions or performance issues.\n- **Table Updates**: The updates to `input.DEMChange` and `budget.Scenario` are straightforward but should be monitored for locking and blocking issues, especially if these tables are large or frequently accessed.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: The method of calculating the next `DEMChangeDetailEntityID` is susceptible to race conditions in a concurrent environment, potentially leading to duplicate IDs.\n- **Cursor Overhead**: Cursors can be resource-intensive and may degrade performance if the input dataset is large. Consider refactoring to use set-based operations.\n- **Error Handling**: The procedure lacks explicit error handling, which means any runtime errors could leave the database in an inconsistent state. Implementing try-catch blocks and transaction management could mitigate this risk.\n- **Scalability**: As the volume of data grows, the performance of this procedure may degrade due to the cursor and the sequential processing of rows.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1756,
      "api_response_id": "chatcmpl-C8VYvbaOXcQyDOAvGdfauMchHV8uC"
    },
    "analysis_timestamp": "2025-08-25 13:46:39"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangeDetailsDelete",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangeDetailsDelete]\r\n(\r\n    @demChangeDetailEntityID AS INT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\t\r\n\tDECLARE @DEMChangeID INT;\r\n\r\n\tSELECT @DEMChangeID = MAX(DEMChangeID)\r\n\tFROM input.DEMChangeDetail\r\n\tWHERE demChangeDetailEntityID = @demChangeDetailEntityID;\r\n\r\n\r\n\tDELETE FROM input.DEMChangeDetail\r\n\tWHERE demChangeDetailEntityID = @demChangeDetailEntityID\r\n\r\n\tUPDATE input.DEMChange\r\n\tSET ModifiedDate=GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @DEMChangeID;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE DEMChangeID=@DEMChangeID AND [Status] IN ('CALCULATED');\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.850000",
      "last_altered": "2025-08-25 15:54:05.850000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@demChangeDetailEntityID",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangeDetailsDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangeDetailsDelete` is designed to delete records from the `input.DEMChangeDetail` table based on a specified `demChangeDetailEntityID`. After deleting the records, it updates the `ModifiedDate` and `ModifiedBy` fields in the `input.DEMChange` table for the associated `DEMChangeID`. Additionally, it updates the `Status` field in the `budget.Scenario` table to 'REQUIRERECALC' for records with the same `DEMChangeID` that currently have a status of 'CALCULATED'.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple operations: selecting a maximum value, deleting records, and updating records across different tables. While the logic is straightforward, the interactions between tables and the conditional updates add a moderate level of complexity.\n\n#### 3. Input Parameters\n- `@demChangeDetailEntityID AS INT`: This parameter specifies the identifier for the records in the `input.DEMChangeDetail` table that need to be deleted.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter specifies the user or system responsible for the action. It defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n1. **Select Operation**: The procedure begins by selecting the maximum `DEMChangeID` from the `input.DEMChangeDetail` table where the `demChangeDetailEntityID` matches the input parameter. This is stored in the local variable `@DEMChangeID`.\n   \n2. **Delete Operation**: It deletes all records from the `input.DEMChangeDetail` table that match the specified `demChangeDetailEntityID`.\n\n3. **Update Operation on DEMChange**: The procedure updates the `ModifiedDate` to the current date and time and sets the `ModifiedBy` field to the value of `@actionBy` for the record in the `input.DEMChange` table that matches the `@DEMChangeID`.\n\n4. **Update Operation on Scenario**: It updates the `Status` field to 'REQUIRERECALC' in the `budget.Scenario` table for records with the same `DEMChangeID` and a current status of 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that `demChangeDetailEntityID` and `DEMChangeID` are indexed in their respective tables to optimize the SELECT, DELETE, and UPDATE operations.\n- **Concurrency**: The procedure may face concurrency issues if multiple processes attempt to delete or update the same records simultaneously. Consider implementing locking mechanisms if necessary.\n- **Batch Processing**: If the `input.DEMChangeDetail` table contains a large number of records for a single `demChangeDetailEntityID`, the DELETE operation could be resource-intensive. Consider batch processing for large datasets.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: If the `SELECT` operation does not find a matching `DEMChangeID`, subsequent updates will not occur, potentially leaving related records in an inconsistent state.\n- **Cascade Effects**: Deleting records from `input.DEMChangeDetail` without proper foreign key constraints or cascading deletes could lead to orphaned records in related tables.\n- **Error Handling**: The procedure lacks error handling mechanisms. Consider adding TRY...CATCH blocks to manage exceptions and ensure that the procedure fails gracefully.\n- **Default Value for `@actionBy`**: The default value of 'SYSTEM' for `@actionBy` may not always be appropriate. Ensure that the calling application or user provides a meaningful value when necessary.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1146,
      "api_response_id": "chatcmpl-C8VZAZxtnyLaljsteoxGcV45YLgM0"
    },
    "analysis_timestamp": "2025-08-25 13:46:54"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangeDetailsRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangeDetailsRetrieve]\r\n(\r\n\t@demChangeId AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT DEMChangeDetailEntityID\r\n\t\t,DEMChangeID\r\n\t\t,AgencyCode\r\n\t\t,BudgetGroupID\r\n\t\t,DistinctAccountCount\r\n\t\t,Notes\r\n\tFROM input.vwDEMChangeDetailsDistinct\r\n\tWHERE DEMChangeID = ISNULL(@demChangeId, DEMChangeID)\r\n\tORDER BY DEMChangeID ASC, AgencyCode ASC, BudgetGroupID ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.853000",
      "last_altered": "2025-08-25 15:54:05.853000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@demChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangeDetailsRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangeDetailsRetrieve` is designed to retrieve details from a view named `vwDEMChangeDetailsDistinct` within the `input` schema. It fetches records related to DEM (presumably \"Demographic\" or \"Demonstration\") changes, filtered by an optional `@demChangeId` parameter. The results are ordered by `DEMChangeID`, `AgencyCode`, and `BudgetGroupID`.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SELECT query with an optional filter and ordering. It does not include complex logic, multiple operations, or conditional branching.\n\n#### 3. Input Parameters\n- `@demChangeId AS INT = NULL`: This is an optional parameter. If provided, it filters the results to only include records with a matching `DEMChangeID`. If not provided, all records are returned.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read uncommitted changes from other transactions, which can lead to dirty reads but improves performance by reducing locking overhead.\n- The SELECT statement retrieves columns such as `DEMChangeDetailEntityID`, `DEMChangeID`, `AgencyCode`, `BudgetGroupID`, `DistinctAccountCount`, and `Notes` from the view `vwDEMChangeDetailsDistinct`.\n- The WHERE clause uses `ISNULL(@demChangeId, DEMChangeID)` to apply the filter only if `@demChangeId` is provided; otherwise, it retrieves all records.\n- The results are ordered by `DEMChangeID`, `AgencyCode`, and `BudgetGroupID` in ascending order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking and blocking, but it risks reading uncommitted data, which may not be suitable for all applications.\n- The procedure's performance largely depends on the underlying view `vwDEMChangeDetailsDistinct`. If the view is complex or involves large datasets, it could impact performance.\n- Indexes on `DEMChangeID`, `AgencyCode`, and `BudgetGroupID` would enhance the performance of the ORDER BY clause and filtering.\n\n#### 6. Potential Issues or Risks\n- The use of `READ UNCOMMITTED` can lead to dirty reads, where data read by the procedure might not be committed and could be rolled back, leading to inconsistencies.\n- If `@demChangeId` is not provided, the procedure retrieves all records, which could lead to performance issues if the dataset is large.\n- The procedure assumes that the view `vwDEMChangeDetailsDistinct` is always available and correctly configured. Any changes to the view's structure or availability could cause the procedure to fail or return incorrect results.\n- The procedure does not handle exceptions or errors, which could lead to unhandled exceptions if issues arise during execution.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 970,
      "api_response_id": "chatcmpl-C8VZPFg0XTfTHDWujBUzI1KYV8qH4"
    },
    "analysis_timestamp": "2025-08-25 13:47:10"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangeDetailsRetrieveBillingPeriodDetails",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangeDetailsRetrieveBillingPeriodDetails]\r\n(\r\n    @demChangeDetailEntityId AS INT = -1,\r\n\t@demChangeId AS INT = -1\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tIF @demChangeDetailEntityId > -1\r\n\tBEGIN\r\n\t\tSELECT [DEMChangeID]\r\n\t\t\t,[DEMChangeDetailEntityID]\r\n\t\t\t,[AgencyCode]\r\n\t\t\t,[BudgetGroupID]\r\n\t\t\t,[DistinctAccountCount]\r\n\t\t\t,[BillingPeriod]\r\n\t\t\t,[DemandUsage]\r\n\t\t\t,[EnergyUsage]\r\n\t\t\t,[EnergyUsagePeakPercentage]\r\n\t\t\t,[EnergyUsagePeak]\r\n\t\t\t,[EnergyUsageOffPeak]\r\n\t\t\t,[EnergyUsageReactivePower]\r\n\t\t\t,[StreetLightingFacilityPoints]\r\n\t\t\t,[Notes]\r\n\t\tFROM [input].[vwDEMChangeDetails]\r\n\t\tWHERE DEMChangeDetailEntityID = @demChangeDetailEntityId\r\n\t\tORDER BY DEMChangeID ASC, AgencyCode ASC, BudgetGroupID ASC, BillingPeriod ASC;\r\n\tEND\r\n\tELSE IF @demChangeId > -1\r\n\tBEGIN\r\n\t\tSELECT [DEMChangeID]\r\n\t\t\t,[DEMChangeDetailEntityID]\r\n\t\t\t,[AgencyCode]\r\n\t\t\t,[BudgetGroupID]\r\n\t\t\t,[DistinctAccountCount]\r\n\t\t\t,[BillingPeriod]\r\n\t\t\t,[DemandUsage]\r\n\t\t\t,[EnergyUsage]\r\n\t\t\t,[EnergyUsagePeakPercentage]\r\n\t\t\t,[EnergyUsagePeak]\r\n\t\t\t,[EnergyUsageOffPeak]\r\n\t\t\t,[EnergyUsageReactivePower]\r\n\t\t\t,[StreetLightingFacilityPoints]\r\n\t\t\t,[Notes]\r\n\t\tFROM [input].[vwDEMChangeDetails]\r\n\t\tWHERE DEMChangeID = @demChangeId\r\n\t\tORDER BY DEMChangeDetailEntityID ASC, AgencyCode ASC, BudgetGroupID ASC, BillingPeriod ASC;\r\n\tEND\r\n\tELSE\r\n\tBEGIN\r\n\t\tSELECT [DEMChangeID]\r\n\t\t\t,[DEMChangeDetailEntityID]\r\n\t\t\t,[AgencyCode]\r\n\t\t\t,[BudgetGroupID]\r\n\t\t\t,[DistinctAccountCount]\r\n\t\t\t,[BillingPeriod]\r\n\t\t\t,[DemandUsage]\r\n\t\t\t,[EnergyUsage]\r\n\t\t\t,[EnergyUsagePeakPercentage]\r\n\t\t\t,[EnergyUsagePeak]\r\n\t\t\t,[EnergyUsageOffPeak]\r\n\t\t\t,[EnergyUsageReactivePower]\r\n\t\t\t,[StreetLightingFacilityPoints]\r\n\t\t\t,[Notes]\r\n\t\tFROM [input].[vwDEMChangeDetails]\r\n\t\tORDER BY DEMChangeID ASC, DEMChangeDetailEntityID ASC, AgencyCode ASC, BudgetGroupID ASC, BillingPeriod ASC;\r\n\tEND;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.857000",
      "last_altered": "2025-08-25 15:54:05.857000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@demChangeDetailEntityId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@demChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangeDetailsRetrieveBillingPeriodDetails",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangeDetailsRetrieveBillingPeriodDetails` is designed to retrieve billing period details from a view named `vwDEMChangeDetails` within the `input` schema. It allows filtering based on either `DEMChangeDetailEntityID` or `DEMChangeID`, or retrieves all records if neither parameter is specified with a valid ID. The results are ordered by specific columns to ensure consistent output.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving simple conditional logic to determine which records to retrieve based on the input parameters. It performs basic SELECT operations with ORDER BY clauses, without any complex joins, subqueries, or data transformations.\n\n#### 3. Input Parameters\n- `@demChangeDetailEntityId AS INT = -1`: This parameter is used to filter the results by `DEMChangeDetailEntityID`. A default value of `-1` indicates that this filter should not be applied unless a valid ID is provided.\n- `@demChangeId AS INT = -1`: This parameter is used to filter the results by `DEMChangeID`. Similarly, a default value of `-1` indicates that this filter should not be applied unless a valid ID is provided.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing dirty reads and potentially improving performance by not acquiring shared locks.\n- The procedure checks the input parameters:\n  - If `@demChangeDetailEntityId` is greater than `-1`, it retrieves records where `DEMChangeDetailEntityID` matches the provided ID.\n  - If `@demChangeDetailEntityId` is not specified (i.e., `-1`), but `@demChangeId` is greater than `-1`, it retrieves records where `DEMChangeID` matches the provided ID.\n  - If neither parameter is specified with a valid ID, it retrieves all records from the view.\n- The results are ordered by specified columns to ensure a consistent and logical output.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead, but it may lead to reading uncommitted or dirty data.\n- The procedure performs a simple SELECT operation, which is generally efficient, but performance can be impacted by the size of the `vwDEMChangeDetails` view and the presence of indexes on the columns used in the WHERE clause and ORDER BY clause.\n- The ORDER BY clause can be costly if the dataset is large and the columns are not indexed appropriately.\n\n#### 6. Potential Issues or Risks\n- Using `READ UNCOMMITTED` can lead to reading inconsistent data, which might not be suitable for all business scenarios, especially where data accuracy is critical.\n- If the view `vwDEMChangeDetails` is complex or involves multiple joins, the performance might degrade, especially if the underlying tables are large.\n- The procedure does not handle cases where both parameters are provided with valid IDs, which might lead to unexpected results if the calling application does not ensure proper parameter usage.\n- The default values of `-1` for the parameters assume that valid IDs are always positive integers, which should be validated in the application logic to prevent misuse.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1446,
      "api_response_id": "chatcmpl-C8VZfB43ngm9qPMMtsq1WxXAabU8A"
    },
    "analysis_timestamp": "2025-08-25 13:47:26"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangeDetailsSave",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangeDetailsSave]\r\n(\r\n\t@details AS input.UDT_DEMChangeDetail READONLY\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @DEMChangeDetailEntityIDMaxPlusOne AS INT, @DEMChangeID AS INT, @DEMChangeDetailEntityID AS INT, @AgencyCode AS VARCHAR(6)\r\n\t\t,@DistinctAccountCount AS INT = 0, @BudgetGroupID AS INT, @BillingPeriod AS INT, @DemandUsage AS DECIMAL(18, 5) = 0.0\r\n\t\t,@EnergyUsage AS DECIMAL(18, 5) = 0.0, @EnergyUsagePeakPercentage AS DECIMAL(10, 5) = 1.0, @EnergyUsageReactivePower AS DECIMAL(18, 5) = 0.0\r\n\t\t,@StreetLightingFacilityPoints AS DECIMAL(18, 5) = 0.0, @Notes AS VARCHAR(200);\r\n\r\n\tSELECT @DEMChangeDetailEntityIDMaxPlusOne = Max(DEMChangeDetailEntityID) + 1 FROM input.DEMChangeDetail\r\n\r\n\tDECLARE @detailCursor CURSOR;    \r\n    SET @detailCursor =  CURSOR FOR \r\n\t\tSELECT DEMChangeID,\r\n\t\t\tDEMChangeDetailEntityID,\r\n\t\t\tAgencyCode,\r\n\t\t\tDistinctAccountCount,\r\n\t\t\tBudgetGroupID,\r\n\t\t\tBillingPeriod,\r\n\t\t\tDemandUsage,\r\n\t\t\tEnergyUsage,\r\n\t\t\tEnergyUsagePeakPercentage,\r\n\t\t\tEnergyUsageReactivePower,\r\n\t\t\tStreetLightingFacilityPoints,\r\n\t\t\tNotes\r\n\t\tFROM @details\r\n\t\tOPEN @detailCursor;\r\n\r\n\tFETCH NEXT FROM  @detailCursor INTO @DEMChangeID,\r\n\t\t@DEMChangeDetailEntityID,\r\n\t\t@AgencyCode,\r\n\t\t@DistinctAccountCount,\r\n\t\t@BudgetGroupID,\r\n\t\t@BillingPeriod,\r\n\t\t@DemandUsage, \r\n\t\t@EnergyUsage,\r\n\t\t@EnergyUsagePeakPercentage,\r\n\t\t@EnergyUsageReactivePower,\r\n\t\t@StreetLightingFacilityPoints,\r\n\t\t@Notes\r\n\tWHILE @@FETCH_STATUS = 0\r\n\tBEGIN\r\n\t\tIF @DEMChangeDetailEntityID > -1\r\n\t\tBEGIN\r\n\t\t\tUPDATE input.DEMChangeDetail\r\n\t\t\tSET AgencyCode = @AgencyCode,\r\n\t\t\t\tDistinctAccountCount = @DistinctAccountCount,\r\n\t\t\t\tBudgetGroupID = @BudgetGroupID, \r\n\t\t\t\tDemandUsage = @DemandUsage, \r\n\t\t\t\tEnergyUsage = @EnergyUsage,\r\n\t\t\t\tEnergyUsagePeakPercentage = @EnergyUsagePeakPercentage,\r\n\t\t\t\tEnergyUsageReactivePower = @EnergyUsageReactivePower, \r\n\t\t\t\tStreetLightingFacilityPoints = @StreetLightingFacilityPoints,\r\n\t\t\t\tNotes = @Notes\r\n\t\t\tWHERE input.DEMChangeDetail.DEMChangeDetailEntityID = @DEMChangeDetailEntityID\r\n\t\t\t\tAND BillingPeriod = @BillingPeriod;\r\n\t\tEND\r\n\t\tELSE\r\n\t\tBEGIN\r\n\t\t\tINSERT INTO [input].[DEMChangeDetail]\r\n\t\t\t\t([DEMChangeID]\r\n\t\t\t\t,[AgencyCode]\r\n\t\t\t\t,[BudgetGroupID]\r\n\t\t\t\t,[BillingPeriod]\r\n\t\t\t\t,[DistinctAccountCount]\r\n\t\t\t\t,[DemandUsage]\r\n\t\t\t\t,[EnergyUsage]\r\n\t\t\t\t,[EnergyUsagePeakPercentage]\r\n\t\t\t\t,[EnergyUsageReactivePower]\r\n\t\t\t\t,[StreetLightingFacilityPoints]\r\n\t\t\t\t,[DEMChangeDetailEntityID]\r\n\t\t\t\t,[Notes])\r\n\t\t\tVALUES (@DEMChangeID\r\n\t\t\t\t,@AgencyCode\r\n\t\t\t\t,@BudgetGroupID\r\n\t\t\t\t,@BillingPeriod\r\n\t\t\t\t,@DistinctAccountCount\r\n\t\t\t\t,@DemandUsage\r\n\t\t\t\t,@EnergyUsage\r\n\t\t\t\t,@EnergyUsagePeakPercentage\r\n\t\t\t\t,@EnergyUsageReactivePower\r\n\t\t\t\t,@StreetLightingFacilityPoints\r\n\t\t\t\t,@DEMChangeDetailEntityIDMaxPlusOne\r\n\t\t\t\t,@Notes);\r\n\t\tEND;\r\n\r\n\t\tFETCH NEXT FROM  @detailCursor INTO @DEMChangeID, \r\n\t\t\t@DEMChangeDetailEntityID, \r\n\t\t\t@AgencyCode,\r\n\t\t\t@DistinctAccountCount,\r\n\t\t\t@BudgetGroupID, \r\n\t\t\t@BillingPeriod, \r\n\t\t\t@DemandUsage, \r\n\t\t\t@EnergyUsage,\r\n\t\t\t@EnergyUsagePeakPercentage,\r\n\t\t\t@EnergyUsageReactivePower, \r\n\t\t\t@StreetLightingFacilityPoints,\r\n\t\t\t@Notes\r\n\tEND;\r\n\tCLOSE @detailCursor;\r\n\tDEALLOCATE @detailCursor;\r\n\r\n\tUPDATE input.DEMChange\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @DEMChangeID;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE DEMChangeID = @DEMChangeID AND [Status] IN ('CALCULATED');\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.863000",
      "last_altered": "2025-08-25 15:54:05.863000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@details",
        "data_type": "UDT_DEMChangeDetail",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangeDetailsSave",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangeDetailsSave` is designed to process and save details related to demand changes. It takes a table-valued parameter containing multiple records of demand change details and either updates existing records or inserts new ones into the `input.DEMChangeDetail` table. After processing the details, it updates the modification metadata in the `input.DEMChange` table and sets the status of related scenarios in the `budget.Scenario` table to 'REQUIRERECALC' if they are currently 'CALCULATED'.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple operations, including cursor-based iteration over a table-valued parameter, conditional logic for updates and inserts, and updates to related tables. The use of cursors and multiple table updates increases the complexity compared to simpler CRUD operations.\n\n#### 3. Input Parameters\n- `@details AS input.UDT_DEMChangeDetail READONLY`: A table-valued parameter that contains the demand change details to be processed. It is expected to be a user-defined table type with columns matching those in the `input.DEMChangeDetail` table.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: An optional parameter that specifies the user or system entity responsible for the changes. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance.\n2. **Determine Next Entity ID**: It calculates the next available `DEMChangeDetailEntityID` by finding the maximum current ID and adding one.\n3. **Cursor Setup**: A cursor is declared and opened to iterate over the records in the `@details` parameter.\n4. **Processing Each Record**:\n   - For each record, it checks if `DEMChangeDetailEntityID` is greater than -1.\n   - If true, it updates the existing record in `input.DEMChangeDetail` with matching `DEMChangeDetailEntityID` and `BillingPeriod`.\n   - If false, it inserts a new record into `input.DEMChangeDetail` using the calculated `DEMChangeDetailEntityIDMaxPlusOne`.\n5. **Cursor Cleanup**: The cursor is closed and deallocated after processing all records.\n6. **Update Metadata**: The `input.DEMChange` table is updated with the current date and the `@actionBy` value.\n7. **Update Scenario Status**: The `budget.Scenario` table is updated to set the status to 'REQUIRERECALC' for scenarios related to the processed `DEMChangeID` that are currently 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **Cursor Usage**: The use of a cursor can lead to performance issues, especially with large datasets, as it processes each row individually. Consider using set-based operations if possible.\n- **Concurrency**: The procedure does not include explicit transaction handling, which could lead to issues in a high-concurrency environment.\n- **Indexing**: Ensure that the `DEMChangeDetailEntityID` and `DEMChangeID` columns are indexed to optimize the update and insert operations.\n\n#### 6. Potential Issues or Risks\n- **Scalability**: The cursor-based approach may not scale well with large datasets, potentially leading to long execution times.\n- **Concurrency and Locking**: Without explicit transaction management, there is a risk of data inconsistency if multiple instances of the procedure run concurrently.\n- **Error Handling**: The procedure lacks error handling, which could lead to unhandled exceptions and partial updates in case of failures.\n- **Assumption of Unique Billing Period**: The update logic assumes that `BillingPeriod` is unique for each `DEMChangeDetailEntityID`, which may not hold true if the data model changes.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 2008,
      "api_response_id": "chatcmpl-C8VZvKlwLXSh2GmNbMWOR9nNFr40H"
    },
    "analysis_timestamp": "2025-08-25 13:47:38"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangesRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangesRetrieve]\r\n\t@fy AS INT = NULL\r\n\t,@id AS INT = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @used AS BIT = 0;\r\n\r\n\tIF @id IS NOT NULL\r\n\t   SELECT @used = CASE WHEN EXISTS (SELECT 1 FROM budget.Scenario s WHERE s.Status = 'CALCULATED' AND s.DEMChangeID = @id) THEN 1 ELSE 0 END \r\n\r\n\tSELECT ID\r\n\t\t,[Name]\r\n\t\t,[Description]\r\n\t\t,FY\r\n\t\t,CreatedBy\r\n\t\t,CreatedDate\r\n\t\t,ModifiedBy\r\n\t\t,ModifiedDate\r\n\t\t,Active\r\n\t\t,Locked\r\n\t\t,@used AS UsedByOtherCalculatedScenario \r\n\tFROM input.vwDEMChanges\r\n\tWHERE ID = ISNULL(@id, ID) AND FY = ISNULL(@fy, FY)\r\n\tORDER BY FY DESC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.867000",
      "last_altered": "2025-08-25 15:54:05.867000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangesRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangesRetrieve` is designed to retrieve records from a view named `input.vwDEMChanges` based on optional filtering criteria provided by fiscal year (`@fy`) and ID (`@id`). It also checks if a specific ID is used in any calculated scenarios within the `budget.Scenario` table and includes this information in the result set. The procedure is set to operate under the `READ UNCOMMITTED` transaction isolation level, which allows reading uncommitted changes from other transactions.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving basic SQL operations such as conditional logic, a simple SELECT query with optional filtering, and a subquery to determine the usage of a specific ID. The logic is easy to follow and does not involve complex joins or nested queries.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: An optional parameter representing the fiscal year. If provided, it filters the results to include only records matching this fiscal year.\n- `@id AS INT = NULL`: An optional parameter representing the ID of the record. If provided, it filters the results to include only records with this ID. It is also used to check if the ID is referenced in any calculated scenarios.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n2. **Transaction Isolation Level**: It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the procedure to read data that might not yet be committed by other transactions.\n3. **Usage Check**: If `@id` is provided, the procedure checks if this ID is used in any scenario with a status of 'CALCULATED' in the `budget.Scenario` table. The result is stored in the `@used` variable.\n4. **Data Retrieval**: The procedure retrieves records from `input.vwDEMChanges`, applying filters based on the provided `@fy` and `@id` parameters. It includes an additional column, `UsedByOtherCalculatedScenario`, indicating whether the ID is used in any calculated scenario.\n5. **Ordering**: The results are ordered by fiscal year in descending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: This isolation level can improve performance by reducing locking overhead but at the risk of reading uncommitted or \"dirty\" data.\n- **Indexing**: Performance can be enhanced if appropriate indexes exist on the `budget.Scenario` table for the `Status` and `DEMChangeID` columns, and on the `vwDEMChanges` view for the `ID` and `FY` columns.\n- **Conditional Logic**: The use of `ISNULL` in the WHERE clause allows for flexible filtering but may affect index usage and query performance.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to reading uncommitted data, which might not be suitable for all business scenarios, especially where data accuracy is critical.\n- **Concurrency**: While `READ UNCOMMITTED` reduces locking, it may lead to inconsistencies if other transactions are modifying the data concurrently.\n- **NULL Handling**: The use of `ISNULL` for filtering can lead to full table scans if indexes are not properly utilized, potentially impacting performance.\n- **Scalability**: As the data grows, the performance of the subquery checking for calculated scenarios might degrade if not properly indexed or optimized.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1163,
      "api_response_id": "chatcmpl-C8Va7RCnWw5kofWQIjEHVMZ3ATgPq"
    },
    "analysis_timestamp": "2025-08-25 13:47:58"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_DEMChangeUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_DEMChangeUpdate]\r\n\t@id AS INT\r\n\t,@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@active AS BIT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tUPDATE input.DEMChange\r\n\tSET FY = @fy\r\n\t\t,[Name] = @name\r\n\t\t,[Description] = @description\r\n\t\t,Active\t= @active\r\n\t\t,ModifiedBy\t= @actionBy\r\n\t\t,ModifiedDate = GETDATE()\r\n\tWHERE ID = @id;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.870000",
      "last_altered": "2025-08-25 15:54:05.870000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@active",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_DEMChangeUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_DEMChangeUpdate` is designed to update records in the `DEMChange` table within the `input` schema. It modifies specific fields of a record identified by a unique `ID`. The procedure updates fiscal year, name, description, active status, and records the user who performed the update along with the current timestamp.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `UPDATE` statement that modifies a record based on a primary key. There are no complex joins, conditional logic, or transactions, which keeps the complexity low.\n\n#### 3. Input Parameters\n- `@id AS INT`: The unique identifier for the record to be updated. This is a critical parameter as it determines which record will be modified.\n- `@fy AS INT`: Represents the fiscal year to be updated in the record.\n- `@name AS VARCHAR(250)`: The new name to be set for the record.\n- `@description AS VARCHAR(500)`: The new description for the record.\n- `@active AS BIT`: A flag indicating whether the record is active (1) or inactive (0).\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system making the update. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It performs an `UPDATE` operation on the `DEMChange` table, setting the fiscal year, name, description, active status, and updating the `ModifiedBy` and `ModifiedDate` fields.\n- The `WHERE` clause ensures that only the record with the specified `ID` is updated.\n- The `ModifiedDate` is set to the current date and time using `GETDATE()`, capturing when the update occurred.\n\n#### 5. Performance Considerations\n- The procedure's performance is primarily dependent on the indexing of the `ID` column. Assuming `ID` is a primary key or has an index, the update operation should be efficient.\n- The use of `SET NOCOUNT ON` is a good practice to reduce unnecessary network traffic.\n- The procedure does not handle large data manipulations or complex operations, so it should perform well under typical conditions.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: If multiple updates occur simultaneously on the same record, there could be a risk of overwriting changes. Implementing row versioning or locking mechanisms could mitigate this.\n- **Data Integrity**: There is no validation of input parameters within the procedure. Invalid or malicious data could be passed, potentially leading to data integrity issues.\n- **Error Handling**: The procedure lacks error handling. If the `UPDATE` fails (e.g., due to a non-existent `ID`), the procedure will not provide feedback or handle the error gracefully.\n- **Security**: The procedure allows updates to critical fields without any checks or balances. Consider implementing role-based access control or input validation to enhance security.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 994,
      "api_response_id": "chatcmpl-C8VaRshNDs3rlUrMzmVm16GxBkdHV"
    },
    "analysis_timestamp": "2025-08-25 13:48:06"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_GetActionTypes",
      "definition": "CREATE PROCEDURE [input].[USP_GetActionTypes]\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT ActionTypeId\r\n\t\t,[Name] AS ActionName\r\n\t\t,[Description] AS ActionDescription\r\n\tFROM input.ActionType\r\n\tWHERE IsShownInDropdown = 1;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.870000",
      "last_altered": "2025-08-25 15:54:05.870000",
      "type": "PROCEDURE"
    },
    "parameters": [],
    "chatgpt_explanation": {
      "procedure_name": "USP_GetActionTypes",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_GetActionTypes` is designed to retrieve a list of action types from the `ActionType` table within the `input` schema. It specifically selects action types that are marked to be shown in a dropdown list, as indicated by the `IsShownInDropdown` column. The procedure returns three columns: `ActionTypeId`, `ActionName`, and `ActionDescription`.\n\n#### 2. Complexity Level: Low\nThe complexity of this stored procedure is low. It performs a straightforward SELECT query with a simple WHERE clause to filter results. There are no input parameters, conditional logic, or complex operations involved.\n\n#### 3. Input Parameters\nThis stored procedure does not have any input parameters. It operates on the `ActionType` table and retrieves data based on a fixed condition (`IsShownInDropdown = 1`).\n\n#### 4. Business Logic and Workflow\n- **SET NOCOUNT ON**: This command is used to prevent the sending of DONE_IN_PROC messages for each statement in a stored procedure. This can reduce network traffic and improve performance when the number of affected rows is not needed.\n- **SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED**: This sets the isolation level for the transaction to READ UNCOMMITTED, which allows the procedure to read data that might be in the process of being modified by other transactions. This can lead to dirty reads but improves performance by reducing locking overhead.\n- **SELECT Statement**: The procedure selects `ActionTypeId`, `Name` (aliased as `ActionName`), and `Description` (aliased as `ActionDescription`) from the `ActionType` table where `IsShownInDropdown` is true (1). This implies that the procedure is used to fetch action types that are intended to be displayed in a dropdown menu, likely for user interface purposes.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED Isolation Level**: While this isolation level can improve performance by reducing locking, it can also lead to dirty reads, where data might be read that is not yet committed. This is suitable for scenarios where the most up-to-date data is not critical, and performance is prioritized.\n- **Indexing**: To optimize the performance of the SELECT query, especially if the `ActionType` table is large, ensure that there is an index on the `IsShownInDropdown` column. This will help in quickly filtering the rows that need to be returned.\n- **NOCOUNT**: Using `SET NOCOUNT ON` can slightly improve performance by reducing the amount of information sent over the network.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of READ UNCOMMITTED isolation level can lead to dirty reads, where uncommitted changes from other transactions are read. This might not be suitable if the application requires consistent and accurate data.\n- **Lack of Input Parameters**: The procedure does not allow for dynamic filtering or customization of the query, which limits its flexibility. If future requirements change, the procedure might need to be modified to include parameters.\n- **Schema Dependency**: The procedure is tightly coupled with the `input` schema and the `ActionType` table structure. Any changes to the table schema or column names will require updates to the procedure.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 961,
      "api_response_id": "chatcmpl-C8VaZpODxXhtyr0BMYkHMXCPtEkKt"
    },
    "analysis_timestamp": "2025-08-25 13:48:21"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_GetProjectChangeDetailsByScenarioId",
      "definition": "CREATE PROCEDURE [input].[USP_GetProjectChangeDetailsByScenarioId]\r\n(\r\n\t@ScenarioId AS INT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSELECT P.ProjectChangeID\r\n\t\t,P.AgencyCode\r\n\t\t,P.BudgetGroupID\r\n\t\t,P.BillingPeriod\r\n\t\t,SUM(P.MonthlyDemandUsage) AS MonthlyDemandUsage\r\n\t\t,SUM(P.MonthlyEnergyUsage) AS MonthlyEnergyUsage\r\n\t\t,SUM(P.MonthlyOnPeakEnergyUsage) AS MonthlyOnPeakEnergyUsage\r\n\t\t,SUM(P.MonthlyOffPeakEnergyUsage) AS MonthlyOffPeakEnergyUsage\r\n\t\t,SUM(P.EnergyUsageReactivePower) AS EnergyUsageReactivePower\r\n\t\t,SUM(P.StreetLightingFacilityPoints) AS StreetLightingFacilityPoints\r\n\t\t,SUM(P.NumberOfDistinctAccount) AS NumberOfDistinctAccount\r\n\tFROM input.vwProjectChangeDetailsMonthly AS P\r\n\t\tINNER JOIN budget.Scenario AS S ON S.ProjectChangeID = P.ProjectChangeID\r\n\tWHERE S.ID = @ScenarioId\r\n\tGROUP BY P.ProjectChangeID, P.AgencyCode, P.BudgetGroupID, P.BillingPeriod;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.883000",
      "last_altered": "2025-08-25 15:54:05.883000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@ScenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_GetProjectChangeDetailsByScenarioId",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_GetProjectChangeDetailsByScenarioId` is designed to retrieve aggregated project change details based on a specific scenario ID. It queries data from a view `vwProjectChangeDetailsMonthly` and joins it with the `Scenario` table to filter results by the provided scenario ID. The procedure aggregates various usage metrics and groups the results by project change ID, agency code, budget group ID, and billing period.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this stored procedure is considered medium. It involves a join operation, aggregation of multiple columns, and grouping, which requires a moderate understanding of SQL operations and performance considerations.\n\n#### 3. Input Parameters\n- `@ScenarioId AS INT`: This is the sole input parameter for the procedure. It is used to filter the results to only include data associated with the specified scenario ID from the `Scenario` table.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It performs a `SELECT` query on the `vwProjectChangeDetailsMonthly` view, joining it with the `Scenario` table using the `ProjectChangeID`.\n- The `WHERE` clause filters the results to include only those records where the `Scenario` table's ID matches the provided `@ScenarioId`.\n- The query aggregates several columns using the `SUM` function, such as `MonthlyDemandUsage`, `MonthlyEnergyUsage`, and others, to provide total usage metrics.\n- The results are grouped by `ProjectChangeID`, `AgencyCode`, `BudgetGroupID`, and `BillingPeriod`, which allows for aggregation of data within these groupings.\n\n#### 5. Performance Considerations\n- The use of `SET NOCOUNT ON` is a good practice to enhance performance by reducing unnecessary network traffic.\n- The performance of the join operation depends on the indexing of the `ProjectChangeID` in both the `vwProjectChangeDetailsMonthly` view and the `Scenario` table. Proper indexing can significantly improve query performance.\n- Aggregation operations like `SUM` can be resource-intensive, especially if the dataset is large. Ensuring that the underlying tables or views are optimized for read operations can help mitigate performance issues.\n- The grouping operation can also impact performance, particularly if there are many distinct groups. Indexing on the grouping columns can help improve performance.\n\n#### 6. Potential Issues or Risks\n- If the `vwProjectChangeDetailsMonthly` view or the `Scenario` table contains a large volume of data, the query might experience performance degradation due to the join and aggregation operations.\n- The procedure assumes that the `Scenario` table and the view have consistent and valid data. Any discrepancies or data integrity issues could lead to incorrect results.\n- Lack of error handling within the procedure means that any runtime errors (e.g., invalid `@ScenarioId`) will not be gracefully managed, potentially causing the procedure to fail without providing meaningful feedback.\n- If the `ScenarioId` provided does not exist in the `Scenario` table, the procedure will return an empty result set, which might not be the desired behavior in all business contexts.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1118,
      "api_response_id": "chatcmpl-C8VapL8aMdBArSyHufDblfuBKBl0L"
    },
    "analysis_timestamp": "2025-08-25 13:48:31"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ProjectChangeClone",
      "definition": "CREATE PROCEDURE [input].[USP_ProjectChangeClone]\r\n(\r\n    @fy AS INT,\r\n    @name AS VARCHAR(250),\r\n    @description AS VARCHAR(500),\r\n    @actionBy AS VARCHAR(25) = 'SYSTEM',\r\n    @id AS INT OUTPUT,\r\n    @originalId AS INT\r\n)\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n\r\n    DECLARE @IdOutput TABLE (ID INT);\r\n\r\n    INSERT INTO input.ProjectChange (FY, [Name], [Description], CreatedBy, ModifiedBy)\r\n    OUTPUT INSERTED.ID INTO @IdOutput\r\n    VALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n    SELECT @id = ID FROM @IdOutput;\r\n\r\n    -----------------------------------------------------------------------------------------------------\r\n    -- get all old DetailID that are associated with the old ProjectChangeID\r\n    SELECT [DetailID]\r\n    INTO #TEMP_Detail_ID\r\n    FROM [input].[ProjectChangeDetail]\r\n    WHERE [ProjectChangeID] = @originalId;\r\n\r\n    -- persist the excluded items for return\r\n    SELECT DISTINCT DetailID\r\n        ,AgencyCode\r\n        ,BudgetGroupID\r\n    INTO #TEMP_Obsolete\r\n    FROM input.ProjectChangeDetail\r\n    WHERE DetailID IN (SELECT DetailID FROM #TEMP_Detail_ID)\r\n          AND (AgencyCode NOT IN (SELECT a.AgencyCodeOEC\r\n                FROM Preload.Agency AS a\r\n                    INNER JOIN Preload.AgencyByFY AS abf ON a.AgencyId = abf.AgencyId\r\n                  WHERE abf.FY = @fy)\r\n              OR BudgetGroupID NOT IN (SELECT BudgetGroupID FROM Preload.BudgetGroupByFY WHERE FY = @fy));\r\n\r\n    -- purge #TEMP_Detail_ID to exclude entries with obsolete agencies and budget groups\r\n    DELETE #TEMP_Detail_ID\r\n    WHERE [DetailID] IN (SELECT [DetailID] FROM #TEMP_Obsolete);\r\n    -----------------------------------------------------------------------------------------------------\r\n\r\n    INSERT INTO input.ProjectChangeDetail(ProjectChangeID\r\n        ,DEMProjectID\r\n        ,AgencyCode\r\n        ,FacilityNo\r\n        ,FacilityName\r\n        ,FacilityAddress\r\n        ,AccountNo\r\n        ,BudgetGroupID\r\n        ,EffectiveDate\r\n        ,DemandSavings\r\n        ,EnergySavings\r\n        ,EnergySavingsPeakPercentage\r\n        ,ProgramTypeId\r\n        ,PatternTypeId)\r\n    SELECT @id\r\n        ,DEMProjectID\r\n        ,AgencyCode\r\n        ,FacilityNo\r\n        ,FacilityName\r\n        ,FacilityAddress\r\n        ,AccountNo\r\n        ,BudgetGroupID\r\n        ,EffectiveDate\r\n        ,DemandSavings\r\n        ,EnergySavings\r\n        ,EnergySavingsPeakPercentage\r\n        ,ProgramTypeId\r\n        ,PatternTypeId\r\n    FROM input.ProjectChangeDetail\r\n    WHERE ProjectChangeID = @originalId\r\n          AND DetailID IN (SELECT DetailID FROM #TEMP_Detail_ID);\r\n\r\n    SELECT AgencyCode, BudgetGroupID\r\n    FROM #TEMP_Obsolete;\r\n\r\n    DROP TABLE #TEMP_Obsolete, #TEMP_Detail_ID;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.893000",
      "last_altered": "2025-08-25 15:54:05.893000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@originalId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectChangeClone",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectChangeClone` is designed to clone a project change record from an existing one, identified by `@originalId`, into a new record for a specified fiscal year (`@fy`). It also handles associated project change details, filtering out obsolete entries based on agency codes and budget group IDs that do not match the current fiscal year. The procedure returns the new project change ID and a list of obsolete agency codes and budget group IDs.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including data insertion, temporary table management, filtering logic, and output handling. It requires a good understanding of SQL operations, such as `INSERT`, `SELECT INTO`, `DELETE`, and `OUTPUT`, as well as temporary table usage.\n\n#### 3. Input Parameters\n- `@fy AS INT`: The fiscal year for which the new project change is being created.\n- `@name AS VARCHAR(250)`: The name of the new project change.\n- `@description AS VARCHAR(500)`: A description of the new project change.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user or system identifier performing the action, defaulting to 'SYSTEM'.\n- `@id AS INT OUTPUT`: An output parameter that returns the ID of the newly created project change.\n- `@originalId AS INT`: The ID of the original project change to be cloned.\n\n#### 4. Business Logic and Workflow\n1. **Insert New Project Change**: A new record is inserted into `input.ProjectChange` with the provided fiscal year, name, description, and actionBy. The new ID is captured using the `OUTPUT` clause into a table variable `@IdOutput`, and then assigned to the output parameter `@id`.\n\n2. **Retrieve Old Detail IDs**: The procedure selects all `DetailID`s associated with the original project change ID into a temporary table `#TEMP_Detail_ID`.\n\n3. **Identify Obsolete Details**: It identifies obsolete details by checking if the agency codes and budget group IDs are not valid for the specified fiscal year. These are stored in another temporary table `#TEMP_Obsolete`.\n\n4. **Filter Out Obsolete Details**: The obsolete details are removed from `#TEMP_Detail_ID`.\n\n5. **Clone Project Change Details**: The remaining valid details are inserted into `input.ProjectChangeDetail` with the new project change ID.\n\n6. **Return Obsolete Details**: The procedure returns a list of obsolete agency codes and budget group IDs.\n\n7. **Cleanup**: Temporary tables `#TEMP_Obsolete` and `#TEMP_Detail_ID` are dropped to clean up resources.\n\n#### 5. Performance Considerations\n- **Temporary Tables**: The use of temporary tables can impact performance, especially if the dataset is large. Indexing temporary tables or using table variables might be considered for optimization.\n- **Filtering Logic**: The filtering logic involves multiple subqueries, which could be optimized by ensuring that the underlying tables have appropriate indexes.\n- **Concurrency**: The procedure does not include explicit transaction handling, which might be necessary if used in a high-concurrency environment to ensure data integrity.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Without explicit transaction management, there is a risk of partial updates if an error occurs mid-procedure.\n- **Scalability**: As the dataset grows, the performance might degrade due to the use of temporary tables and subqueries.\n- **Error Handling**: The procedure lacks error handling mechanisms, which could lead to unhandled exceptions and incomplete operations.\n- **Security**: The procedure assumes that the input parameters are sanitized and does not include any checks for SQL injection or other security vulnerabilities.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1602,
      "api_response_id": "chatcmpl-C8VaybXYGFNl8EfLiGFwDsmjG921s"
    },
    "analysis_timestamp": "2025-08-25 13:48:46"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ProjectChangeCreate",
      "definition": "CREATE PROCEDURE [input].[USP_ProjectChangeCreate]\r\n\t@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@id AS INT OUTPUT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO input.ProjectChange (FY, Name, [Description], CreatedBy, ModifiedBy)\r\n\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\tVALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.897000",
      "last_altered": "2025-08-25 15:54:05.897000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectChangeCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectChangeCreate` is designed to insert a new record into the `input.ProjectChange` table. It captures details about a project change, such as the fiscal year, name, and description, along with metadata about who created and modified the record. The procedure outputs the ID of the newly inserted record.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single insert operation and the retrieval of the inserted record's ID. It does not include complex logic, conditional statements, or multiple operations.\n\n#### 3. Input Parameters\n- `@fy AS INT`: Represents the fiscal year associated with the project change.\n- `@name AS VARCHAR(250)`: The name of the project change, with a maximum length of 250 characters.\n- `@description AS VARCHAR(500)`: A description of the project change, allowing up to 500 characters.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system making the change. Defaults to 'SYSTEM' if not provided.\n- `@id AS INT OUTPUT`: An output parameter that returns the ID of the newly inserted record in the `input.ProjectChange` table.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance in certain scenarios.\n- It declares a table variable `@IdOutput` to temporarily store the ID of the newly inserted record.\n- An `INSERT` statement adds a new record to the `input.ProjectChange` table, capturing the fiscal year, name, description, and the user responsible for the creation and modification.\n- The `OUTPUT` clause captures the ID of the inserted record and stores it in the `@IdOutput` table variable.\n- Finally, the procedure selects the ID from `@IdOutput` and assigns it to the output parameter `@id`.\n\n#### 5. Performance Considerations\n- The use of `SET NOCOUNT ON` can reduce network traffic by suppressing the \"n rows affected\" message, which is beneficial in high-volume environments.\n- The procedure performs a single insert operation, which is generally efficient. However, performance could be impacted if the `input.ProjectChange` table has triggers or if there are many indexes that need updating.\n- The use of a table variable for capturing the inserted ID is efficient for this single-row operation.\n\n#### 6. Potential Issues or Risks\n- The procedure does not include error handling. If the insert operation fails, the procedure will terminate without providing feedback on the error.\n- There is no validation of input parameters. Invalid or unexpected data types could lead to runtime errors or data integrity issues.\n- The default value for `@actionBy` is 'SYSTEM', which may not always be appropriate. If the procedure is called without specifying this parameter, it could lead to inaccurate audit trails.\n- The procedure assumes that the `input.ProjectChange` table has an identity column named `ID`. If the table structure changes, the procedure may fail or produce incorrect results.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 983,
      "api_response_id": "chatcmpl-C8VbDpe58XWbkSo8U8bjJmWRjAKa3"
    },
    "analysis_timestamp": "2025-08-25 13:49:05"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ProjectChangeDelete",
      "definition": "CREATE PROCEDURE [input].[USP_ProjectChangeDelete]\r\n\t@id AS INT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDELETE FROM input.ProjectChangeDetail WHERE ProjectChangeID = @id;\r\n\tDELETE FROM input.ProjectChange WHERE ID = @id;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.900000",
      "last_altered": "2025-08-25 15:54:05.900000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectChangeDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectChangeDelete` is designed to delete records from two related tables within a database schema named `input`. Specifically, it removes entries from the `ProjectChangeDetail` table and the `ProjectChange` table based on a given `ProjectChangeID`. This procedure is typically used to clean up or remove project change records and their associated details from the database.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving only two DELETE operations. It does not include any conditional logic, loops, or complex operations, making it relatively simple in terms of SQL complexity.\n\n#### 3. Input Parameters\n- `@id AS INT`: This parameter represents the unique identifier for the project change record that needs to be deleted. It is used to match and delete records in both the `ProjectChangeDetail` and `ProjectChange` tables.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter specifies the user or system entity responsible for initiating the delete operation. It defaults to 'SYSTEM' if not provided. However, in this procedure, it is not utilized within the logic.\n\n#### 4. Business Logic and Workflow\n1. **SET NOCOUNT ON**: This command is used to prevent the SQL Server from sending messages about the number of rows affected by the DELETE operations. This can reduce network traffic and improve performance slightly.\n2. **DELETE Operations**:\n   - The first DELETE statement removes all records from the `ProjectChangeDetail` table where the `ProjectChangeID` matches the provided `@id`. This ensures that all related detail records are removed before the main project change record.\n   - The second DELETE statement removes the record from the `ProjectChange` table where the `ID` matches the provided `@id`. This completes the deletion of the main project change entry.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `ProjectChangeID` in `ProjectChangeDetail` and `ID` in `ProjectChange` are indexed. This will improve the performance of the DELETE operations by allowing faster lookups.\n- **Transaction Management**: The procedure does not explicitly use transactions. If the DELETE operations need to be atomic (i.e., both succeed or fail together), consider wrapping them in a transaction block.\n- **NOCOUNT**: The use of `SET NOCOUNT ON` is beneficial in reducing unnecessary network traffic, especially if the procedure is called frequently.\n\n#### 6. Potential Issues or Risks\n- **Referential Integrity**: If there are foreign key constraints between `ProjectChange` and `ProjectChangeDetail`, ensure that the constraints are set to cascade deletes or are temporarily disabled to prevent errors during deletion.\n- **Data Loss**: The procedure permanently deletes data. Ensure that there is a backup or that the operation is logged if recovery is needed.\n- **Concurrency**: If multiple users or processes might attempt to delete the same `ProjectChangeID` simultaneously, consider implementing locking mechanisms to prevent conflicts or data integrity issues.\n- **Unused Parameter**: The `@actionBy` parameter is not used within the procedure. If tracking the user or system initiating the delete is necessary, consider logging this information in an audit table.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 944,
      "api_response_id": "chatcmpl-C8VbW5wUNNVE0VqZmpqxtpieTWX2Q"
    },
    "analysis_timestamp": "2025-08-25 13:49:22"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ProjectChangeDetailCreate",
      "definition": "CREATE PROCEDURE [input].[USP_ProjectChangeDetailCreate]\r\n\t@projectChangeId AS INT\r\n\t,@demProjectId AS VARCHAR(25)\r\n\t,@agencyCode AS VARCHAR(6)\r\n\t,@facilityNo AS VARCHAR(10) = NULL\r\n\t,@facilityName AS VARCHAR(100) = NULL\r\n\t,@facilityAddress AS VARCHAR(100) = NULL\r\n\t,@accountNo AS VARCHAR(26) = NULL\r\n\t,@budgetGroupId AS INT\r\n\t,@effectiveDate AS DATETIME\r\n\t,@demandSavings AS DECIMAL(18, 5) = 0.0\r\n\t,@energySavings\tAS DECIMAL(18, 5) = 0.0\r\n\t,@energySavingsPeakPercentage AS DECIMAL(10, 5) = 1.0\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@programTypeId AS INT\r\n\t,@patternTypeId AS INT\r\n\t,@notes\tAS VARCHAR(500) = NULL\r\n\t,@id AS INT OUTPUT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSET @facilityNo = NULLIF(ISNULL(@facilityNo, ''), '');\r\n\tSET @facilityName = NULLIF(ISNULL(@facilityName, ''), '');\r\n\tSET @facilityAddress = NULLIF(ISNULL(@facilityAddress, ''), '');\r\n\tSET @accountNo = NULLIF(ISNULL(@accountNo, ''), '');\r\n\tSET @notes = NULLIF(ISNULL(@notes, ''), '');\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO input.ProjectChangeDetail (ProjectChangeID, DEMProjectID, AgencyCode, FacilityNo, FacilityName, FacilityAddress, AccountNo\r\n\t\t\t\t,BudgetGroupID, EffectiveDate, DemandSavings, EnergySavings, EnergySavingsPeakPercentage\r\n\t\t\t\t,ProgramTypeId, PatternTypeId, Notes, CreatedBy, ModifiedBy)\r\n\tOUTPUT INSERTED.DetailID INTO @IdOutput\r\n\tVALUES (@projectChangeId, @demProjectId, @agencyCode, @facilityNo, @facilityName, @facilityAddress, @accountNo\r\n\t\t\t,@budgetGroupId, @effectiveDate, @demandSavings, @energySavings, @energySavingsPeakPercentage\r\n\t\t\t,@programTypeId, @patternTypeId, @notes, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\n\r\n--------------------------------------------------------------------\r\n-- Update ProjectChange and Scenario status if possible\r\n--------------------------------------------------------------------\r\n\t\r\n\tUPDATE input.ProjectChange\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @projectChangeId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE ProjectChangeID = @projectChangeId AND [Status] IN ('CALCULATED');\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.907000",
      "last_altered": "2025-08-25 15:54:05.907000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@projectChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@demProjectId",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyCode",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@facilityNo",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 10,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@facilityName",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 100,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@facilityAddress",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 100,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@accountNo",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 26,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 7,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 8,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@effectiveDate",
        "data_type": "datetime",
        "mode": "IN",
        "max_length": 8,
        "precision": 23,
        "scale": 3,
        "ordinal_position": 9,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@demandSavings",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 9,
        "precision": 18,
        "scale": 5,
        "ordinal_position": 10,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@energySavings",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 9,
        "precision": 18,
        "scale": 5,
        "ordinal_position": 11,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@energySavingsPeakPercentage",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 9,
        "precision": 10,
        "scale": 5,
        "ordinal_position": 12,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 13,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@programTypeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 14,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@patternTypeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 15,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@notes",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 16,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 17,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectChangeDetailCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectChangeDetailCreate` is designed to insert a new record into the `ProjectChangeDetail` table within the `input` schema. It captures various details related to a project change, such as project identifiers, agency codes, facility information, budget details, and savings metrics. After inserting the record, it updates the `ProjectChange` table to reflect the modification date and user, and it also updates the status of related scenarios in the `budget.Scenario` table if certain conditions are met.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including data validation, insertion, and conditional updates across different tables. The complexity arises from handling optional parameters, managing default values, and ensuring data consistency across related tables.\n\n#### 3. Input Parameters\n- `@projectChangeId AS INT`: The identifier for the project change.\n- `@demProjectId AS VARCHAR(25)`: The DEM project identifier.\n- `@agencyCode AS VARCHAR(6)`: The code representing the agency.\n- `@facilityNo AS VARCHAR(10) = NULL`: Optional facility number.\n- `@facilityName AS VARCHAR(100) = NULL`: Optional facility name.\n- `@facilityAddress AS VARCHAR(100) = NULL`: Optional facility address.\n- `@accountNo AS VARCHAR(26) = NULL`: Optional account number.\n- `@budgetGroupId AS INT`: Identifier for the budget group.\n- `@effectiveDate AS DATETIME`: The date when the change becomes effective.\n- `@demandSavings AS DECIMAL(18, 5) = 0.0`: The amount of demand savings.\n- `@energySavings AS DECIMAL(18, 5) = 0.0`: The amount of energy savings.\n- `@energySavingsPeakPercentage AS DECIMAL(10, 5) = 1.0`: The peak percentage of energy savings.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user performing the action, defaulting to 'SYSTEM'.\n- `@programTypeId AS INT`: Identifier for the program type.\n- `@patternTypeId AS INT`: Identifier for the pattern type.\n- `@notes AS VARCHAR(500) = NULL`: Optional notes about the change.\n- `@id AS INT OUTPUT`: Output parameter to return the newly inserted record's ID.\n\n#### 4. Business Logic and Workflow\n1. **Parameter Normalization**: Optional parameters are normalized to `NULL` if they are empty strings.\n2. **Record Insertion**: A new record is inserted into the `ProjectChangeDetail` table. The `OUTPUT` clause captures the `DetailID` of the inserted record into a table variable `@IdOutput`.\n3. **ID Assignment**: The captured `DetailID` is assigned to the output parameter `@id`.\n4. **ProjectChange Update**: The `ProjectChange` table is updated to set the `ModifiedDate` and `ModifiedBy` fields for the specified `projectChangeId`.\n5. **Scenario Status Update**: The `budget.Scenario` table is updated to set the status to 'REQUIRERECALC' for scenarios linked to the `projectChangeId` that currently have a status of 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `ProjectChangeDetail`, `ProjectChange`, and `Scenario` tables are properly indexed on the columns used in the `WHERE` clauses to optimize update operations.\n- **Transaction Management**: The procedure does not explicitly manage transactions, which could lead to partial updates if an error occurs. Consider wrapping the operations in a transaction to ensure atomicity.\n- **Concurrency**: The procedure updates multiple tables, which could lead to locking issues in a high-concurrency environment. Consider using appropriate isolation levels.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: The procedure assumes that the `projectChangeId` and related identifiers are valid and exist in the respective tables. Lack of validation could lead to foreign key violations or orphaned records.\n- **Error Handling**: The procedure lacks error handling mechanisms. If any operation fails, it could leave the database in an inconsistent state.\n- **Default Values**: The use of default values for optional parameters may lead to unintended data being inserted if not carefully managed.\n- **Scalability**: As the number of records grows, the performance of the updates and inserts may degrade if the tables are not properly indexed or if the procedure is executed frequently.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1724,
      "api_response_id": "chatcmpl-C8VbnfBWbp4MLCYUPk0pQLSYUMzEv"
    },
    "analysis_timestamp": "2025-08-25 13:49:34"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ProjectChangeDetailsDelete",
      "definition": "CREATE PROCEDURE [input].[USP_ProjectChangeDetailsDelete]\r\n\t@id AS INT = NULL\r\n\t,@projectChangeId AS INT = NULL\r\n\t,@budgetGroupId AS INT = NULL\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSET @id = ISNULL(@id, 0);\r\n\tSET @projectChangeId = ISNULL(@projectChangeId, 0);\r\n\tSET @budgetGroupId = ISNULL(@budgetGroupId, 0);\r\n\r\n\tIF @id > 0 OR @projectChangeId > 0\r\n\t\tDELETE FROM input.ProjectChangeDetail\r\n\t\tWHERE DetailID = ISNULL(@id, DetailID)\r\n\t\t\tAND ProjectChangeID = ISNULL(@projectChangeId, ProjectChangeID)\r\n\t\t\tAND BudgetGroupID = ISNULL(@budgetGroupId, BudgetGroupID);\r\n\r\n--------------------------------------------------------------------\r\n-- Update ProjectChange and Scenario status if possible\r\n--------------------------------------------------------------------\r\n\t\r\n\tUPDATE input.ProjectChange\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @projectChangeId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE ProjectChangeID = @projectChangeId AND [Status] IN ('CALCULATED');\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.913000",
      "last_altered": "2025-08-25 15:54:05.913000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@projectChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectChangeDetailsDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectChangeDetailsDelete` is designed to delete records from the `input.ProjectChangeDetail` table based on specified criteria and update related records in the `input.ProjectChange` and `budget.Scenario` tables. It primarily focuses on maintaining data integrity and ensuring that related records reflect the changes made by the deletion operation.\n\n#### 2. Complexity Level: Medium\nThe procedure involves conditional logic for deletion, updates to multiple tables, and uses default parameter values. While the logic is straightforward, the interaction with multiple tables and conditional updates increases its complexity slightly beyond a basic level.\n\n#### 3. Input Parameters\n- `@id AS INT = NULL`: Represents the unique identifier for a specific detail record in the `ProjectChangeDetail` table. Default is `NULL`.\n- `@projectChangeId AS INT = NULL`: Represents the identifier for a project change, used to filter records in both the `ProjectChangeDetail` and `ProjectChange` tables. Default is `NULL`.\n- `@budgetGroupId AS INT = NULL`: Represents the identifier for a budget group, used to filter records in the `ProjectChangeDetail` table. Default is `NULL`.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: Indicates the user or system responsible for the action, used to update the `ModifiedBy` field in the `ProjectChange` table. Default is `'SYSTEM'`.\n\n#### 4. Business Logic and Workflow\n1. **Parameter Initialization**: The procedure initializes the input parameters to zero if they are `NULL` using the `ISNULL` function. This ensures that the subsequent logic can handle cases where parameters are not provided.\n   \n2. **Conditional Deletion**: \n   - The procedure deletes records from the `input.ProjectChangeDetail` table where the `DetailID`, `ProjectChangeID`, and `BudgetGroupID` match the provided parameters. \n   - The `ISNULL` function is used to allow for flexible filtering, meaning if a parameter is zero, it will not filter on that column.\n\n3. **Updating Related Records**:\n   - The `input.ProjectChange` table is updated to reflect the modification date and the user who performed the action if a `projectChangeId` is provided.\n   - The `budget.Scenario` table is updated to set the status to `'REQUIRERECALC'` for records with a `ProjectChangeID` matching the provided `projectChangeId` and a current status of `'CALCULATED'`.\n\n#### 5. Performance Considerations\n- **Index Utilization**: The effectiveness of the deletion and update operations depends on the presence of indexes on `DetailID`, `ProjectChangeID`, and `BudgetGroupID` in the `ProjectChangeDetail` table, as well as `ProjectChangeID` in the `Scenario` table.\n- **Batch Processing**: If the tables involved are large, consider batch processing or additional filtering to avoid locking issues and improve performance.\n- **SET NOCOUNT ON**: This improves performance by preventing the sending of DONE_IN_PROC messages to the client for each statement in the procedure.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Deleting records without proper validation or logging could lead to data integrity issues. Ensure that the deletion criteria are correct and that there is a mechanism to audit or log deletions.\n- **Concurrency**: The procedure may face concurrency issues if multiple users attempt to delete or update the same records simultaneously. Implementing appropriate locking mechanisms or using transaction isolation levels could mitigate this.\n- **Default Parameter Values**: Using zero as a default value for `@id`, `@projectChangeId`, and `@budgetGroupId` might lead to unintended deletions if not handled carefully. Ensure that zero is a valid and safe default in the context of the application.\n- **Error Handling**: The procedure lacks explicit error handling. Consider adding TRY...CATCH blocks to manage exceptions and ensure that the procedure fails gracefully.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1299,
      "api_response_id": "chatcmpl-C8Vc0AH0bu0azPCckDeOk13dCpcMs"
    },
    "analysis_timestamp": "2025-08-25 13:49:46"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ProjectChangeDetailsRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_ProjectChangeDetailsRetrieve]\r\n(\r\n\t@id AS INT = NULL\r\n\t,@projectChangeId AS INT = NULL\r\n\t,@budgetGroupId AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSET @id = NULLIF(ISNULL(@id, 0), 0);\r\n\tSET @projectChangeId = NULLIF(ISNULL(@projectChangeId, 0), 0);\r\n\tSET @budgetGroupId = NULLIF(ISNULL(@budgetGroupId, 0), 0);\r\n\r\n\tSELECT PCD.DetailID\r\n\t\t,PCD.ProjectChangeID\r\n\t\t,PCD.DEMProjectID\r\n\t\t,PCD.AgencyCode\r\n\t\t,PCD.FacilityNo\r\n\t\t,PCD.FacilityName\r\n\t\t,PCD.FacilityAddress\r\n\t\t,PCD.AccountNo\r\n\t\t,PCD.BudgetGroupID\r\n\t\t,PCD.EffectiveDate\r\n\t\t,PCD.DemandSavings\r\n\t\t,PCD.EnergySavings\r\n\t\t,PCD.EnergySavingsPeakPercentage\r\n\t\t,PCD.EnergyUsagePeak\r\n\t\t,PCD.EnergyUsageOffPeak\r\n\t\t,PCD.ProgramTypeID\r\n\t\t,PPT.Abbreviation AS ProgramType\r\n\t\t,PCD.PatternTypeID\r\n\t\t,PCD.Notes\r\n\t\t,PCD.CreatedDate\r\n\t\t,PCD.CreatedBy\r\n\t\t,PCD.ModifiedDate\r\n\t\t,PCD.ModifiedBy\r\n\tFROM input.vwProjectChangeDetails AS PCD\r\n\t\tINNER JOIN input.ProjectProgramType AS PPT ON PCD.ProgramTypeID = PPT.ProjectProgramId\r\n\tWHERE PCD.DetailID = ISNULL(@id, PCD.DetailID)\r\n\t\tAND PCD.ProjectChangeID = ISNULL(@projectChangeId, PCD.ProjectChangeID)\r\n\t\tAND PCD.BudgetGroupID = ISNULL(@budgetGroupId, PCD.BudgetGroupID)\r\n\tORDER BY PCD.BudgetGroupID ASC\r\n\t\t,PCD.AgencyCode ASC\r\n\t\t,PCD.FacilityNo ASC\r\n\t\t,PCD.AccountNo ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.917000",
      "last_altered": "2025-08-25 15:54:05.917000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@projectChangeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectChangeDetailsRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectChangeDetailsRetrieve` is designed to retrieve detailed information about project changes from a view named `vwProjectChangeDetails`. It allows filtering based on three optional parameters: `DetailID`, `ProjectChangeID`, and `BudgetGroupID`. The procedure joins this view with the `ProjectProgramType` table to include program type abbreviations in the result set. The results are ordered by `BudgetGroupID`, `AgencyCode`, `FacilityNo`, and `AccountNo`.\n\n#### 2. Complexity Level: Medium\nThe procedure involves conditional logic for parameter handling, a join operation, and a multi-column ordering, which adds a moderate level of complexity. The use of a view and a join operation requires understanding of the underlying data structures.\n\n#### 3. Input Parameters\n- `@id AS INT = NULL`: Represents the `DetailID` for filtering specific project change details. If not provided, it defaults to `NULL`.\n- `@projectChangeId AS INT = NULL`: Represents the `ProjectChangeID` for filtering. Defaults to `NULL` if not specified.\n- `@budgetGroupId AS INT = NULL`: Represents the `BudgetGroupID` for filtering. Defaults to `NULL` if not specified.\n\n#### 4. Business Logic and Workflow\n- **Parameter Initialization**: Each input parameter is initialized to `NULL` if it is `0` or `NULL`, using `NULLIF` and `ISNULL` functions. This ensures that the default behavior is to ignore the filter if the parameter is not explicitly set.\n- **Transaction Isolation Level**: The procedure sets the transaction isolation level to `READ UNCOMMITTED`, allowing it to read uncommitted changes from other transactions, which can improve performance but may lead to dirty reads.\n- **Data Retrieval**: The procedure retrieves data from the `vwProjectChangeDetails` view, joining it with the `ProjectProgramType` table to get the program type abbreviation.\n- **Filtering**: The `WHERE` clause applies filters based on the input parameters, using `ISNULL` to default to the column value if the parameter is `NULL`.\n- **Ordering**: The results are ordered by `BudgetGroupID`, `AgencyCode`, `FacilityNo`, and `AccountNo` to provide a structured output.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: This isolation level can improve performance by reducing locking overhead but may result in reading uncommitted or dirty data.\n- **Indexing**: Performance can be significantly affected by the presence or absence of indexes on the columns used in the `WHERE` clause and the `JOIN` condition. Proper indexing on `DetailID`, `ProjectChangeID`, `BudgetGroupID`, and `ProgramTypeID` can enhance query performance.\n- **View Optimization**: The performance of the view `vwProjectChangeDetails` itself can impact the procedure. Ensuring that the view is optimized and indexed appropriately is crucial.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to dirty reads, where the data read might not be consistent or committed, potentially leading to incorrect results.\n- **Parameter Handling**: The logic for setting parameters to `NULL` if they are `0` or `NULL` might not be intuitive for all users, potentially leading to unexpected results if users are unaware of this behavior.\n- **Scalability**: As the dataset grows, the performance might degrade if the underlying tables and views are not properly indexed or optimized.\n- **Join Performance**: The join operation with `ProjectProgramType` can become a bottleneck if the `ProgramTypeID` is not indexed or if the table is large.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1453,
      "api_response_id": "chatcmpl-C8VcC9s0C3KA38QwmdUosUwxEwO94"
    },
    "analysis_timestamp": "2025-08-25 13:49:58"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ProjectChangeDetailUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_ProjectChangeDetailUpdate]\r\n\t@id AS INT\r\n\t,@demProjectId AS VARCHAR(25)\r\n\t,@agencyCode AS VARCHAR(6)\r\n\t,@facilityNo AS VARCHAR(10) = NULL\r\n\t,@facilityName AS VARCHAR(100) = NULL\r\n\t,@facilityAddress AS VARCHAR(100) = NULL\r\n\t,@accountNo AS VARCHAR(26) = NULL\r\n\t,@budgetGroupId AS INT\r\n\t,@effectiveDate AS DATETIME\r\n\t,@demandSavings AS DECIMAL(18, 5) = 0.0\r\n\t,@energySavings\tAS DECIMAL(18, 5) = 0.0\r\n\t,@energySavingsPeakPercentage AS DECIMAL(10, 5) = 1.0\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@programTypeId\tAS INT\r\n\t,@patternTypeId\tAS INT\r\n\t,@notes AS VARCHAR(500) = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSET @facilityNo = NULLIF(ISNULL(@facilityNo, ''), '');\r\n\tSET @facilityName = NULLIF(ISNULL(@facilityName, ''), '');\r\n\tSET @facilityAddress = NULLIF(ISNULL(@facilityAddress, ''), '');\r\n\tSET @accountNo = NULLIF(ISNULL(@accountNo, ''), '');\r\n\tSET @notes = NULLIF(ISNULL(@notes, ''), '');\r\n\r\n\tDECLARE @projectChangeId AS INT;\r\n\tSELECT @projectChangeId=MAX(ProjectChangeID)\r\n\tFROM input.ProjectChangeDetail\r\n\tWHERE DetailID = @id;\r\n\r\n\tUPDATE input.ProjectChangeDetail\r\n\tSET DEMProjectID = @demProjectID\r\n\t\t,AgencyCode\t= @agencyCode\r\n\t\t,FacilityNo\t= @facilityNo\r\n\t\t,FacilityName = @facilityName\r\n\t\t,FacilityAddress = @facilityAddress\r\n\t\t,AccountNo = @accountNo\r\n\t\t,BudgetGroupID = @budgetGroupId\r\n\t\t,EffectiveDate = @effectiveDate\r\n\t\t,DemandSavings = @demandSavings\r\n\t\t,EnergySavings = @energySavings\r\n\t\t,EnergySavingsPeakPercentage = @energySavingsPeakPercentage\r\n\t\t,ProgramTypeID = @programTypeId\r\n\t\t,PatternTypeID = @patternTypeId\r\n\t\t,Notes = @notes\r\n\t\t,ModifiedBy = @actionBy\r\n\t\t,ModifiedDate = GETDATE()\r\n\tWHERE DetailID = @id;\r\n\r\n--------------------------------------------------------------------\r\n-- Update ProjectChange and Scenario status if possible\r\n--------------------------------------------------------------------\r\n\t\r\n\tUPDATE input.ProjectChange\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @projectChangeId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE ProjectChangeID = @projectChangeId AND [Status] IN ('CALCULATED');\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.920000",
      "last_altered": "2025-08-25 15:54:05.920000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@demProjectId",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyCode",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@facilityNo",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 10,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@facilityName",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 100,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@facilityAddress",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 100,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@accountNo",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 26,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 7,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 8,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@effectiveDate",
        "data_type": "datetime",
        "mode": "IN",
        "max_length": 8,
        "precision": 23,
        "scale": 3,
        "ordinal_position": 9,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@demandSavings",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 9,
        "precision": 18,
        "scale": 5,
        "ordinal_position": 10,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@energySavings",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 9,
        "precision": 18,
        "scale": 5,
        "ordinal_position": 11,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@energySavingsPeakPercentage",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 9,
        "precision": 10,
        "scale": 5,
        "ordinal_position": 12,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 13,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@programTypeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 14,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@patternTypeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 15,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@notes",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 16,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectChangeDetailUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectChangeDetailUpdate` is designed to update records in the `input.ProjectChangeDetail` table based on a given `DetailID`. It also updates related records in the `input.ProjectChange` and `budget.Scenario` tables. The procedure ensures that certain fields are set to `NULL` if they are empty strings and updates the modification metadata for the records.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple updates across different tables and includes conditional logic to handle `NULL` values. It also manages relationships between tables, which adds to its complexity.\n\n#### 3. Input Parameters\n- `@id AS INT`: The primary identifier for the `ProjectChangeDetail` record to be updated.\n- `@demProjectId AS VARCHAR(25)`: The DEM project identifier.\n- `@agencyCode AS VARCHAR(6)`: The code representing the agency.\n- `@facilityNo AS VARCHAR(10) = NULL`: The facility number, optional.\n- `@facilityName AS VARCHAR(100) = NULL`: The facility name, optional.\n- `@facilityAddress AS VARCHAR(100) = NULL`: The facility address, optional.\n- `@accountNo AS VARCHAR(26) = NULL`: The account number, optional.\n- `@budgetGroupId AS INT`: The budget group identifier.\n- `@effectiveDate AS DATETIME`: The date when the changes become effective.\n- `@demandSavings AS DECIMAL(18, 5) = 0.0`: The amount of demand savings, default is 0.0.\n- `@energySavings AS DECIMAL(18, 5) = 0.0`: The amount of energy savings, default is 0.0.\n- `@energySavingsPeakPercentage AS DECIMAL(10, 5) = 1.0`: The percentage of energy savings at peak, default is 1.0.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user or system making the update, default is 'SYSTEM'.\n- `@programTypeId AS INT`: The program type identifier.\n- `@patternTypeId AS INT`: The pattern type identifier.\n- `@notes AS VARCHAR(500) = NULL`: Additional notes, optional.\n\n#### 4. Business Logic and Workflow\n1. **Null Handling**: The procedure first checks if optional string parameters are empty and sets them to `NULL` if they are.\n2. **Retrieve ProjectChangeID**: It retrieves the maximum `ProjectChangeID` for the given `DetailID` from the `input.ProjectChangeDetail` table.\n3. **Update ProjectChangeDetail**: It updates the `ProjectChangeDetail` record with the provided parameters and sets the `ModifiedBy` and `ModifiedDate` fields.\n4. **Update ProjectChange**: It updates the `ModifiedDate` and `ModifiedBy` fields in the `input.ProjectChange` table for the related `ProjectChangeID`.\n5. **Update Scenario Status**: It updates the `budget.Scenario` table, setting the status to 'REQUIRERECALC' for scenarios with the status 'CALCULATED' and the same `ProjectChangeID`.\n\n#### 5. Performance Considerations\n- **Index Usage**: Ensure that `DetailID` and `ProjectChangeID` are indexed to optimize the `SELECT` and `UPDATE` operations.\n- **Concurrency**: The procedure may face concurrency issues if multiple updates occur simultaneously on the same records.\n- **Transaction Management**: Consider wrapping the updates in a transaction to ensure atomicity, especially if the procedure is part of a larger workflow.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: If `DetailID` or `ProjectChangeID` are not unique or not properly indexed, it could lead to incorrect updates or performance degradation.\n- **Null Handling**: The use of `NULLIF` and `ISNULL` assumes that empty strings should be treated as `NULL`, which may not be the desired behavior in all cases.\n- **Hardcoded Defaults**: The default values for parameters like `@actionBy` may not be suitable for all contexts and could lead to inaccurate audit trails.\n- **Error Handling**: The procedure lacks explicit error handling, which could result in silent failures or incomplete updates if an error occurs during execution.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1713,
      "api_response_id": "chatcmpl-C8VcNRsYv5XFRB7pIYyiQgQG1hjbc"
    },
    "analysis_timestamp": "2025-08-25 13:50:12"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ProjectChangesRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_ProjectChangesRetrieve]\r\n\t@fy AS INT = NULL\r\n\t,@id AS INT = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @used bit = 0;\r\n\r\n\tIF @id IS NOT NULL\r\n\t  SELECT @used = CASE WHEN EXISTS (SELECT 1 FROM budget.Scenario s WHERE s.[Status] = 'CALCULATED' AND s.ProjectChangeID = @id) THEN 1 ELSE 0 END\r\n\r\n\tSELECT ID\r\n\t\t,[Name]\r\n\t\t,[Description]\r\n\t\t,FY\r\n\t\t,CreatedBy\r\n\t\t,CreatedDate\r\n\t\t,ModifiedBy\r\n\t\t,ModifiedDate\r\n\t\t,Active\r\n\t\t,Locked\r\n\t\t,@used AS UsedByOtherCalculatedScenario \r\n\tFROM input.vwProjectChanges\r\n\tWHERE ID = ISNULL(@id, ID) AND FY = ISNULL(@fy, FY)\r\n\tORDER BY FY DESC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.927000",
      "last_altered": "2025-08-25 15:54:05.927000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectChangesRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectChangesRetrieve` is designed to retrieve project change records from a view named `vwProjectChanges` within the `input` schema. It allows filtering based on fiscal year (`FY`) and project change ID (`ID`). Additionally, it checks if a specific project change ID is used in any calculated budget scenario and returns this information as part of the result set.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving basic SQL operations such as conditional checks, a simple SELECT query, and the use of a CASE statement. It does not involve complex logic, multiple joins, or intricate data transformations.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: This optional parameter allows filtering the results by fiscal year. If not provided, the procedure retrieves records for all fiscal years.\n- `@id AS INT = NULL`: This optional parameter allows filtering the results by a specific project change ID. If not provided, the procedure retrieves records for all project change IDs.\n\n#### 4. Business Logic and Workflow\n1. **Transaction Isolation Level**: The procedure sets the transaction isolation level to `READ UNCOMMITTED`, allowing dirty reads. This is typically used to improve performance by avoiding locks but at the cost of potential data inconsistency.\n2. **Variable Declaration**: A bit variable `@used` is declared and initialized to 0. This variable is used to determine if the specified project change ID is associated with any calculated budget scenario.\n3. **Conditional Check**: If `@id` is provided, the procedure checks if there exists any record in the `budget.Scenario` table where the `Status` is 'CALCULATED' and `ProjectChangeID` matches `@id`. If such a record exists, `@used` is set to 1.\n4. **Data Retrieval**: The procedure retrieves records from the `vwProjectChanges` view, filtering by `ID` and `FY` using the `ISNULL` function to handle NULL parameters. It includes the `@used` variable in the result set to indicate if the project change is used by another calculated scenario.\n5. **Ordering**: The results are ordered by fiscal year in descending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: While this isolation level can improve performance by reducing locking overhead, it may lead to reading uncommitted or dirty data, which could be problematic in certain scenarios.\n- **Indexing**: Performance can be improved if the `budget.Scenario` table and `vwProjectChanges` view are properly indexed on columns used in the WHERE clause (`ProjectChangeID`, `Status`, `ID`, `FY`).\n- **Conditional Logic**: The use of `ISNULL` in the WHERE clause can prevent the use of indexes effectively, potentially leading to full table scans.\n\n#### 6. Potential Issues or Risks\n- **Data Consistency**: The use of `READ UNCOMMITTED` can lead to reading uncommitted changes, which might not be suitable for all business scenarios, especially where data accuracy is critical.\n- **NULL Handling**: The use of `ISNULL` for filtering can lead to unexpected results if not carefully managed, especially if NULL values are present in the data.\n- **Scalability**: As the dataset grows, the performance might degrade if indexes are not optimized, particularly due to the potential full table scans caused by `ISNULL`.\n- **Concurrency**: While the procedure minimizes locking, it may still face issues in high-concurrency environments if the underlying data changes frequently.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1161,
      "api_response_id": "chatcmpl-C8VcbGwZ58tXMQwhDV8ntZe4hsSDj"
    },
    "analysis_timestamp": "2025-08-25 13:50:27"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_ProjectChangeUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_ProjectChangeUpdate]\r\n\t@id AS INT\r\n\t,@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@active AS BIT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tUPDATE input.ProjectChange\r\n\tSET FY = @fy\r\n\t\t,[Name] = @name\r\n\t\t,[Description] = @description\r\n\t\t,Active = @active\r\n\t\t,ModifiedBy = @actionBy\r\n\t\t,ModifiedDate = GETDATE()\r\n\tWHERE ID = @id;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.930000",
      "last_altered": "2025-08-25 15:54:05.930000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@active",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ProjectChangeUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ProjectChangeUpdate` is designed to update records in the `input.ProjectChange` table. It modifies specific fields of a record identified by a unique `ID`. The procedure updates the fiscal year, name, description, active status, and records the user who made the change along with the timestamp of the modification.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `UPDATE` statement that modifies a record based on a primary key. It does not include complex logic, conditional branching, or multiple operations, which keeps its complexity low.\n\n#### 3. Input Parameters\n- `@id AS INT`: The unique identifier for the record to be updated. It is crucial for locating the specific row in the `ProjectChange` table.\n- `@fy AS INT`: Represents the fiscal year to be updated in the record.\n- `@name AS VARCHAR(250)`: The new name for the project change, with a maximum length of 250 characters.\n- `@description AS VARCHAR(500)`: A description of the project change, with a maximum length of 500 characters.\n- `@active AS BIT`: A binary flag indicating whether the project change is active (1) or inactive (0).\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system making the update. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n1. **SET NOCOUNT ON**: This command prevents the message indicating the number of rows affected by the `UPDATE` statement from being returned. This is often used to reduce network traffic and improve performance when the row count is not needed.\n2. **UPDATE Statement**: The procedure updates the `ProjectChange` table:\n   - Sets the `FY` column to the value of `@fy`.\n   - Updates the `Name` column with `@name`.\n   - Updates the `Description` column with `@description`.\n   - Sets the `Active` column to the value of `@active`.\n   - Updates the `ModifiedBy` column with `@actionBy`.\n   - Sets the `ModifiedDate` column to the current date and time using `GETDATE()`.\n3. **WHERE Clause**: The update is applied only to the row where the `ID` matches `@id`.\n\n#### 5. Performance Considerations\n- **Index Utilization**: Assuming `ID` is a primary key or indexed column, the `UPDATE` operation should be efficient. Indexes on `ID` will facilitate quick row location.\n- **SET NOCOUNT ON**: This improves performance slightly by reducing unnecessary network traffic.\n- **Concurrency**: The procedure does not include any explicit transaction handling, which is acceptable for single-row updates but may need consideration in high-concurrency environments.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: There is no validation of input parameters within the procedure. Invalid or malicious data could be passed, potentially leading to data integrity issues.\n- **Concurrency Control**: Without explicit transaction management or locking hints, there could be race conditions if multiple updates occur simultaneously on the same record.\n- **Default Value for `@actionBy`**: The default value 'SYSTEM' might overwrite the actual user information if not explicitly provided, leading to inaccurate audit trails.\n- **Error Handling**: The procedure lacks error handling. If the `UPDATE` fails (e.g., due to a non-existent `ID`), no feedback is provided to the caller. Implementing TRY...CATCH blocks could improve robustness.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1090,
      "api_response_id": "chatcmpl-C8Vcq38ZBut4e0oBDYNArbnJ7T0AC"
    },
    "analysis_timestamp": "2025-08-25 13:50:40"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorClone",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorClone]\r\n\t@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@id AS INT OUTPUT\r\n\t,@originalId AS INT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO input.RateFactor (FY, [Name], [Description], CreatedBy, ModifiedBy)\r\n    OUTPUT INSERTED.ID INTO @IdOutput\r\n    VALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\n\r\n    -----------------------------------------------------------------------------------------------------\r\n    -- get all old [BudgetGroupID] that are associated with the old RateFactorID\r\n    SELECT DISTINCT [BudgetGroupID]\r\n    INTO #TEMP_Detail_ID\r\n    FROM [input].[RateFactorDetail]\r\n    WHERE [RateFactorID] = @originalId;\r\n\r\n    -- persist the excluded items for return -- Mei 6/30/2017\r\n    SELECT DISTINCT '' AS [AgencyCode], [BudgetGroupID]\r\n    INTO #TEMP_Obsolete\r\n    FROM input.RateFactorDetail\r\n    WHERE [BudgetGroupID] IN\r\n          (\r\n              SELECT [BudgetGroupID] FROM #TEMP_Detail_ID\r\n          )\r\n          AND [BudgetGroupID] NOT IN\r\n              (\r\n                  SELECT [BudgetGroupID] FROM [Preload].[BudgetGroupByFY] WHERE FY = @fy\r\n              );\r\n\r\n    -- purge #TEMP_Detail_ID to exclude entries with obsolete agencies and budget groups\r\n    DELETE #TEMP_Detail_ID\r\n    WHERE [BudgetGroupID] IN (SELECT [BudgetGroupID] FROM #TEMP_Obsolete);\r\n\r\n    -----------------------------------------------------------------------------------------------------\r\n\r\n\tINSERT INTO input.RateFactorDetail (RateFactorID, BudgetGroupID, BillingPeriod\r\n        ,CommodityAdder, CommodityMultiplier, DeliveryMultiplier, GRTMultiplier, DemandAdjustmentMultiplier)\r\n\tSELECT @id, BudgetGroupID\r\n        ,CASE WHEN 6 < BillingPeriod % 100 THEN (@fy - 1) * 100 + BillingPeriod % 100 ELSE @fy * 100 + BillingPeriod % 100 END AS BillingPeriod\r\n        ,CommodityAdder, CommodityMultiplier, DeliveryMultiplier, GRTMultiplier, DemandAdjustmentMultiplier\r\n\tFROM input.RateFactorDetail\r\n\tWHERE RateFactorID=@originalId AND BudgetGroupID IN (SELECT BudgetGroupID FROM #TEMP_Detail_ID);\r\n\r\n    SELECT [AgencyCode], [BudgetGroupID]\r\n    FROM #TEMP_Obsolete;\r\n\r\n    DROP TABLE #TEMP_Obsolete, #TEMP_Detail_ID; \r\nEND\r\n",
      "created": "2025-08-25 15:54:05.933000",
      "last_altered": "2025-08-25 15:54:05.933000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@originalId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorClone",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorClone` is designed to clone a rate factor record from the `input.RateFactor` table, along with its associated details from the `input.RateFactorDetail` table, for a specified fiscal year (`FY`). It creates a new rate factor entry with a new ID and copies relevant details, excluding obsolete budget groups. The procedure also returns a list of obsolete budget groups that were not cloned.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including data insertion, temporary table management, conditional logic for billing period adjustments, and filtering of obsolete data. While not overly complex, it requires a good understanding of SQL operations and temporary table usage.\n\n#### 3. Input Parameters\n- `@fy AS INT`: The fiscal year for which the rate factor is being cloned.\n- `@name AS VARCHAR(250)`: The name for the new rate factor entry.\n- `@description AS VARCHAR(500)`: A description for the new rate factor entry.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user or system identifier performing the action, defaulting to 'SYSTEM'.\n- `@id AS INT OUTPUT`: An output parameter to capture the ID of the newly created rate factor.\n- `@originalId AS INT`: The ID of the original rate factor to be cloned.\n\n#### 4. Business Logic and Workflow\n1. **Insert New Rate Factor**: A new entry is inserted into the `input.RateFactor` table with the provided fiscal year, name, description, and actionBy. The new ID is captured using the `OUTPUT` clause into a table variable `@IdOutput` and assigned to the output parameter `@id`.\n\n2. **Identify Relevant Budget Groups**: The procedure selects distinct `BudgetGroupID`s associated with the original rate factor ID into a temporary table `#TEMP_Detail_ID`.\n\n3. **Identify and Exclude Obsolete Budget Groups**: It identifies obsolete budget groups that are not present in the `Preload.BudgetGroupByFY` table for the specified fiscal year and stores them in another temporary table `#TEMP_Obsolete`.\n\n4. **Filter Out Obsolete Budget Groups**: The procedure deletes entries from `#TEMP_Detail_ID` that are considered obsolete based on the `#TEMP_Obsolete` table.\n\n5. **Clone Rate Factor Details**: It inserts new records into the `input.RateFactorDetail` table for the new rate factor ID, adjusting the `BillingPeriod` based on the fiscal year and excluding obsolete budget groups.\n\n6. **Return Obsolete Budget Groups**: The procedure returns a list of obsolete budget groups that were not cloned.\n\n7. **Cleanup**: Temporary tables `#TEMP_Obsolete` and `#TEMP_Detail_ID` are dropped to clean up resources.\n\n#### 5. Performance Considerations\n- **Temporary Tables**: The use of temporary tables can impact performance, especially if the data set is large. Indexing temporary tables or using table variables could be considered for optimization.\n- **Conditional Logic**: The calculation of `BillingPeriod` involves conditional logic, which may affect performance if not optimized.\n- **Data Volume**: The procedure's performance may degrade with large volumes of data due to multiple SELECT and DELETE operations.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: The use of temporary tables may lead to contention in high-concurrency environments.\n- **Data Integrity**: If the `Preload.BudgetGroupByFY` table is not up-to-date, it may lead to incorrect exclusion of budget groups.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions and incomplete operations.\n- **Security**: Ensure that the procedure is executed with appropriate permissions to prevent unauthorized data manipulation.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1549,
      "api_response_id": "chatcmpl-C8Vd3zthasqZDO8n9vuD0sCSX4Ds1"
    },
    "analysis_timestamp": "2025-08-25 13:51:13"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorCreate",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorCreate]\r\n\t@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@id AS INT OUTPUT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO input.RateFactor (FY, [Name], [Description], CreatedBy, ModifiedBy)\r\n\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\tVALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.940000",
      "last_altered": "2025-08-25 15:54:05.940000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorCreate` is designed to insert a new record into the `RateFactor` table within the `input` schema. It captures details such as fiscal year, name, description, and the user performing the action. After the insertion, it outputs the newly generated ID of the inserted record.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single insert operation with an output clause to capture the inserted record's ID. It does not involve complex logic, conditional statements, or multiple operations.\n\n#### 3. Input Parameters\n- `@fy AS INT`: Represents the fiscal year for the rate factor.\n- `@name AS VARCHAR(250)`: The name of the rate factor, with a maximum length of 250 characters.\n- `@description AS VARCHAR(500)`: A description of the rate factor, with a maximum length of 500 characters.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system performing the action, defaulting to 'SYSTEM' if not provided.\n- `@id AS INT OUTPUT`: An output parameter that returns the ID of the newly inserted record.\n\n#### 4. Business Logic and Workflow\n1. **SET NOCOUNT ON**: This prevents the sending of DONE_IN_PROC messages to the client for each statement, which can reduce network traffic.\n2. **DECLARE @IdOutput TABLE (ID INT)**: A table variable is declared to temporarily store the ID of the newly inserted record.\n3. **INSERT INTO input.RateFactor**: The procedure inserts a new record into the `RateFactor` table with the provided fiscal year, name, description, and actionBy values for both `CreatedBy` and `ModifiedBy` fields.\n4. **OUTPUT INSERTED.ID INTO @IdOutput**: The `OUTPUT` clause captures the ID of the newly inserted record and stores it in the `@IdOutput` table variable.\n5. **SELECT @id = ID FROM @IdOutput**: The ID from the `@IdOutput` table variable is assigned to the output parameter `@id`, making it available to the calling context.\n\n#### 5. Performance Considerations\n- **SET NOCOUNT ON**: Improves performance by reducing unnecessary network traffic.\n- **Table Variable for ID Capture**: Using a table variable to capture the inserted ID is efficient for this single-row operation.\n- **Simplicity**: The procedure's simplicity ensures minimal overhead and quick execution.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: While the procedure itself is simple, concurrent executions could lead to contention if the `RateFactor` table has constraints or triggers that are not optimized.\n- **Error Handling**: The procedure lacks explicit error handling. If the insert operation fails (e.g., due to constraint violations), the procedure will terminate without providing a meaningful error message to the caller.\n- **Default Value for `@actionBy`**: The default value of 'SYSTEM' may not always be appropriate. It assumes that the action is performed by a system process unless specified otherwise, which might not reflect the actual user context.\n- **Data Type and Length**: Ensure that the input parameters' data types and lengths align with the table's schema to prevent truncation or errors during insertion.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1037,
      "api_response_id": "chatcmpl-C8Vdaha95pZrPGk25zpIszwCZOW9z"
    },
    "analysis_timestamp": "2025-08-25 13:51:24"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorDelete",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorDelete]\r\n\t@id AS INT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDELETE FROM input.RateFactorDetail WHERE RateFactorID = @id;\r\n\tDELETE FROM input.RateFactor WHERE ID = @id;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.940000",
      "last_altered": "2025-08-25 15:54:05.940000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorDelete` is designed to delete records from two tables within the `input` schema: `RateFactorDetail` and `RateFactor`. It takes an `ID` as input and removes the corresponding entries from both tables. This procedure is typically used to maintain data integrity by ensuring that related records in both tables are deleted when a specific `RateFactor` is no longer needed.\n\n#### 2. Complexity Level: Low\nThe complexity level of this stored procedure is low. It performs straightforward delete operations on two tables based on a single input parameter. There are no conditional logic, loops, or complex transactions involved.\n\n#### 3. Input Parameters\n- `@id AS INT`: This parameter represents the unique identifier of the `RateFactor` to be deleted. It is used to locate and remove the corresponding records in both the `RateFactorDetail` and `RateFactor` tables.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter is intended to record who initiated the delete action. However, in the current implementation, it is not utilized within the procedure.\n\n#### 4. Business Logic and Workflow\n1. **Set NOCOUNT ON**: This command prevents the sending of DONE_IN_PROC messages to the client for each statement in a stored procedure, which can reduce network traffic.\n2. **Delete from `RateFactorDetail`**: The procedure first deletes records from the `RateFactorDetail` table where the `RateFactorID` matches the provided `@id`. This ensures that all related detail records are removed before deleting the main record.\n3. **Delete from `RateFactor`**: After removing the related detail records, the procedure deletes the main record from the `RateFactor` table where the `ID` matches the provided `@id`.\n\n#### 5. Performance Considerations\n- **Index Usage**: Ensure that both `RateFactorID` in `RateFactorDetail` and `ID` in `RateFactor` are indexed. This will optimize the delete operations by quickly locating the records to be deleted.\n- **Batch Deletion**: If the tables are large and the procedure is executed frequently, consider implementing batch deletions or archiving strategies to manage performance and reduce locking contention.\n- **NOCOUNT**: The use of `SET NOCOUNT ON` is beneficial in reducing unnecessary network traffic, especially if the procedure is called frequently.\n\n#### 6. Potential Issues or Risks\n- **Foreign Key Constraints**: If there are foreign key constraints involving `RateFactorDetail` or `RateFactor`, ensure that cascading deletes are properly configured, or handle potential constraint violations.\n- **Data Integrity**: Deleting records without proper validation or logging can lead to data integrity issues. Consider implementing logging or audit trails to track deletions.\n- **Unused Parameter**: The `@actionBy` parameter is not used within the procedure. If tracking the user who performs the deletion is necessary, consider implementing logging or modifying the procedure to utilize this parameter.\n- **Concurrency**: If multiple users or processes attempt to delete the same `RateFactor` simultaneously, consider implementing locking mechanisms to prevent race conditions or deadlocks.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 939,
      "api_response_id": "chatcmpl-C8VdmDhAWUQ6xlfUuiSvyQabjyJ5h"
    },
    "analysis_timestamp": "2025-08-25 13:51:37"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorDetailsDelete",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorDetailsDelete]\r\n\t@rateFactorId AS INT\r\n\t,@budgetGroupId AS INT = NULL\r\n\t,@billingPeriod AS INT = NULL\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDELETE FROM input.RateFactorDetail\r\n\tWHERE RateFactorID = @rateFactorId\r\n\t\tAND BudgetGroupID = ISNULL(@budgetGroupId, BudgetGroupID)\r\n\t\tAND BillingPeriod = ISNULL(@billingPeriod, BillingPeriod)\r\n\r\n--------------------------------------------------------------------\r\n-- Update RateFactor and Scenario status if possible\r\n--------------------------------------------------------------------\r\n\t\r\n\tUPDATE input.RateFactor\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @rateFactorId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE RateFactorID = @rateFactorId AND [Status] IN ('CALCULATED');\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.943000",
      "last_altered": "2025-08-25 15:54:05.943000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@rateFactorId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@billingPeriod",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorDetailsDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorDetailsDelete` is designed to delete records from the `RateFactorDetail` table based on specified criteria and subsequently update related records in the `RateFactor` and `Scenario` tables. The procedure is part of a database schema related to budgeting and billing, as indicated by the table and parameter names.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple operations: a conditional delete, updates to two different tables, and the use of default parameter values. While the logic is straightforward, the procedure affects multiple tables and involves conditional logic, which increases its complexity.\n\n#### 3. Input Parameters\n- `@rateFactorId AS INT`: Mandatory. Identifies the specific rate factor record(s) to be deleted and updated.\n- `@budgetGroupId AS INT = NULL`: Optional. Filters the records to be deleted by budget group. If not provided, all records with the specified `RateFactorID` are considered.\n- `@billingPeriod AS INT = NULL`: Optional. Filters the records to be deleted by billing period. If not provided, all records with the specified `RateFactorID` are considered.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: Optional. Specifies the user or system responsible for the modification, defaulting to 'SYSTEM'.\n\n#### 4. Business Logic and Workflow\n1. **Delete Operation**: \n   - Deletes records from `input.RateFactorDetail` where `RateFactorID` matches `@rateFactorId`.\n   - If `@budgetGroupId` is provided, it further filters by `BudgetGroupID`.\n   - If `@billingPeriod` is provided, it further filters by `BillingPeriod`.\n   - Uses `ISNULL` to handle optional parameters, allowing for broader deletion if parameters are not specified.\n\n2. **Update Operations**:\n   - Updates the `ModifiedDate` and `ModifiedBy` fields in the `input.RateFactor` table for the record with the specified `RateFactorID`.\n   - Updates the `Status` field in the `budget.Scenario` table to 'REQUIRERECALC' for records with the specified `RateFactorID` and a current status of 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **Index Usage**: Ensure that `RateFactorID`, `BudgetGroupID`, and `BillingPeriod` are indexed to optimize the delete operation.\n- **Concurrency**: The procedure may cause locking issues if executed frequently or on large datasets, particularly during the delete operation.\n- **Batch Processing**: Consider implementing batch processing if the delete operation affects a large number of records to reduce transaction log growth and locking.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Deleting records from `RateFactorDetail` without corresponding updates or checks in related tables could lead to orphaned records or inconsistent data states.\n- **Error Handling**: The procedure lacks error handling, which could lead to unhandled exceptions and incomplete transactions.\n- **Security**: Ensure that only authorized users can execute this procedure, as it involves data deletion and updates.\n- **Default Values**: The use of default values for `@budgetGroupId` and `@billingPeriod` could lead to broader deletions than intended if not carefully managed.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1095,
      "api_response_id": "chatcmpl-C8VdzO1Xv3MxDgBKQhSnG8yJjMUXZ"
    },
    "analysis_timestamp": "2025-08-25 13:51:52"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorDetailsRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorDetailsRetrieve]\r\n\t@rateFactorId AS INT = NULL\r\n\t,@budgetGroupId AS INT = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT RateFactorID, BudgetGroupID\r\n\tFROM input.vwRateFactorDetailsDistinct\r\n\tWHERE RateFactorID = ISNULL(@rateFactorId, RateFactorID)\r\n\t\tAND BudgetGroupID = ISNULL(@budgetGroupId, BudgetGroupID)\r\n\tORDER BY RateFactorID ASC, BudgetGroupID ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.950000",
      "last_altered": "2025-08-25 15:54:05.950000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@rateFactorId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorDetailsRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorDetailsRetrieve` is designed to retrieve records from a view named `vwRateFactorDetailsDistinct` within the `input` schema. It filters the records based on optional input parameters, `@rateFactorId` and `@budgetGroupId`. The procedure returns a result set containing `RateFactorID` and `BudgetGroupID`, ordered by these columns in ascending order.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a simple SELECT query with optional filtering based on input parameters. It does not include complex logic, joins, or subqueries, making it easy to understand and maintain.\n\n#### 3. Input Parameters\n- `@rateFactorId AS INT = NULL`: This optional parameter allows filtering the result set by a specific `RateFactorID`. If not provided, the procedure retrieves records for all `RateFactorID` values.\n- `@budgetGroupId AS INT = NULL`: This optional parameter allows filtering the result set by a specific `BudgetGroupID`. If not provided, the procedure retrieves records for all `BudgetGroupID` values.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read uncommitted changes from other transactions, which can reduce locking contention but may result in dirty reads.\n- The SELECT statement retrieves `RateFactorID` and `BudgetGroupID` from the `vwRateFactorDetailsDistinct` view.\n- The WHERE clause uses the `ISNULL` function to apply filters based on the input parameters. If a parameter is NULL, the corresponding column is not filtered.\n- The result set is ordered by `RateFactorID` and `BudgetGroupID` in ascending order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead, but it may lead to reading uncommitted or inconsistent data.\n- The use of `ISNULL` in the WHERE clause can prevent the use of indexes on `RateFactorID` and `BudgetGroupID`, potentially leading to full table scans if indexes are not properly designed.\n- The procedure's performance is largely dependent on the underlying view `vwRateFactorDetailsDistinct` and its indexing strategy.\n\n#### 6. Potential Issues or Risks\n- The `READ UNCOMMITTED` isolation level can lead to dirty reads, where the data read by the query might not be committed and could be rolled back later, leading to inconsistencies.\n- The use of `ISNULL` for filtering can impact index utilization, which might degrade performance if the dataset is large and not properly indexed.\n- If the view `vwRateFactorDetailsDistinct` is complex or involves multiple joins, the performance of this procedure could be affected, especially under high load or with large datasets.\n- The procedure does not handle exceptions or errors, which could be a concern if the underlying view or database encounters issues.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 968,
      "api_response_id": "chatcmpl-C8VeDehWHESoz0viHJm3jJ82OTsnt"
    },
    "analysis_timestamp": "2025-08-25 13:52:02"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorDetailsRetrieveBillingPeriodDetails",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorDetailsRetrieveBillingPeriodDetails]\r\n\t@rateFactorId AS INT = NULL\r\n\t,@budgetGroupId AS INT = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT RateFactorID\r\n\t\t,a.BudgetGroupID\r\n\t\t,BillingPeriod\r\n\t\t,CommodityAdder\r\n\t\t,CommodityMultiplier\r\n\t\t,DeliveryMultiplier\r\n\t\t,GRTMultiplier\r\n\t\t,DemandAdjustmentMultiplier\r\n\t\t,b.BudgetGroupName\r\n\tFROM input.vwRateFactorDetails a JOIN preload.BudgetGroup b ON a.BudgetGroupID=b.BudgetGroupID\r\n\tWHERE RateFactorID = ISNULL(@rateFactorId, RateFactorID)\r\n\t\tAND a.BudgetGroupID = ISNULL(@budgetGroupId, a.BudgetGroupID)\r\n\tORDER BY RateFactorID ASC, a.BudgetGroupID ASC, BillingPeriod ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.953000",
      "last_altered": "2025-08-25 15:54:05.953000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@rateFactorId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorDetailsRetrieveBillingPeriodDetails",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorDetailsRetrieveBillingPeriodDetails` is designed to retrieve details related to rate factors and their associated billing periods from a database. It joins data from two sources: a view `vwRateFactorDetails` and a table `BudgetGroup`. The procedure filters results based on optional input parameters for `RateFactorID` and `BudgetGroupID`, and orders the results by `RateFactorID`, `BudgetGroupID`, and `BillingPeriod`.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a simple SELECT query with a JOIN and optional filtering based on input parameters. The complexity is low due to the lack of intricate logic, multiple joins, or complex calculations.\n\n#### 3. Input Parameters\n- `@rateFactorId AS INT = NULL`: This optional parameter allows filtering the results by a specific `RateFactorID`. If not provided, the procedure retrieves records for all `RateFactorID` values.\n- `@budgetGroupId AS INT = NULL`: This optional parameter allows filtering the results by a specific `BudgetGroupID`. If not provided, the procedure retrieves records for all `BudgetGroupID` values.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read uncommitted changes from other transactions, which can reduce locking contention but may result in dirty reads.\n- The main operation is a SELECT statement that retrieves columns from the `vwRateFactorDetails` view and the `BudgetGroup` table.\n- A JOIN operation is performed between `vwRateFactorDetails` and `BudgetGroup` on `BudgetGroupID`.\n- The WHERE clause uses `ISNULL` to apply filters based on the input parameters, defaulting to all records if parameters are not provided.\n- Results are ordered by `RateFactorID`, `BudgetGroupID`, and `BillingPeriod`.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking but at the risk of reading uncommitted data.\n- The procedure's performance largely depends on the indexing of the `vwRateFactorDetails` view and `BudgetGroup` table, particularly on `RateFactorID` and `BudgetGroupID`.\n- The use of `ISNULL` in the WHERE clause can prevent the use of indexes effectively, potentially leading to full table scans if indexes are not properly designed.\n\n#### 6. Potential Issues or Risks\n- The `READ UNCOMMITTED` isolation level can lead to dirty reads, where the data read might not be consistent or committed, which could be problematic depending on the business requirements.\n- The use of `ISNULL` in the WHERE clause can lead to inefficient query plans if indexes are not utilized effectively.\n- If the `vwRateFactorDetails` view or `BudgetGroup` table contains a large amount of data, performance could degrade without proper indexing.\n- The procedure does not handle exceptions or errors, which could lead to unhandled exceptions if issues arise during execution.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1068,
      "api_response_id": "chatcmpl-C8VeNWhAYJ8AxFwXVeG64WsgvcG3r"
    },
    "analysis_timestamp": "2025-08-25 13:52:10"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorDetailsSave",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorDetailsSave]\r\n\t@details AS input.UDT_RateFactorDetail READONLY\r\n\t,@budgetGroupId AS INT = NULL\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @rateFactorID INT;\r\n\r\n\tSELECT @rateFactorID = MAX(RateFactorID)\r\n\tFROM @details;\r\n\t\r\n\tIF @budgetGroupId <> 35 --Edit, then delete old first\r\n\t\tDELETE FROM input.RateFactorDetail\r\n\t\tWHERE RateFactorID = (SELECT DISTINCT RateFactorID FROM @details)\r\n\t\t\t  AND BudgetGroupID = @budgetGroupId;\r\n\r\n\t-- Create temp table with existing base rates for given base rate\r\n\tSELECT RateFactorID, BudgetGroupID, BillingPeriod\r\n\t\t,CommodityAdder, CommodityMultiplier, DeliveryMultiplier, GRTMultiplier, DemandAdjustmentMultiplier\r\n\tINTO #tmpRateFactors\r\n\tFROM input.RateFactorDetail\r\n\tWHERE RateFactorID = (SELECT DISTINCT RateFactorID FROM @details)\r\n\t\tAND BudgetGroupID = (SELECT DISTINCT BudgetGroupID FROM @details);\r\n\r\n\t-- Merge changes FROM input base rates table\r\n\tMERGE #tmpRateFactors AS TARGET\r\n\tUSING @details AS SOURCE\r\n\tON TARGET.RateFactorID = SOURCE.RateFactorID\r\n\t\tAND TARGET.BudgetGroupID = SOURCE.BudgetGroupID\r\n\t\tAND TARGET.BillingPeriod = SOURCE.BillingPeriod\r\n\tWHEN MATCHED THEN\r\n\t\tUPDATE SET\r\n\t\t\tTARGET.CommodityAdder = SOURCE.CommodityAdder, \r\n\t\t\tTARGET.CommodityMultiplier = SOURCE.CommodityMultiplier, \r\n\t\t\tTARGET.DeliveryMultiplier = SOURCE.DeliveryMultiplier, \r\n\t\t\tTARGET.GRTMultiplier = SOURCE.GRTMultiplier, \r\n\t\t\tTARGET.DemandAdjustmentMultiplier = SOURCE.DemandAdjustmentMultiplier\r\n\tWHEN NOT MATCHED BY TARGET THEN\r\n\t\tINSERT (RateFactorID, BudgetGroupID, BillingPeriod, CommodityAdder, CommodityMultiplier\r\n\t\t\t\t,DeliveryMultiplier, GRTMultiplier, DemandAdjustmentMultiplier)\r\n\t\tVALUES (SOURCE.RateFactorID, SOURCE.BudgetGroupID, SOURCE.BillingPeriod, SOURCE.CommodityAdder, SOURCE.CommodityMultiplier\r\n\t\t\t\t,SOURCE.DeliveryMultiplier, SOURCE.GRTMultiplier, SOURCE.DemandAdjustmentMultiplier)\r\n\tWHEN NOT MATCHED BY SOURCE THEN\r\n\t\tDELETE;\r\n\r\n\tDELETE FROM input.RateFactorDetail\r\n\tWHERE RateFactorID = (SELECT DISTINCT RateFactorID FROM @details)\r\n\t\tAND BudgetGroupID = (SELECT DISTINCT BudgetGroupID FROM @details);\r\n\r\n\tINSERT INTO input.RateFactorDetail (RateFactorID, BudgetGroupID, BillingPeriod\r\n\t\t\t,CommodityAdder, CommodityMultiplier, DeliveryMultiplier, GRTMultiplier, DemandAdjustmentMultiplier)\r\n\t\tSELECT RateFactorID, BudgetGroupID, BillingPeriod\r\n\t\t\t,CommodityAdder, CommodityMultiplier, DeliveryMultiplier, GRTMultiplier, DemandAdjustmentMultiplier\r\n\t\tFROM #tmpRateFactors;\r\n\t\r\n--------------------------------------------------------------------\r\n-- Update RateFactor and Scenario status if possible\r\n--------------------------------------------------------------------\r\n\t\r\n\tUPDATE input.RateFactor\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @rateFactorId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE RateFactorID = @rateFactorId AND [Status] IN ('CALCULATED');\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.960000",
      "last_altered": "2025-08-25 15:54:05.960000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@details",
        "data_type": "UDT_RateFactorDetail",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorDetailsSave",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorDetailsSave` is designed to manage the saving and updating of rate factor details in a SQL Server database. It processes a set of rate factor details provided as a table-valued parameter, potentially deletes existing records, merges new or updated data, and updates related records in other tables. The procedure also updates the status of related scenarios to indicate that recalculation is required.\n\n#### 2. Complexity Level: Medium\n\n#### 3. Input Parameters\n- `@details AS input.UDT_RateFactorDetail READONLY`: A table-valued parameter containing the rate factor details to be processed. This parameter is expected to be a user-defined table type that includes columns like `RateFactorID`, `BudgetGroupID`, `BillingPeriod`, `CommodityAdder`, `CommodityMultiplier`, `DeliveryMultiplier`, `GRTMultiplier`, and `DemandAdjustmentMultiplier`.\n- `@budgetGroupId AS INT = NULL`: An optional integer parameter that specifies the budget group ID. It is used to determine whether to delete existing records before inserting new ones.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: An optional string parameter that specifies the user or system performing the action. It defaults to 'SYSTEM' and is used to update the `ModifiedBy` field in the `RateFactor` table.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance.\n\n2. **Determine RateFactorID**: It retrieves the maximum `RateFactorID` from the `@details` parameter to use in subsequent operations.\n\n3. **Conditional Deletion**: If `@budgetGroupId` is not 35, it deletes existing records from `input.RateFactorDetail` where the `RateFactorID` and `BudgetGroupID` match those in `@details`.\n\n4. **Temporary Table Creation**: It creates a temporary table `#tmpRateFactors` to store existing rate factor details for the specified `RateFactorID` and `BudgetGroupID`.\n\n5. **Data Merging**: The procedure uses the `MERGE` statement to synchronize the temporary table with the data in `@details`. It updates existing records, inserts new ones, and deletes records not present in `@details`.\n\n6. **Final Deletion and Insertion**: After merging, it deletes the corresponding records from `input.RateFactorDetail` and inserts the updated data from `#tmpRateFactors`.\n\n7. **Status Update**: It updates the `ModifiedDate` and `ModifiedBy` fields in the `input.RateFactor` table and sets the status of related scenarios in the `budget.Scenario` table to 'REQUIRERECALC' if they are currently 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **Use of Temporary Tables**: The use of a temporary table (`#tmpRateFactors`) can be efficient for handling intermediate data, but it may increase I/O operations if the data set is large.\n- **MERGE Statement**: The `MERGE` statement is efficient for handling insert, update, and delete operations in a single pass, but it can be complex and may have performance implications if not indexed properly.\n- **Indexing**: Ensuring that the `RateFactorDetail` table is properly indexed on `RateFactorID`, `BudgetGroupID`, and `BillingPeriod` can significantly improve the performance of the `MERGE` and `DELETE` operations.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: The procedure does not include explicit transaction handling, which could lead to data inconsistencies if multiple instances of the procedure are executed concurrently.\n- **Error Handling**: There is no error handling mechanism in place, which means that any runtime errors could cause the procedure to fail without logging or rollback.\n- **Assumptions on Data Uniqueness**: The procedure assumes that `RateFactorID` and `BudgetGroupID` are unique within `@details`, which may not be enforced by constraints.\n- **Hardcoded Logic**: The check for `@budgetGroupId <> 35` is hardcoded, which reduces flexibility and may require changes if business rules evolve.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1785,
      "api_response_id": "chatcmpl-C8VeVDvBlFdvb8tAJzICoNv89whmv"
    },
    "analysis_timestamp": "2025-08-25 13:52:23"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorDetailsUpdateByCommonRateFactors",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorDetailsUpdateByCommonRateFactors]\r\n\t@rateFactorID AS INT\r\n\t,@commonRateFactorIDs AS input.UDT_IDList READONLY\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\t\r\n\tDECLARE @ComdtyMult_Desc AS VARCHAR(20) = 'MULT_COMMODITY';\r\n\r\n\tUPDATE input.RateFactorDetail\r\n\tSET CommodityMultiplier = c.multiplier\r\n\tFROM input.CommonRateFactor a JOIN input.CommonRateFactorType b ON a.CommonRateFactorTypeID = b.id\r\n\t\t JOIN input.CommonRateFactorDetail c ON a.id = c.commonRateFactorId\r\n\t\t JOIN input.CommonRateFactorTypeBudgetGroupMapping d ON a.CommonRateFactorTypeID = d.CommonRateFactorTypeID\r\n\tWHERE a.id IN (SELECT ID FROM @commonRateFactorIDs) \r\n\t\t AND b.[description] = @ComdtyMult_Desc\r\n\t\t AND input.RateFactorDetail.RateFactorID = @rateFactorID\r\n\t\t AND d.budgetGroupId = input.RateFactorDetail.budgetGroupId \r\n\t\t AND c.billingPeriod = input.RateFactorDetail.BillingPeriod;\t\r\n\t\r\n\tUPDATE input.RateFactor\r\n\tSET ModifiedBy = @actionBy, ModifiedDate = getdate()\r\n\tWHERE ID = @rateFactorID;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.963000",
      "last_altered": "2025-08-25 15:54:05.963000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@rateFactorID",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@commonRateFactorIDs",
        "data_type": "UDT_IDList",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorDetailsUpdateByCommonRateFactors",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorDetailsUpdateByCommonRateFactors` is designed to update records in the `RateFactorDetail` table based on a set of common rate factors. It also updates the `RateFactor` table to reflect who made the modification and when. The procedure uses a user-defined table type to pass a list of common rate factor IDs, which are used to filter and update the relevant records.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple table joins and updates, which adds to its complexity. The use of a user-defined table type for input and the need to maintain referential integrity across several tables also contribute to its medium complexity level.\n\n#### 3. Input Parameters\n- `@rateFactorID AS INT`: This parameter specifies the ID of the rate factor that needs to be updated in the `RateFactorDetail` table.\n- `@commonRateFactorIDs AS input.UDT_IDList READONLY`: This is a table-valued parameter that contains a list of common rate factor IDs. It is used to filter the records that need to be updated.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter specifies who is performing the update. It defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages to the client, which can improve performance in some scenarios.\n2. **Variable Declaration**: A local variable `@ComdtyMult_Desc` is declared and initialized with the value 'MULT_COMMODITY'. This is used to filter records based on the description in the `CommonRateFactorType` table.\n3. **Update `RateFactorDetail`**: \n   - The procedure updates the `CommodityMultiplier` field in the `RateFactorDetail` table.\n   - It joins the `CommonRateFactor`, `CommonRateFactorType`, `CommonRateFactorDetail`, and `CommonRateFactorTypeBudgetGroupMapping` tables to filter the records.\n   - The update is applied only to records where the `CommonRateFactorType` description matches 'MULT_COMMODITY', the `RateFactorID` matches the provided `@rateFactorID`, and the `budgetGroupId` and `billingPeriod` match between the joined tables and `RateFactorDetail`.\n4. **Update `RateFactor`**:\n   - The `ModifiedBy` and `ModifiedDate` fields in the `RateFactor` table are updated to reflect the user who performed the update and the current date and time.\n\n#### 5. Performance Considerations\n- **Index Usage**: Ensure that the columns used in the WHERE clause and JOIN conditions are indexed to improve query performance.\n- **Table-Valued Parameter**: The use of a table-valued parameter can be efficient for passing multiple IDs, but its performance depends on the size of the data and indexing.\n- **NOCOUNT ON**: This setting can reduce network traffic by suppressing the message that indicates the number of rows affected by a T-SQL statement.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: If multiple users or processes attempt to update the same records simultaneously, it could lead to race conditions or deadlocks.\n- **Data Integrity**: The procedure assumes that the relationships between tables are correctly maintained. Any discrepancies in foreign key relationships could lead to incorrect updates.\n- **Error Handling**: The procedure lacks explicit error handling, which means any runtime errors could cause the procedure to fail without logging or notifying the user.\n- **Hardcoded Values**: The use of a hardcoded description ('MULT_COMMODITY') could lead to maintenance challenges if the business logic changes or if additional descriptions need to be supported.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1281,
      "api_response_id": "chatcmpl-C8Vei52rF19fOL9Rsx7BOpRFe0csy"
    },
    "analysis_timestamp": "2025-08-25 13:52:31"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorsRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorsRetrieve]\r\n\t@fy AS INT = NULL\r\n\t,@id AS INT = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @used AS BIT = 0;\r\n\r\n\tIF @id IS NOT NULL\r\n\t   SELECT @used = CASE WHEN EXISTS (SELECT 1 FROM budget.Scenario s WHERE s.Status = 'CALCULATED' AND s.RateFactorID = @id) THEN 1 ELSE 0 END \r\n\r\n\tSELECT ID\r\n\t\t,[Name]\r\n\t\t,[Description]\r\n\t\t,FY\r\n\t\t,CreatedBy\r\n\t\t,CreatedDate\r\n\t\t,ModifiedBy\r\n\t\t,ModifiedDate\r\n\t\t,Active\r\n\t\t,Locked\r\n\t\t,@used AS UsedByOtherCalculatedScenario \r\n\tFROM input.vwRateFactors\r\n\tWHERE ID = ISNULL(@id, ID) AND FY = ISNULL(@fy, FY)\r\n\tORDER BY FY DESC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.967000",
      "last_altered": "2025-08-25 15:54:05.967000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorsRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorsRetrieve` is designed to retrieve rate factor records from a view named `input.vwRateFactors`. It allows filtering based on fiscal year (`@fy`) and a specific rate factor ID (`@id`). Additionally, it checks if a rate factor is used in any calculated scenarios within the `budget.Scenario` table and includes this information in the result set.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving basic SQL operations such as conditional logic, a simple SELECT query, and the use of a CASE statement. It does not involve complex joins, subqueries, or advanced SQL features.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: Represents the fiscal year. It is optional and defaults to NULL, meaning it will not filter by fiscal year unless specified.\n- `@id AS INT = NULL`: Represents the ID of the rate factor. It is optional and defaults to NULL, meaning it will not filter by ID unless specified.\n\n#### 4. Business Logic and Workflow\n1. **SET NOCOUNT ON**: This prevents the message indicating the number of rows affected by a SQL statement from being returned, which can reduce network traffic.\n2. **SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED**: This allows the procedure to read uncommitted data, which can prevent blocking but may result in reading dirty data.\n3. **Declare @used**: A BIT variable is declared to determine if the rate factor is used in any calculated scenarios.\n4. **Check for Usage**: If `@id` is provided, the procedure checks if the rate factor is used in any scenarios with a status of 'CALCULATED'. If so, `@used` is set to 1.\n5. **Select Query**: Retrieves records from `input.vwRateFactors`, filtering by `@id` and `@fy` if they are provided. The result includes a column `UsedByOtherCalculatedScenario` indicating if the rate factor is used elsewhere.\n6. **Order By**: The results are ordered by fiscal year in descending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: While this isolation level can improve performance by reducing locking, it risks reading uncommitted (dirty) data, which may not be suitable for all applications.\n- **Indexing**: Ensure that `budget.Scenario` and `input.vwRateFactors` have appropriate indexes on columns used in WHERE clauses and joins to optimize query performance.\n- **Conditional Logic**: The use of `ISNULL` in the WHERE clause allows for flexible filtering but may affect index usage, potentially leading to full table scans if not indexed properly.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to reading uncommitted changes, which might not be acceptable in scenarios requiring data accuracy.\n- **NULL Handling**: The use of `ISNULL` in the WHERE clause can lead to unexpected results if not carefully managed, especially if NULL values are present in the data.\n- **Scalability**: As the data grows, the performance of the EXISTS check and the main SELECT query could degrade if not properly indexed.\n- **Concurrency**: While `READ UNCOMMITTED` reduces blocking, it may lead to concurrency issues if other transactions are modifying the data simultaneously.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1127,
      "api_response_id": "chatcmpl-C8VeqSBbWx1ceAfVE4kcs3n48NFyB"
    },
    "analysis_timestamp": "2025-08-25 13:52:42"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorTypesRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorTypesRetrieve]\r\n\t@code AS VARCHAR(25) = null\r\n\t,@type AS CHAR(1) = null\r\n\tWITH EXEC AS CALLER\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSET @type = ISNULL(NULLIF(@type, ''), 'B');\r\n\r\n\tSELECT RateFactorCode, RateFactorDescription, IsMultiplier, DefaultValue, Active\r\n\tFROM input.RateFactorType\r\n\tWHERE 1 = CASE WHEN ISNULL(@code, '') <> '' THEN CASE WHEN RateFactorCode = @code THEN 1 ELSE 0 END ELSE 1 END\r\n\t\tAND 1 = CASE WHEN @type = 'A' AND IsMultiplier = 0 THEN 1 WHEN @type = 'M' AND IsMultiplier = 1 THEN 1 ELSE 1 END\r\n\t\tAND Active = 1\r\n\tORDER BY RateFactorDescription ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.970000",
      "last_altered": "2025-08-25 15:54:05.970000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@code",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@type",
        "data_type": "char",
        "mode": "IN",
        "max_length": 1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorTypesRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorTypesRetrieve` is designed to retrieve records from the `RateFactorType` table within the `input` schema. It filters the records based on optional input parameters `@code` and `@type`, and only returns active records. The procedure is executed with the caller's permissions and uses a non-blocking read isolation level to minimize locking.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving basic SQL constructs such as `SELECT`, `WHERE`, and conditional logic using `CASE` statements. It does not involve complex joins, subqueries, or advanced SQL features, making it relatively simple to understand and maintain.\n\n#### 3. Input Parameters\n- `@code AS VARCHAR(25) = null`: This parameter is used to filter the results by a specific `RateFactorCode`. If not provided, the procedure retrieves records without filtering by code.\n- `@type AS CHAR(1) = null`: This parameter determines the type of rate factors to retrieve. It defaults to 'B' if not specified or if an empty string is provided. The valid values are:\n  - 'A': Retrieves records where `IsMultiplier` is 0.\n  - 'M': Retrieves records where `IsMultiplier` is 1.\n  - 'B': Retrieves all records regardless of `IsMultiplier`.\n\n#### 4. Business Logic and Workflow\n1. **Parameter Handling**: The procedure initializes `@type` to 'B' if it is null or an empty string.\n2. **Transaction Isolation Level**: It sets the transaction isolation level to `READ UNCOMMITTED`, allowing dirty reads to improve performance by avoiding locks.\n3. **Data Retrieval**: The `SELECT` statement retrieves columns `RateFactorCode`, `RateFactorDescription`, `IsMultiplier`, `DefaultValue`, and `Active` from the `RateFactorType` table.\n4. **Filtering Logic**:\n   - If `@code` is provided, it filters the results to match the specified `RateFactorCode`.\n   - It applies additional filtering based on `@type`:\n     - 'A': Filters for records where `IsMultiplier` is 0.\n     - 'M': Filters for records where `IsMultiplier` is 1.\n     - 'B': No additional filtering on `IsMultiplier`.\n   - Only active records (`Active = 1`) are included in the results.\n5. **Ordering**: The results are ordered by `RateFactorDescription` in ascending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED Isolation Level**: This level reduces locking overhead and can improve performance, especially in high-concurrency environments. However, it may lead to reading uncommitted or dirty data.\n- **Indexing**: Performance can be improved if there are appropriate indexes on `RateFactorCode`, `IsMultiplier`, and `Active` columns to support the filtering conditions.\n- **Parameter Sniffing**: The use of parameters can lead to parameter sniffing issues if the distribution of data is skewed. Consider using `OPTION (RECOMPILE)` if this becomes a problem.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can result in reading uncommitted changes, which might not be suitable for all business scenarios.\n- **Parameter Defaults**: The default handling of `@type` might lead to unexpected results if users are unaware that it defaults to 'B'.\n- **Code Maintenance**: The use of `CASE` statements for filtering can make the logic slightly harder to follow, especially if additional conditions are added in the future.\n- **Security**: The procedure executes with the caller's permissions, which is generally safe but requires that the caller has appropriate permissions on the `RateFactorType` table.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1204,
      "api_response_id": "chatcmpl-C8Vf1N7l3YiZ8sgWwLoJwS3gXQbc8"
    },
    "analysis_timestamp": "2025-08-25 13:53:05"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RateFactorUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_RateFactorUpdate]\r\n\t@id AS INT\r\n\t,@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@active AS BIT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tUPDATE input.RateFactor\r\n\tSET FY = @fy\r\n\t\t,[Name] = @name\r\n\t\t,[Description] = @description\r\n\t\t,Active = @active\r\n\t\t,ModifiedBy = @actionBy\r\n\t\t,ModifiedDate = GETDATE()\r\n\tWHERE ID = @id;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.973000",
      "last_altered": "2025-08-25 15:54:05.973000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@active",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RateFactorUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RateFactorUpdate` is designed to update a record in the `RateFactor` table within the `input` schema. It modifies specific fields of a record identified by a unique `ID`. The procedure updates fields such as fiscal year, name, description, active status, and records the user who performed the update along with the current timestamp.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `UPDATE` statement that modifies a record based on a primary key. There are no complex joins, subqueries, or conditional logic, making it easy to understand and maintain.\n\n#### 3. Input Parameters\n- `@id AS INT`: The unique identifier for the record to be updated. It is crucial for locating the specific record in the `RateFactor` table.\n- `@fy AS INT`: Represents the fiscal year to be updated in the record.\n- `@name AS VARCHAR(250)`: The new name for the record, allowing up to 250 characters.\n- `@description AS VARCHAR(500)`: A description of the record, allowing up to 500 characters.\n- `@active AS BIT`: A boolean flag indicating whether the record is active (`1`) or inactive (`0`).\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or system identifier of the person or process making the update. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n1. The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n2. It executes an `UPDATE` statement on the `RateFactor` table:\n   - Updates the fiscal year, name, description, and active status of the record.\n   - Sets `ModifiedBy` to the value of `@actionBy`.\n   - Sets `ModifiedDate` to the current date and time using `GETDATE()`.\n3. The `WHERE` clause ensures that only the record with the specified `ID` is updated.\n\n#### 5. Performance Considerations\n- The procedure's performance is generally efficient due to its simplicity and reliance on a single `UPDATE` statement.\n- The use of `ID` in the `WHERE` clause suggests that `ID` should be a primary key or indexed column, which would optimize the search and update operation.\n- The procedure does not include any transaction handling, which is acceptable given its simplicity, but could be considered if part of a larger transactional operation.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: If multiple users attempt to update the same record simultaneously, it could lead to race conditions. Implementing row versioning or locking mechanisms could mitigate this.\n- **Data Integrity**: There is no validation of input parameters within the procedure. Invalid or malicious input could lead to data integrity issues. Consider adding validation logic or constraints.\n- **Security**: The procedure does not include any security checks or permissions validation. Ensure that only authorized users can execute this procedure to prevent unauthorized data modifications.\n- **Error Handling**: The procedure lacks error handling. Implementing `TRY...CATCH` blocks could help manage exceptions and provide more robust error reporting.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1015,
      "api_response_id": "chatcmpl-C8VfO965MqEDCucq9K3hIloGza4jJ"
    },
    "analysis_timestamp": "2025-08-25 13:53:13"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RetrieveAgencyChangePatternList",
      "definition": "CREATE PROCEDURE [input].[USP_RetrieveAgencyChangePatternList]\r\n(\r\n\t@DEMBudgetGroupId AS INT  = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT a.ID AS PatternId\r\n\t\t,a.[Description] AS PatternDescription\r\n\t\t,b.MM\r\n\t\t,b.DemandUsage\r\n\t\t,b.EnergyUsage\r\n\t\t,b.EnergyPeakPercentage\r\n\t\t,b.EnergyType\r\n\tFROM input.Pattern AS a\r\n\t\tFULL OUTER JOIN input.PatternDetail AS b ON A.ID = B.PatternID\r\n\t\tINNER JOIN EC3DB.Billing_DEMBudgetGroup AS c ON b.EnergyType = c.EnergyDeliveryType\r\n\tWHERE a.Active = 1 AND c.DEMBudgetGroupSeqId = ISNULL(@DEMBudgetGroupId, c.DEMBudgetGroupSeqId)\r\n\tORDER BY a.ID DESC, b.EnergyType ASC, b.MM ASC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:05.977000",
      "last_altered": "2025-08-25 15:54:05.977000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@DEMBudgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RetrieveAgencyChangePatternList",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RetrieveAgencyChangePatternList` is designed to retrieve a list of agency change patterns from a database. It joins data from three tables: `Pattern`, `PatternDetail`, and `Billing_DEMBudgetGroup`. The procedure filters active patterns and optionally filters by a specific DEMBudgetGroupId if provided. The results are ordered by pattern ID, energy type, and month.\n\n#### 2. Complexity Level: Medium\nThe complexity level is considered medium due to the use of multiple joins, including a full outer join, and the conditional filtering based on the input parameter. The procedure also involves setting a specific transaction isolation level, which adds to its complexity.\n\n#### 3. Input Parameters\n- `@DEMBudgetGroupId AS INT = NULL`: This is an optional integer parameter. If provided, it filters the results to include only those records that match the specified DEMBudgetGroupId. If not provided, the procedure defaults to including all DEMBudgetGroupSeqId values.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the message that shows the count of rows affected by a T-SQL statement from being returned.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing dirty reads, which can improve performance by not placing shared locks on the data.\n- The main query selects columns from the `Pattern` and `PatternDetail` tables, joined with the `Billing_DEMBudgetGroup` table.\n- A full outer join is used between `Pattern` and `PatternDetail` to ensure that all records from both tables are included, even if there is no match.\n- An inner join with `Billing_DEMBudgetGroup` ensures that only records with matching energy types are included.\n- The `WHERE` clause filters for active patterns and applies the optional DEMBudgetGroupId filter.\n- The results are ordered by pattern ID in descending order, followed by energy type and month in ascending order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead but at the risk of reading uncommitted or dirty data.\n- The full outer join can be resource-intensive, especially if the tables involved are large, as it requires combining all records from both tables.\n- The procedure's performance may be affected by the presence of indexes on the join and filter columns. Proper indexing can significantly enhance query performance.\n- The use of `ISNULL` in the `WHERE` clause can prevent the use of indexes on `DEMBudgetGroupSeqId`, potentially leading to a full table scan.\n\n#### 6. Potential Issues or Risks\n- The `READ UNCOMMITTED` isolation level can lead to reading uncommitted data, which might not be suitable for all business scenarios, especially where data accuracy is critical.\n- The full outer join may result in a large result set, which could impact performance and lead to increased memory usage.\n- If the `Pattern` or `PatternDetail` tables contain a large number of inactive records, the filtering on `a.Active = 1` might not be efficient without appropriate indexing.\n- The use of `ISNULL` in the `WHERE` clause could lead to suboptimal query plans if not handled correctly by the SQL Server optimizer.\n- The procedure does not handle potential null values in the join columns, which could lead to unexpected results if nulls are present.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1125,
      "api_response_id": "chatcmpl-C8VfWHuhHDWYKDcu1gzxYSWhN4EzH"
    },
    "analysis_timestamp": "2025-08-25 13:53:32"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RetrieveScenarioNamesByAgencyChangeId",
      "definition": "CREATE PROCEDURE [input].[USP_RetrieveScenarioNamesByAgencyChangeId]\r\n\t@AgencyChangeID AS INT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT [Name]  + ' (' + CONVERT(VARCHAR(4), FY) + ')'  AS ScenarioName\r\n\tFROM budget.vwScenarios\r\n\tWHERE AgencyChangeID = @AgencyChangeID\r\n\tORDER BY FY DESC, Name ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.980000",
      "last_altered": "2025-08-25 15:54:05.980000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@AgencyChangeID",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RetrieveScenarioNamesByAgencyChangeId",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RetrieveScenarioNamesByAgencyChangeId` is designed to retrieve scenario names associated with a specific `AgencyChangeID` from the `budget.vwScenarios` view. It formats the scenario names by appending the fiscal year (`FY`) in parentheses to each name. The results are ordered by fiscal year in descending order and by name in ascending order.\n\n#### 2. Complexity Level: Low\nThis stored procedure is straightforward, involving a single SELECT query with a simple WHERE clause and ORDER BY clause. It does not involve any complex logic, joins, or subqueries, making it low in complexity.\n\n#### 3. Input Parameters\n- `@AgencyChangeID AS INT`: This is the sole input parameter, representing the identifier for the agency change. It is used to filter the scenarios in the `vwScenarios` view to only those that match the specified `AgencyChangeID`.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages to the client after each statement, which can improve performance in certain scenarios.\n- The transaction isolation level is set to `READ UNCOMMITTED`, allowing the query to read data that might be in the process of being modified by other transactions. This can reduce blocking but at the risk of reading uncommitted changes.\n- The core logic is a SELECT statement that retrieves and formats scenario names from the `vwScenarios` view. The `Name` is concatenated with the fiscal year (`FY`) converted to a string, enclosed in parentheses.\n- The results are ordered by fiscal year in descending order and by name in ascending order, ensuring that the most recent fiscal years appear first.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking and blocking, but it may lead to dirty reads, where uncommitted changes are visible.\n- The procedure's performance largely depends on the indexing of the `vwScenarios` view, particularly on the `AgencyChangeID` and `FY` columns. Proper indexing can significantly enhance query performance.\n- The concatenation operation and conversion of `FY` to a string are lightweight operations and should not significantly impact performance.\n\n#### 6. Potential Issues or Risks\n- The use of `READ UNCOMMITTED` poses a risk of reading uncommitted or dirty data, which may not be suitable for all business scenarios, especially where data accuracy is critical.\n- If the `vwScenarios` view is large and not properly indexed, the query could become slow, particularly if there are many rows with the same `AgencyChangeID`.\n- The procedure does not handle cases where `AgencyChangeID` does not exist in the view, which might be a concern if the calling application expects a specific response or error handling for such cases.\n- The procedure assumes that the `FY` column is always convertible to a `VARCHAR(4)`, which should be validated to prevent runtime errors if data types change.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 940,
      "api_response_id": "chatcmpl-C8VfpIeLwSXqlzzm9XrV2lhI44iGN"
    },
    "analysis_timestamp": "2025-08-25 13:53:40"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RetrieveScenarioNamesByBaseRateID",
      "definition": "CREATE PROCEDURE [input].[USP_RetrieveScenarioNamesByBaseRateID]\r\n\t@BaseRateID AS INT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT [Name]  + ' (' + CONVERT(VARCHAR(4), FY) + ')'  AS ScenarioName\r\n\tFROM budget.vwScenarios\r\n\tWHERE BaseRateID = @BaseRateID\r\n\tORDER BY FY DESC, Name ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.983000",
      "last_altered": "2025-08-25 15:54:05.983000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@BaseRateID",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RetrieveScenarioNamesByBaseRateID",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RetrieveScenarioNamesByBaseRateID` is designed to retrieve scenario names from a view called `budget.vwScenarios` based on a given `BaseRateID`. It concatenates the scenario name with the fiscal year (FY) in parentheses and orders the results by fiscal year in descending order and by name in ascending order.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SELECT query with a WHERE clause and basic string concatenation. It does not involve complex logic, multiple joins, or subqueries, making it low in complexity.\n\n#### 3. Input Parameters\n- `@BaseRateID AS INT`: This is the sole input parameter, representing the identifier for the base rate. It is used to filter the scenarios in the `vwScenarios` view to only those associated with the specified `BaseRateID`.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read uncommitted changes from other transactions. This can reduce locking contention but at the risk of reading dirty data.\n- The SELECT statement retrieves the `Name` and `FY` columns from the `vwScenarios` view, concatenating them into a single string formatted as \"Name (FY)\".\n- The WHERE clause filters the results to only include rows where `BaseRateID` matches the input parameter.\n- The results are ordered by fiscal year in descending order and by name in ascending order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead, but it may lead to reading uncommitted or dirty data.\n- The procedure's performance largely depends on the indexing of the `vwScenarios` view, particularly on the `BaseRateID`, `Name`, and `FY` columns. Proper indexing can significantly enhance query performance.\n- The concatenation operation and conversion of `FY` to a `VARCHAR` type are lightweight operations and should not significantly impact performance.\n\n#### 6. Potential Issues or Risks\n- The use of `READ UNCOMMITTED` poses a risk of reading dirty data, which may not be suitable for all business scenarios, especially where data accuracy is critical.\n- If the `vwScenarios` view is based on complex queries or joins, the performance might be affected, and the procedure's execution time could increase.\n- The procedure assumes that the `FY` column can be safely converted to a `VARCHAR(4)`. If `FY` contains non-integer values or values exceeding four digits, this could lead to conversion errors or truncation.\n- The procedure does not handle potential exceptions or errors, such as invalid `BaseRateID` values or issues with the underlying view, which could lead to runtime errors without proper logging or error handling mechanisms in place.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 933,
      "api_response_id": "chatcmpl-C8VfyUvZxQTRBG98puLpjA9xJTiEx"
    },
    "analysis_timestamp": "2025-08-25 13:53:50"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RetrieveScenarioNamesByDEMChangeID",
      "definition": "CREATE PROCEDURE [input].[USP_RetrieveScenarioNamesByDEMChangeID]\r\n\t@DEMChangeID AS INT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT [Name]  + ' (' + CONVERT(VARCHAR(4), FY) + ')'  AS ScenarioName\r\n\tFROM budget.vwScenarios\r\n\tWHERE DEMChangeID = @DEMChangeID\r\n\tORDER BY FY DESC, Name ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.987000",
      "last_altered": "2025-08-25 15:54:05.987000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@DEMChangeID",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RetrieveScenarioNamesByDEMChangeID",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RetrieveScenarioNamesByDEMChangeID` is designed to retrieve scenario names from a view named `budget.vwScenarios` based on a specific `DEMChangeID`. It concatenates the scenario name with the fiscal year (FY) in parentheses and orders the results by fiscal year in descending order and by name in ascending order. The procedure uses a read-uncommitted transaction isolation level to minimize locking and blocking.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SELECT statement with a simple WHERE clause and ORDER BY clause. It does not involve complex logic, multiple joins, or subqueries, making it low in complexity.\n\n#### 3. Input Parameters\n- `@DEMChangeID AS INT`: This is the sole input parameter, representing the identifier for a specific DEM change. It is used to filter the scenarios in the `vwScenarios` view to return only those that match the given `DEMChangeID`.\n\n#### 4. Business Logic and Workflow\n- **SET NOCOUNT ON**: This command is used to prevent the message indicating the number of rows affected by a T-SQL statement from being returned. This can reduce network traffic and improve performance slightly.\n- **SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED**: This sets the isolation level to read uncommitted, allowing the procedure to read data that might be in the process of being modified by other transactions. This can reduce locking contention but at the risk of reading uncommitted or \"dirty\" data.\n- **SELECT Statement**: The procedure selects the `Name` field from the `vwScenarios` view, concatenates it with the fiscal year (`FY`), and formats it as `ScenarioName`. The `WHERE` clause filters the records based on the `DEMChangeID` parameter.\n- **ORDER BY Clause**: The results are ordered by fiscal year in descending order and by name in ascending order, ensuring that the most recent fiscal years appear first.\n\n#### 5. Performance Considerations\n- **Read Uncommitted Isolation Level**: While this reduces locking and can improve performance, it may lead to reading uncommitted data, which could be inconsistent or incorrect.\n- **Indexing**: Performance can be significantly improved if there are appropriate indexes on the `DEMChangeID`, `FY`, and `Name` columns in the `vwScenarios` view. This would speed up the filtering and ordering operations.\n- **Network Traffic**: Using `SET NOCOUNT ON` helps reduce unnecessary network traffic by suppressing the \"rows affected\" message.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of the READ UNCOMMITTED isolation level can lead to dirty reads, where the data read might not be committed and could be rolled back, leading to potential inconsistencies.\n- **Data Integrity**: If the `vwScenarios` view is based on complex joins or aggregations, the use of READ UNCOMMITTED might lead to reading partial or inconsistent data sets.\n- **Error Handling**: The procedure lacks error handling mechanisms. If an error occurs during execution, it will not be caught or logged, which could lead to unhandled exceptions.\n- **Scalability**: As the dataset grows, the performance might degrade if the view or underlying tables are not properly indexed, especially given the ordering requirements.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1013,
      "api_response_id": "chatcmpl-C8Vg8xbwoqFj4W8NngnVVy0opRmuj"
    },
    "analysis_timestamp": "2025-08-25 13:54:01"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RetrieveScenarioNamesByProjectChangeID",
      "definition": "CREATE PROCEDURE [input].[USP_RetrieveScenarioNamesByProjectChangeID]\r\n\t@ProjectChangeID AS INT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT [Name]  + ' (' + CONVERT(VARCHAR(4), FY) + ')'  AS ScenarioName\r\n\tFROM budget.vwScenarios\r\n\tWHERE ProjectChangeID = @ProjectChangeID\r\n\tORDER BY FY DESC, Name ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.990000",
      "last_altered": "2025-08-25 15:54:05.990000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@ProjectChangeID",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RetrieveScenarioNamesByProjectChangeID",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RetrieveScenarioNamesByProjectChangeID` is designed to retrieve a list of scenario names associated with a specific project change ID from a view named `budget.vwScenarios`. The procedure formats each scenario name by appending the fiscal year (FY) in parentheses. The results are ordered by fiscal year in descending order and by name in ascending order.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SELECT query with a simple WHERE clause and ORDER BY clause. It does not involve complex logic, multiple joins, or subqueries, which keeps its complexity low.\n\n#### 3. Input Parameters\n- `@ProjectChangeID AS INT`: This is the sole input parameter, representing the unique identifier for a project change. It is used to filter the scenarios in the `vwScenarios` view to only those associated with the specified project change.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic and improve performance slightly.\n- The transaction isolation level is set to `READ UNCOMMITTED`, allowing the query to read uncommitted changes from other transactions. This can reduce blocking but at the risk of reading dirty data.\n- The SELECT statement retrieves the `Name` and `FY` columns from the `vwScenarios` view. It concatenates the `Name` with the fiscal year, formatted as a four-character string, enclosed in parentheses.\n- The WHERE clause filters the results to only include rows where `ProjectChangeID` matches the input parameter.\n- The results are ordered by fiscal year in descending order and by name in ascending order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking and blocking, but it may lead to reading uncommitted or dirty data.\n- The procedure's performance largely depends on the indexing of the `vwScenarios` view, particularly on the `ProjectChangeID` and `FY` columns. Proper indexing can significantly enhance query performance.\n- The concatenation operation and conversion of `FY` to a string are lightweight operations and should not significantly impact performance.\n\n#### 6. Potential Issues or Risks\n- The use of `READ UNCOMMITTED` poses a risk of reading dirty data, which may not be suitable for all business scenarios, especially where data accuracy is critical.\n- If the `vwScenarios` view is not indexed appropriately, particularly on the `ProjectChangeID` column, the query may perform poorly on large datasets.\n- The procedure assumes that the fiscal year (`FY`) is always a valid integer that can be converted to a four-character string. If this assumption is violated, it could lead to conversion errors.\n- The procedure does not handle potential exceptions or errors, such as invalid input parameters or database connectivity issues, which could be addressed with additional error handling logic.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 923,
      "api_response_id": "chatcmpl-C8VgJuHiaj1OIvf4TmnygCS1Cz4AY"
    },
    "analysis_timestamp": "2025-08-25 13:54:11"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RetrieveScenarioNamesByRateFactorID",
      "definition": "CREATE PROCEDURE [input].[USP_RetrieveScenarioNamesByRateFactorID]\r\n\t@RateFactorID AS INT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT [Name]  + ' (' + CONVERT(VARCHAR(4), FY) + ')'  AS ScenarioName\r\n\tFROM budget.vwScenarios\r\n\tWHERE RateFactorID = @RateFactorID\r\n\tORDER BY FY DESC, Name ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.990000",
      "last_altered": "2025-08-25 15:54:05.990000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@RateFactorID",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RetrieveScenarioNamesByRateFactorID",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RetrieveScenarioNamesByRateFactorID` is designed to retrieve scenario names from a view called `budget.vwScenarios` based on a given `RateFactorID`. It constructs a string that combines the scenario name with the fiscal year (FY) in parentheses. The results are ordered by fiscal year in descending order and by name in ascending order.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SELECT query with a WHERE clause and ORDER BY clause. It does not involve complex logic, multiple joins, or subqueries, making it low in complexity.\n\n#### 3. Input Parameters\n- `@RateFactorID AS INT`: This is the sole input parameter for the procedure. It is an integer that specifies the `RateFactorID` used to filter the scenarios in the `vwScenarios` view. The procedure uses this parameter to determine which scenarios to retrieve.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read data without acquiring locks, which can be useful for improving performance in environments where data consistency is not a critical concern.\n- The core logic is a SELECT statement that retrieves and concatenates the `Name` and `FY` fields from the `vwScenarios` view, filtering by the provided `RateFactorID`.\n- The results are ordered by fiscal year in descending order and by name in ascending order, ensuring that the most recent fiscal years appear first.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead, but it may lead to reading uncommitted or \"dirty\" data.\n- The procedure's performance largely depends on the indexing of the `vwScenarios` view, particularly on the `RateFactorID`, `FY`, and `Name` columns. Proper indexing can significantly enhance query performance.\n- The concatenation operation and conversion of `FY` to a `VARCHAR` type are lightweight operations and should not significantly impact performance.\n\n#### 6. Potential Issues or Risks\n- The use of `READ UNCOMMITTED` poses a risk of reading uncommitted data, which can lead to inconsistencies if the underlying data is being modified concurrently.\n- If the `vwScenarios` view is complex or involves multiple joins, the performance might degrade, especially if the view is not properly indexed.\n- The procedure does not handle cases where `RateFactorID` does not exist in the view, which might lead to an empty result set without any indication of an error or issue.\n- The conversion of `FY` to a `VARCHAR(4)` assumes that `FY` is always a four-digit year. If this assumption is violated, it could lead to incorrect formatting or truncation.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 922,
      "api_response_id": "chatcmpl-C8VgS5EToiE5lcW3aIVbGFBq0uFEt"
    },
    "analysis_timestamp": "2025-08-25 13:54:22"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_RetrieveScenarioNamesByTenantChargeID",
      "definition": "CREATE PROCEDURE [input].[USP_RetrieveScenarioNamesByTenantChargeID]\r\n\t@TenantChargeID AS INT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSELECT [Name]  + ' (' + CONVERT(VARCHAR(4), FY) + ')'  AS ScenarioName\r\n\tFROM budget.vwScenarios\r\n\tWHERE TenantChargeID = @TenantChargeID\r\n\tORDER BY FY DESC, Name ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:05.993000",
      "last_altered": "2025-08-25 15:54:05.993000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@TenantChargeID",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RetrieveScenarioNamesByTenantChargeID",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RetrieveScenarioNamesByTenantChargeID` is designed to retrieve scenario names associated with a specific `TenantChargeID` from the `budget.vwScenarios` view. The result set includes scenario names concatenated with their fiscal year in a specific format. The procedure uses a non-blocking read strategy to ensure that it does not lock resources during execution.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single SELECT query with a simple WHERE clause and ORDER BY clause. It does not involve complex logic, multiple joins, or subqueries, making it easy to understand and maintain.\n\n#### 3. Input Parameters\n- `@TenantChargeID AS INT`: This is the sole input parameter for the procedure. It specifies the `TenantChargeID` for which the scenario names are to be retrieved. This parameter is crucial as it filters the results to only those scenarios associated with the given `TenantChargeID`.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic and improve performance.\n- It sets the transaction isolation level to `READ UNCOMMITTED`, allowing the query to read data that might be in the process of being modified by other transactions. This can help reduce locking and blocking issues but at the risk of reading uncommitted or \"dirty\" data.\n- The core logic is a SELECT statement that retrieves scenario names from the `budget.vwScenarios` view. The names are concatenated with the fiscal year (`FY`) in the format `Name (FY)`.\n- The results are filtered by the `TenantChargeID` provided as an input parameter.\n- The results are ordered by fiscal year in descending order and by name in ascending order.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead, but it may lead to reading uncommitted data.\n- The procedure's performance largely depends on the indexing of the `budget.vwScenarios` view, particularly on the `TenantChargeID` and `FY` columns. Proper indexing can significantly enhance query performance.\n- The concatenation operation and conversion of `FY` to a string format are lightweight operations and should not significantly impact performance.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: By using `READ UNCOMMITTED`, the procedure is susceptible to dirty reads, where it might retrieve data that has not been committed yet. This can lead to inconsistencies if the data is being modified concurrently.\n- **Data Integrity**: If the `budget.vwScenarios` view does not have constraints or validations, there might be a risk of retrieving incomplete or incorrect data.\n- **Scalability**: As the dataset grows, the performance might degrade if appropriate indexes are not in place, especially given the ORDER BY clause.\n- **Error Handling**: The procedure lacks error handling mechanisms. If an error occurs during execution, it might not be gracefully managed, potentially leading to incomplete transactions or incorrect application behavior.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 957,
      "api_response_id": "chatcmpl-C8VgdozUqUw04J9xeSbg8m184wwyw"
    },
    "analysis_timestamp": "2025-08-25 13:54:33"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_TenantChargeClone",
      "definition": "CREATE PROCEDURE [input].[USP_TenantChargeClone]\r\n\t@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@id AS INT OUTPUT\r\n\t,@originalId AS INT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO input.TenantCharge (FY, [Name], [Description], CreatedBy, ModifiedBy)\r\n    OUTPUT INSERTED.ID INTO @IdOutput\r\n    VALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\n\r\n\t-----------------------------------------------------------------------------------------------------\r\n    -- get all old DetailID that are associated with the old TenantChargeID\r\n    SELECT [DetailID]\r\n    INTO #TEMP_Detail_ID\r\n    FROM [input].TenantChargeDetail\r\n    WHERE TenantChargeID = @originalId;\r\n\r\n    -- persist the excluded items for return -- Mei 6/30/2017\r\n    SELECT DISTINCT [DetailID], [AgencyCode], [BudgetGroupID]\r\n    INTO #TEMP_Obsolete\r\n    FROM input.TenantChargeDetail\r\n    WHERE [DetailID] IN (SELECT [DetailID] FROM #TEMP_Detail_ID)\r\n          AND\r\n          (\r\n              [AgencyCode] NOT IN\r\n              (\r\n                  SELECT a.AgencyCodeOEC\r\n                  FROM Preload.Agency a INNER JOIN [Preload].[AgencyByFY] abf ON a.AgencyID = abf.AgencyID\r\n                  WHERE abf.FY = @fy\r\n              )\r\n              OR [BudgetGroupID] NOT IN\r\n                 (\r\n                     SELECT [BudgetGroupID] FROM [Preload].[BudgetGroupByFY] WHERE FY = @fy\r\n                 )\r\n          );\r\n\r\n    -- purge #TEMP_Detail_ID to exclude entries with obsolete agencies and budget groups\r\n    DELETE #TEMP_Detail_ID\r\n    WHERE [DetailID] IN (SELECT [DetailID] FROM #TEMP_Obsolete);\r\n    -----------------------------------------------------------------------------------------------------\r\n\r\n\tINSERT INTO input.TenantChargeDetail (TenantChargeID, AgencyCode, BudgetGroupID, ChargePercentage)\r\n\tSELECT @id, AgencyCode, BudgetGroupID, ChargePercentage\r\n\tFROM input.TenantChargeDetail\r\n\tWHERE TenantChargeID = @originalId\r\n\t\t  AND [DetailID] IN (SELECT [DetailID] FROM #TEMP_Detail_ID);\r\n\r\n    SELECT [AgencyCode], [BudgetGroupID]\r\n    FROM #TEMP_Obsolete;\r\n\r\n    DROP TABLE #TEMP_Obsolete, #TEMP_Detail_ID;\r\nEND\r\n",
      "created": "2025-08-25 15:54:06",
      "last_altered": "2025-08-25 15:54:06",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@originalId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TenantChargeClone",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_TenantChargeClone` is designed to clone a tenant charge record from the `TenantCharge` table, along with its associated details from the `TenantChargeDetail` table, for a specified fiscal year. It filters out obsolete agency codes and budget groups based on the provided fiscal year before cloning the details. The procedure returns the ID of the newly created tenant charge and a list of obsolete agency codes and budget groups.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including data insertion, temporary table usage, filtering logic, and output handling. It requires understanding of SQL operations like `INSERT`, `SELECT`, `DELETE`, and `OUTPUT`, as well as temporary table management.\n\n#### 3. Input Parameters\n- `@fy AS INT`: The fiscal year for which the tenant charge is being cloned.\n- `@name AS VARCHAR(250)`: The name of the new tenant charge.\n- `@description AS VARCHAR(500)`: A description for the new tenant charge.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user or system identifier performing the action, defaulting to 'SYSTEM'.\n- `@id AS INT OUTPUT`: An output parameter that returns the ID of the newly created tenant charge.\n- `@originalId AS INT`: The ID of the original tenant charge to be cloned.\n\n#### 4. Business Logic and Workflow\n1. **Insert New Tenant Charge**: A new record is inserted into the `TenantCharge` table with the provided fiscal year, name, description, and actionBy. The ID of the newly inserted record is captured using the `OUTPUT` clause and stored in a table variable `@IdOutput`.\n   \n2. **Retrieve Original Detail IDs**: The procedure selects all `DetailID`s associated with the original tenant charge ID and stores them in a temporary table `#TEMP_Detail_ID`.\n\n3. **Identify Obsolete Details**: It identifies obsolete details by checking if the `AgencyCode` and `BudgetGroupID` are not valid for the specified fiscal year. These obsolete details are stored in another temporary table `#TEMP_Obsolete`.\n\n4. **Filter Out Obsolete Details**: The procedure deletes entries from `#TEMP_Detail_ID` that are considered obsolete based on the previous step.\n\n5. **Clone Valid Details**: It inserts the valid details into the `TenantChargeDetail` table for the new tenant charge ID.\n\n6. **Return Obsolete Details**: The procedure returns the obsolete agency codes and budget groups for further review or logging.\n\n7. **Cleanup**: Temporary tables `#TEMP_Obsolete` and `#TEMP_Detail_ID` are dropped to clean up resources.\n\n#### 5. Performance Considerations\n- **Temporary Tables**: The use of temporary tables can impact performance, especially if the dataset is large. Indexing temporary tables or using table variables could be considered based on the expected data volume.\n- **Subqueries**: The subqueries used to filter obsolete details could be optimized with indexes on the `AgencyCode`, `BudgetGroupID`, and `FY` columns in the respective tables.\n- **Concurrency**: The procedure should be tested for concurrency issues, as multiple executions could lead to contention on temporary table resources.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: If the `Preload.Agency` or `Preload.BudgetGroupByFY` tables are not up-to-date, the procedure might incorrectly identify valid details as obsolete.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions and incomplete operations in case of failures.\n- **Scalability**: As the dataset grows, the performance of the procedure might degrade due to the use of temporary tables and lack of indexing strategies.\n- **Security**: Ensure that the procedure is executed with appropriate permissions to prevent unauthorized data manipulation.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1548,
      "api_response_id": "chatcmpl-C8Vgo6FvRSMFS1EU5pKhcNrOTVlco"
    },
    "analysis_timestamp": "2025-08-25 13:54:46"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_TenantChargeCreate",
      "definition": "CREATE PROCEDURE [input].[USP_TenantChargeCreate]\r\n\t@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@id AS INT OUTPUT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO input.TenantCharge (FY, Name, [Description], CreatedBy, ModifiedBy)\r\n\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\tVALUES (@fy, @name, @description, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\nEND\r\n",
      "created": "2025-08-25 15:54:06.003000",
      "last_altered": "2025-08-25 15:54:06.003000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TenantChargeCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_TenantChargeCreate` is designed to insert a new record into the `TenantCharge` table within the `input` schema. It captures details about a tenant charge, including the fiscal year, name, description, and the user who performed the action. After inserting the record, it outputs the newly generated ID of the inserted record.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single insert operation with an output parameter to capture the ID of the newly inserted record. It does not involve complex logic, conditional statements, or multiple operations.\n\n#### 3. Input Parameters\n- `@fy AS INT`: Represents the fiscal year for the tenant charge.\n- `@name AS VARCHAR(250)`: The name of the tenant charge, with a maximum length of 250 characters.\n- `@description AS VARCHAR(500)`: A description of the tenant charge, with a maximum length of 500 characters.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system performing the action. Defaults to 'SYSTEM' if not provided.\n- `@id AS INT OUTPUT`: An output parameter that returns the ID of the newly inserted tenant charge record.\n\n#### 4. Business Logic and Workflow\n1. The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages to the client, which can improve performance by reducing network traffic.\n2. A table variable `@IdOutput` is declared to temporarily store the ID of the newly inserted record.\n3. An `INSERT` statement is executed to add a new record to the `TenantCharge` table. The `OUTPUT` clause captures the `ID` of the inserted record and stores it in the `@IdOutput` table variable.\n4. The `SELECT` statement retrieves the ID from `@IdOutput` and assigns it to the output parameter `@id`.\n\n#### 5. Performance Considerations\n- The use of `SET NOCOUNT ON` is a good practice to reduce unnecessary network traffic.\n- The procedure performs a single insert operation, which is generally efficient. However, the performance can be affected by factors such as table indexing, constraints, and triggers on the `TenantCharge` table.\n- The use of a table variable to capture the output is efficient for this single-row operation.\n\n#### 6. Potential Issues or Risks\n- The procedure does not include error handling. If the insert operation fails (e.g., due to a constraint violation), the procedure will not provide feedback or handle the error gracefully.\n- There is no validation of input parameters within the procedure. Invalid or unexpected input values could lead to errors or data integrity issues.\n- The default value for `@actionBy` is 'SYSTEM', which may not always be appropriate. If the procedure is called without specifying this parameter, it could lead to inaccurate audit trails.\n- The procedure assumes that the `TenantCharge` table has an `ID` column that is auto-incremented or otherwise generated upon insertion. If this assumption is incorrect, the procedure will fail.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 988,
      "api_response_id": "chatcmpl-C8Vh1vlFlVry9LuPIThc1yy6zwMC9"
    },
    "analysis_timestamp": "2025-08-25 13:54:56"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_TenantChargeDelete",
      "definition": "CREATE PROCEDURE [input].[USP_TenantChargeDelete]\r\n\t@id AS INT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDELETE FROM input.TenantChargeDetail WHERE TenantChargeID = @id;\r\n\tDELETE FROM input.TenantCharge WHERE ID = @id;\r\nEND\r\n",
      "created": "2025-08-25 15:54:06.007000",
      "last_altered": "2025-08-25 15:54:06.007000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TenantChargeDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_TenantChargeDelete` is designed to delete records from two tables: `TenantChargeDetail` and `TenantCharge`, both of which reside in the `input` schema. The procedure takes an identifier for a tenant charge and removes the associated records from these tables. This operation is typically used to maintain data integrity by ensuring that detailed records are removed before or alongside their parent records.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving only two `DELETE` operations. It does not include any conditional logic, loops, or complex transactions, which keeps its complexity low.\n\n#### 3. Input Parameters\n- `@id AS INT`: This parameter represents the unique identifier of the tenant charge to be deleted. It is used to locate and remove the corresponding records in both the `TenantChargeDetail` and `TenantCharge` tables.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter is intended to record who initiated the delete action. It defaults to 'SYSTEM' if not provided. However, in the current implementation, this parameter is not utilized within the procedure.\n\n#### 4. Business Logic and Workflow\n1. **Set NOCOUNT ON**: This command prevents the SQL Server from sending messages about the number of rows affected by the `DELETE` statements, which can reduce network traffic and improve performance slightly.\n2. **Delete from TenantChargeDetail**: The procedure first deletes records from the `TenantChargeDetail` table where the `TenantChargeID` matches the provided `@id`. This ensures that all related detail records are removed before deleting the main record.\n3. **Delete from TenantCharge**: After removing the detail records, the procedure deletes the main record from the `TenantCharge` table where the `ID` matches the provided `@id`.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `TenantChargeID` column in `TenantChargeDetail` and the `ID` column in `TenantCharge` are indexed. This will improve the performance of the `DELETE` operations by speeding up the search for records to delete.\n- **Batch Deletion**: If this procedure is called frequently or with a large number of records, consider implementing batch deletions to manage transaction log growth and reduce locking contention.\n\n#### 6. Potential Issues or Risks\n- **Foreign Key Constraints**: If there are foreign key constraints between `TenantCharge` and `TenantChargeDetail`, ensure that the `DELETE` operations are in the correct order to avoid constraint violations.\n- **Data Integrity**: Deleting records can lead to data integrity issues if not handled carefully. Ensure that there are no orphaned records in other related tables.\n- **Audit and Logging**: The procedure does not currently log deletions or use the `@actionBy` parameter. Consider implementing logging to track who performed deletions and when, which can be crucial for auditing and troubleshooting.\n- **Error Handling**: The procedure lacks error handling. Consider adding `TRY...CATCH` blocks to manage exceptions and ensure that any errors during the deletion process are logged and handled appropriately.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 932,
      "api_response_id": "chatcmpl-C8VhB3eQqNLg6y80mhxWBAqKMvvPq"
    },
    "analysis_timestamp": "2025-08-25 13:55:08"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_TenantChargeDetailCreate",
      "definition": "CREATE PROCEDURE [input].[USP_TenantChargeDetailCreate]\r\n\t@tenantChargeId AS INT\r\n\t,@agencyCode AS VARCHAR(6)\r\n\t,@budgetGroupId AS INT\r\n\t,@chargePercentage AS DECIMAL(10, 5) = 0.0\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@id AS INT OUTPUT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT);\r\n\r\n\tINSERT INTO input.TenantChargeDetail (TenantChargeID, AgencyCode, BudgetGroupID, ChargePercentage)\r\n\tOUTPUT INSERTED.DetailID INTO @IdOutput\r\n\tVALUES (@tenantChargeId, @agencyCode, @budgetGroupId, @chargePercentage);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\n\r\n--------------------------------------------------------------------\r\n-- Update TenantCharge and Scenario status if possible\r\n--------------------------------------------------------------------\r\n\t\r\n\tUPDATE input.TenantCharge\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @tenantChargeId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE TenantChargeID = @tenantChargeId AND [Status] IN ('CALCULATED');\r\nEND\r\n",
      "created": "2025-08-25 15:54:06.010000",
      "last_altered": "2025-08-25 15:54:06.010000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@tenantChargeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyCode",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@chargePercentage",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 9,
        "precision": 10,
        "scale": 5,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TenantChargeDetailCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_TenantChargeDetailCreate` is designed to insert a new record into the `TenantChargeDetail` table and update related records in the `TenantCharge` and `Scenario` tables. It captures the newly inserted record's ID and updates the status of scenarios that require recalculation due to changes in tenant charges.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple operations: an insert with output capturing, and updates to two different tables. While the logic is straightforward, the interaction with multiple tables and the use of output parameters add a moderate level of complexity.\n\n#### 3. Input Parameters\n- `@tenantChargeId AS INT`: Identifies the tenant charge to which the detail record is related.\n- `@agencyCode AS VARCHAR(6)`: Represents the agency code associated with the charge detail.\n- `@budgetGroupId AS INT`: Specifies the budget group ID linked to the charge detail.\n- `@chargePercentage AS DECIMAL(10, 5) = 0.0`: Indicates the percentage of the charge; defaults to 0.0 if not provided.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: Records the user or system that performed the action; defaults to 'SYSTEM'.\n- `@id AS INT OUTPUT`: An output parameter that returns the ID of the newly inserted `TenantChargeDetail` record.\n\n#### 4. Business Logic and Workflow\n1. **Insert Operation**: \n   - A new record is inserted into the `TenantChargeDetail` table with the provided tenant charge ID, agency code, budget group ID, and charge percentage.\n   - The `OUTPUT` clause captures the `DetailID` of the newly inserted record into a table variable `@IdOutput`.\n\n2. **Output Assignment**:\n   - The captured `DetailID` is assigned to the output parameter `@id`.\n\n3. **Update Operations**:\n   - The `TenantCharge` table is updated to reflect the current modification date and the user who performed the action.\n   - The `Scenario` table is updated to set the status to 'REQUIRERECALC' for scenarios associated with the tenant charge that are currently marked as 'CALCULATED'.\n\n#### 5. Performance Considerations\n- **SET NOCOUNT ON**: This reduces network traffic by preventing the sending of DONE_IN_PROC messages for each statement.\n- **Table Variable for Output**: Using a table variable to capture the output of the `INSERT` operation is efficient for handling single-row inserts.\n- **Indexing**: Ensure that the `TenantChargeID` and `Status` columns in the `Scenario` table are indexed to optimize the update operation.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: The procedure does not include any transaction handling, which could lead to issues if multiple users execute it simultaneously, potentially causing race conditions.\n- **Error Handling**: There is no error handling mechanism in place. If any operation fails, it could leave the database in an inconsistent state.\n- **Default Values**: The default value for `@chargePercentage` is 0.0, which might not be appropriate for all business scenarios and could lead to incorrect data if not explicitly set.\n- **Hardcoded Status**: The update to the `Scenario` table assumes that the status 'CALCULATED' is the only one that needs recalculation, which might not cover all business cases.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1169,
      "api_response_id": "chatcmpl-C8VhOrS5syUCY4QZ9igVPeytxC0BL"
    },
    "analysis_timestamp": "2025-08-25 13:55:23"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_TenantChargeDetailsDelete",
      "definition": "CREATE PROCEDURE [input].[USP_TenantChargeDetailsDelete]\r\n\t@id AS INT = NULL\r\n\t,@tenantChargeId AS INT = NULL\r\n\t,@budgetGroupId AS INT = NULL\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSET @id = ISNULL(@id, 0);\r\n\tSET @tenantChargeId = ISNULL(@tenantChargeId, 0);\r\n\tSET @budgetGroupId = ISNULL(@budgetGroupId, 0);\r\n\r\n\tIF @id > 0 OR @tenantChargeId > 0\r\n\t\tDELETE FROM input.TenantChargeDetail\r\n\t\tWHERE DetailID = ISNULL(@id, DetailID)\r\n\t\t\tAND TenantChargeID = ISNULL(@tenantChargeId, TenantChargeID)\r\n\t\t\tAND BudgetGroupID = ISNULL(@budgetGroupId, BudgetGroupID);\r\n\t\r\n--------------------------------------------------------------------\r\n-- Update TenantCharge and Scenario status if possible\r\n--------------------------------------------------------------------\r\n\t\r\n\tUPDATE input.TenantCharge\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @tenantChargeId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE TenantChargeID = @tenantChargeId AND [Status] IN ('CALCULATED');\r\nEND\r\n",
      "created": "2025-08-25 15:54:06.017000",
      "last_altered": "2025-08-25 15:54:06.017000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@tenantChargeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TenantChargeDetailsDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_TenantChargeDetailsDelete` is designed to delete records from the `TenantChargeDetail` table based on provided identifiers. It also updates related records in the `TenantCharge` and `Scenario` tables to reflect changes. The procedure is part of a database schema related to tenant charges, likely used in a property management or financial application.\n\n#### 2. Complexity Level: Medium\nThe procedure involves conditional logic for deletion, updates to multiple tables, and uses default parameter values. While not overly complex, it requires careful handling of input parameters and understanding of the relationships between tables.\n\n#### 3. Input Parameters\n- `@id AS INT = NULL`: Represents the primary key of the `TenantChargeDetail` table. Used to identify a specific record for deletion.\n- `@tenantChargeId AS INT = NULL`: Represents the foreign key linking to the `TenantCharge` table. Used to identify related records for deletion and updates.\n- `@budgetGroupId AS INT = NULL`: Represents a grouping identifier within the `TenantChargeDetail` table. Used to filter records for deletion.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: Indicates the user or system process performing the action, used for auditing purposes in updates.\n\n#### 4. Business Logic and Workflow\n1. **Parameter Initialization**: The procedure initializes the input parameters to zero if they are NULL, ensuring that the subsequent logic can handle them without errors.\n2. **Conditional Deletion**: If either `@id` or `@tenantChargeId` is greater than zero, the procedure deletes records from `TenantChargeDetail` where the `DetailID`, `TenantChargeID`, and `BudgetGroupID` match the provided parameters. The use of `ISNULL` allows for partial filtering based on available parameters.\n3. **Update Operations**:\n   - **TenantCharge Table**: Updates the `ModifiedDate` and `ModifiedBy` fields for the record matching `@tenantChargeId`, indicating a change has occurred.\n   - **Scenario Table**: Changes the `Status` to 'REQUIRERECALC' for records where `TenantChargeID` matches `@tenantChargeId` and the current `Status` is 'CALCULATED', signaling that recalculation is needed due to the deletion.\n\n#### 5. Performance Considerations\n- **Index Usage**: Ensure that `TenantChargeDetail`, `TenantCharge`, and `Scenario` tables have appropriate indexes on `DetailID`, `TenantChargeID`, and `BudgetGroupID` to optimize the DELETE and UPDATE operations.\n- **Batch Processing**: If the procedure is executed frequently or on large datasets, consider implementing batch processing to reduce lock contention and improve performance.\n- **NOCOUNT Setting**: The `SET NOCOUNT ON` statement reduces network traffic by preventing the sending of DONE_IN_PROC messages after each statement.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Deleting records from `TenantChargeDetail` without corresponding updates or checks in related tables could lead to orphaned records or data inconsistencies.\n- **Parameter Defaults**: Defaulting parameters to zero may inadvertently match unintended records if zero is a valid value in the database.\n- **Concurrency**: Simultaneous execution of this procedure could lead to race conditions, especially if multiple users attempt to delete or update the same records.\n- **Audit Trail**: The procedure updates the `ModifiedBy` field, but it does not log deletions. Consider implementing a logging mechanism to track deletions for audit purposes.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions and incomplete transactions. Consider adding TRY...CATCH blocks to manage errors gracefully.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1250,
      "api_response_id": "chatcmpl-C8VhcoNlwzGRwEhyx7y9uF8LoNois"
    },
    "analysis_timestamp": "2025-08-25 13:55:35"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_TenantChargeDetailsRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_TenantChargeDetailsRetrieve]\r\n\t@id AS INT = NULL\r\n\t,@tenantChargeId AS INT = NULL\r\n\t,@budgetGroupId AS INT = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tSET @id = NULLIF(ISNULL(@id, 0), 0);\r\n\tSET @tenantChargeId = NULLIF(ISNULL(@tenantChargeId, 0), 0);\r\n\tSET @budgetGroupId = NULLIF(ISNULL(@budgetGroupId, 0), 0);\r\n\r\n\tSELECT DetailID, TenantChargeID, AgencyCode, BudgetGroupID, ChargePercentage\r\n\tFROM input.vwTenantChargeDetails\r\n\tWHERE DetailID = ISNULL(@id, DetailID)\r\n\t\tAND TenantChargeID = ISNULL(@tenantChargeId, TenantChargeID)\r\n\t\tAND BudgetGroupID = ISNULL(@budgetGroupId, BudgetGroupID)\r\n\tORDER BY BudgetGroupID ASC, AgencyCode ASC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:06.023000",
      "last_altered": "2025-08-25 15:54:06.023000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@tenantChargeId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TenantChargeDetailsRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_TenantChargeDetailsRetrieve` is designed to retrieve tenant charge details from a view named `vwTenantChargeDetails` within the `input` schema. It allows filtering based on three optional parameters: `@id`, `@tenantChargeId`, and `@budgetGroupId`. The procedure returns a result set containing columns such as `DetailID`, `TenantChargeID`, `AgencyCode`, `BudgetGroupID`, and `ChargePercentage`, ordered by `BudgetGroupID` and `AgencyCode`.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving basic SQL operations such as setting variables, handling NULL values, and executing a SELECT query with optional filtering. There are no complex joins, subqueries, or advanced SQL features used.\n\n#### 3. Input Parameters\n- `@id AS INT = NULL`: An optional parameter used to filter results by `DetailID`. If not provided, it defaults to NULL.\n- `@tenantChargeId AS INT = NULL`: An optional parameter used to filter results by `TenantChargeID`. If not provided, it defaults to NULL.\n- `@budgetGroupId AS INT = NULL`: An optional parameter used to filter results by `BudgetGroupID`. If not provided, it defaults to NULL.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting the transaction isolation level to `READ UNCOMMITTED`, which allows reading uncommitted changes from other transactions, potentially improving performance at the cost of data accuracy.\n- It initializes the input parameters to NULL if they are zero or NULL, using the `NULLIF` and `ISNULL` functions. This ensures that zero values are treated as NULL, allowing the query to ignore those filters.\n- The SELECT statement retrieves data from the `vwTenantChargeDetails` view, applying filters based on the input parameters. If a parameter is NULL, the corresponding filter is ignored, allowing for flexible querying.\n- The results are ordered by `BudgetGroupID` and `AgencyCode`.\n\n#### 5. Performance Considerations\n- The use of `READ UNCOMMITTED` can improve performance by reducing locking overhead, but it may lead to reading dirty data.\n- The procedure uses `ISNULL` in the WHERE clause, which can prevent the use of indexes on the filtered columns, potentially leading to full table scans and reduced performance.\n- The view `vwTenantChargeDetails` should be optimized for performance, with appropriate indexing on `DetailID`, `TenantChargeID`, and `BudgetGroupID` to ensure efficient data retrieval.\n\n#### 6. Potential Issues or Risks\n- The `READ UNCOMMITTED` isolation level can lead to dirty reads, where uncommitted changes from other transactions are visible, potentially causing data inconsistencies.\n- The use of `ISNULL` in the WHERE clause can hinder index utilization, impacting query performance, especially on large datasets.\n- If the view `vwTenantChargeDetails` is complex or involves multiple joins, it could affect performance and should be reviewed for optimization.\n- The procedure does not handle exceptions or errors, which could lead to unhandled failures if issues arise during execution.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1068,
      "api_response_id": "chatcmpl-C8Vho3FTAqDM0i8dJoT5G1z3KVtQH"
    },
    "analysis_timestamp": "2025-08-25 13:55:45"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_TenantChargeDetailUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_TenantChargeDetailUpdate]\r\n\t@id AS INT\r\n\t,@agencyCode AS VARCHAR(6)\r\n\t,@budgetGroupId AS INT\r\n\t,@chargePercentage AS DECIMAL(10, 5) = 0.0\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @tenantChargeId AS INT;\r\n\r\n\tSELECT @tenantChargeId = MAX(TenantChargeID)\r\n\tFROM input.TenantChargeDetail\r\n\tWHERE DetailID = @id;\r\n\r\n\tUPDATE input.TenantChargeDetail\r\n\tSET AgencyCode = @agencyCode\r\n\t\t,BudgetGroupID = @budgetGroupId\r\n\t\t,ChargePercentage = @chargePercentage\r\n\tWHERE DetailID = @id;\r\n\t\r\n--------------------------------------------------------------------\r\n-- Update TenantCharge and Scenario status if possible\r\n--------------------------------------------------------------------\r\n\t\r\n\tUPDATE input.TenantCharge\r\n\tSET ModifiedDate = GETDATE(), ModifiedBy = @actionBy\r\n\tWHERE id = @tenantChargeId;\r\n\r\n\tUPDATE budget.Scenario\r\n\tSET [Status] = 'REQUIRERECALC'\r\n\tWHERE TenantChargeID = @tenantChargeId AND [Status] IN ('CALCULATED');\r\nEND\r\n",
      "created": "2025-08-25 15:54:06.030000",
      "last_altered": "2025-08-25 15:54:06.030000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyCode",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@chargePercentage",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 9,
        "precision": 10,
        "scale": 5,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TenantChargeDetailUpdate",
      "explanation": "#### 1. Overview\n\nThe stored procedure `USP_TenantChargeDetailUpdate` is designed to update tenant charge details in a SQL Server database. It modifies records in the `TenantChargeDetail` table based on a given `DetailID`, updates the corresponding `TenantCharge` record's modification metadata, and changes the status of related scenarios in the `Scenario` table if certain conditions are met.\n\n#### 2. Complexity Level: Medium\n\nThe procedure involves multiple updates across different tables and includes conditional logic for updating the `Scenario` table. The complexity is moderate due to the need to maintain data integrity across related tables and the use of conditional updates.\n\n#### 3. Input Parameters\n\n- `@id AS INT`: The identifier for the detail record in the `TenantChargeDetail` table that needs to be updated.\n- `@agencyCode AS VARCHAR(6)`: The new agency code to be set for the specified detail record.\n- `@budgetGroupId AS INT`: The new budget group ID to be set for the specified detail record.\n- `@chargePercentage AS DECIMAL(10, 5) = 0.0`: The new charge percentage to be set for the specified detail record, with a default value of 0.0.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user or system identifier making the update, with a default value of 'SYSTEM'.\n\n#### 4. Business Logic and Workflow\n\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance in certain scenarios.\n\n2. **Retrieve TenantChargeID**: It retrieves the maximum `TenantChargeID` associated with the given `DetailID` from the `TenantChargeDetail` table. This assumes that `DetailID` can be associated with multiple `TenantChargeID` values, and the latest one is needed.\n\n3. **Update TenantChargeDetail**: The procedure updates the `TenantChargeDetail` table with the new `AgencyCode`, `BudgetGroupID`, and `ChargePercentage` for the specified `DetailID`.\n\n4. **Update TenantCharge**: It updates the `ModifiedDate` and `ModifiedBy` fields in the `TenantCharge` table for the retrieved `TenantChargeID`.\n\n5. **Update Scenario Status**: Finally, it updates the `Status` field in the `Scenario` table to 'REQUIRERECALC' for scenarios associated with the `TenantChargeID` that currently have a status of 'CALCULATED'.\n\n#### 5. Performance Considerations\n\n- **Indexing**: Ensure that `DetailID` and `TenantChargeID` are indexed in their respective tables to optimize the SELECT and UPDATE operations.\n- **Concurrency**: The procedure may face concurrency issues if multiple updates are attempted on the same `DetailID` simultaneously. Consider implementing locking mechanisms if necessary.\n- **Batch Processing**: If this procedure is called frequently or in bulk, consider batching updates to reduce transaction overhead.\n\n#### 6. Potential Issues or Risks\n\n- **Data Integrity**: The procedure assumes that the `MAX(TenantChargeID)` logic correctly identifies the relevant record. If `DetailID` is not unique or if the logic for determining the latest `TenantChargeID` is flawed, this could lead to incorrect updates.\n- **Default Values**: The default value for `@chargePercentage` is 0.0, which might unintentionally overwrite existing values if not explicitly set by the caller.\n- **Error Handling**: The procedure lacks error handling. Consider adding TRY...CATCH blocks to manage exceptions and ensure that transactions are rolled back in case of errors.\n- **Status Logic**: The update to the `Scenario` table is conditional on the status being 'CALCULATED'. If other statuses need to trigger a recalculation, this logic may need adjustment.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1253,
      "api_response_id": "chatcmpl-C8Vhy2qxHUL0u1lZkhz0sSmwzH9xh"
    },
    "analysis_timestamp": "2025-08-25 13:56:02"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_TenantChargesRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_TenantChargesRetrieve]\r\n\t@fy AS INT = NULL\r\n\t,@id AS INT = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @used AS BIT = 0;\r\n\r\n\tIF @id IS NOT NULL\r\n\t   SELECT @used = CASE WHEN EXISTS (SELECT 1 FROM budget.Scenario s WHERE s.Status = 'CALCULATED' AND s.TenantChargeID = @id) THEN 1 ELSE 0 END\r\n\r\n\tSELECT ID\r\n\t\t,[Name]\r\n\t\t,[Description]\r\n\t\t,FY\r\n\t\t,CreatedBy\r\n\t\t,CreatedDate\r\n\t\t,ModifiedBy\r\n\t\t,ModifiedDate\r\n\t\t,Active\r\n\t\t,Locked\r\n\t\t,@used AS UsedByOtherCalculatedScenario \r\n\tFROM input.vwTenantCharges\r\n\tWHERE ID = ISNULL(@id, ID) AND FY = ISNULL(@fy, FY)\r\n\tORDER BY FY DESC;\r\nEND\r\n",
      "created": "2025-08-25 15:54:06.037000",
      "last_altered": "2025-08-25 15:54:06.037000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TenantChargesRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_TenantChargesRetrieve` is designed to retrieve tenant charge records from a view named `vwTenantCharges` within the `input` schema. It allows filtering based on fiscal year (`FY`) and tenant charge ID (`ID`). Additionally, it checks if a specific tenant charge ID is used in any calculated scenarios within the `budget.Scenario` table and includes this information in the result set.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving basic SQL operations such as conditional checks, a simple SELECT query, and the use of a CASE statement. It does not involve complex logic, multiple joins, or intricate data transformations.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: This optional parameter allows filtering the results by fiscal year. If not provided, the procedure retrieves records for all fiscal years.\n- `@id AS INT = NULL`: This optional parameter allows filtering the results by a specific tenant charge ID. If not provided, the procedure retrieves records for all IDs.\n\n#### 4. Business Logic and Workflow\n1. **SET NOCOUNT ON**: This command prevents the message indicating the number of rows affected by a SQL statement from being returned, which can reduce network traffic.\n2. **SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED**: This sets the isolation level to READ UNCOMMITTED, allowing dirty reads. It can improve performance by not acquiring shared locks but may result in reading uncommitted data.\n3. **Declare and Initialize `@used`**: A BIT variable `@used` is declared and initialized to 0. This variable is used to determine if the specified tenant charge ID is associated with any calculated scenarios.\n4. **Check for Calculated Scenarios**: If `@id` is not NULL, the procedure checks if there is any entry in the `budget.Scenario` table with a status of 'CALCULATED' for the given `TenantChargeID`. If such an entry exists, `@used` is set to 1.\n5. **Retrieve Tenant Charges**: The procedure selects tenant charge details from the `vwTenantCharges` view, filtering by `ID` and `FY` if provided. It includes the `@used` variable in the result set to indicate if the charge is used by other calculated scenarios.\n6. **Order Results**: The results are ordered by fiscal year in descending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED Isolation Level**: While this can improve performance by reducing locking overhead, it may lead to reading uncommitted or inconsistent data.\n- **Index Usage**: The performance of the SELECT query depends on the indexing of the `vwTenantCharges` view and the `budget.Scenario` table. Proper indexing on `ID`, `FY`, and `TenantChargeID` can enhance query performance.\n- **Conditional Logic**: The use of `ISNULL` in the WHERE clause allows for flexible filtering but may affect index usage and query optimization.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of READ UNCOMMITTED can lead to dirty reads, where the data read might not be committed, potentially causing inconsistencies.\n- **NULL Handling**: The procedure uses `ISNULL` to handle NULL parameters, which can lead to full table scans if indexes are not properly utilized.\n- **Concurrency**: While the procedure is designed to be efficient, concurrent modifications to the `budget.Scenario` table might lead to temporary inconsistencies in the `@used` flag due to the isolation level.\n- **Scalability**: As the data volume grows, the performance might degrade if the underlying tables and views are not optimized with appropriate indexes.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1193,
      "api_response_id": "chatcmpl-C8ViFZr4lYsUZPVzxqiumV4WPTJ1z"
    },
    "analysis_timestamp": "2025-08-25 13:56:16"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_TenantChargeUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_TenantChargeUpdate]\r\n\t@id AS INT\r\n\t,@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@active AS BIT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tUPDATE input.TenantCharge\r\n\tSET FY = @fy\r\n\t\t,[Name] = @name\r\n\t\t,[Description] = @description\r\n\t\t,Active = @active\r\n\t\t,ModifiedBy = @actionBy\r\n\t\t,ModifiedDate = GETDATE()\r\n\tWHERE ID = @id;\r\nEND\r\n",
      "created": "2025-08-25 15:54:06.040000",
      "last_altered": "2025-08-25 15:54:06.040000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@active",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_TenantChargeUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_TenantChargeUpdate` is designed to update records in the `TenantCharge` table within the `input` schema. It modifies specific fields of a record identified by a unique `ID`. The procedure updates fiscal year, name, description, active status, and records the user who performed the update along with the current timestamp.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `UPDATE` statement that modifies a record based on a primary key. It does not include complex logic, conditional statements, or transactions, which keeps the complexity low.\n\n#### 3. Input Parameters\n- `@id AS INT`: The unique identifier for the record in the `TenantCharge` table that needs to be updated.\n- `@fy AS INT`: Represents the fiscal year to be updated in the record.\n- `@name AS VARCHAR(250)`: The new name to be set for the record.\n- `@description AS VARCHAR(500)`: The new description for the record.\n- `@active AS BIT`: A flag indicating whether the record is active (1) or inactive (0).\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system making the update. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can improve performance by reducing network traffic.\n- It performs an `UPDATE` operation on the `TenantCharge` table, setting the fiscal year, name, description, active status, and updating the `ModifiedBy` and `ModifiedDate` fields.\n- The `WHERE` clause ensures that only the record with the specified `ID` is updated.\n- The `ModifiedDate` is set to the current date and time using `GETDATE()`, providing an audit trail of when the update occurred.\n\n#### 5. Performance Considerations\n- The procedure's performance is primarily dependent on the indexing of the `ID` column. Assuming `ID` is a primary key or has an index, the update operation should be efficient.\n- The use of `SET NOCOUNT ON` helps reduce unnecessary network traffic, which can be beneficial in high-transaction environments.\n- The procedure does not handle concurrency issues, such as locking or blocking, which might be a consideration in environments with high write contention.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: If the `ID` provided does not exist in the table, the procedure will not perform any update, but it also does not provide feedback or error handling for such cases.\n- **Concurrency**: The procedure does not include mechanisms to handle concurrent updates, which could lead to lost updates if multiple users attempt to update the same record simultaneously.\n- **Security**: The procedure does not include any checks for user permissions, which could be a risk if executed by unauthorized users.\n- **Default Value for `@actionBy`**: The default value of 'SYSTEM' for `@actionBy` might not always be appropriate, especially if the update is performed by a specific user. This could lead to inaccurate audit trails if not explicitly set by the caller.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1020,
      "api_response_id": "chatcmpl-C8ViTm1vLUIEZDVm7Fi3zFPV90APg"
    },
    "analysis_timestamp": "2025-08-25 13:56:31"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_Tier4RECCreate",
      "definition": "CREATE PROCEDURE [input].[USP_Tier4RECCreate]\r\n(\r\n\t@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@QuantityAlignmentAdjustment AS DECIMAL(5,2)\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n\t,@id AS INT OUTPUT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @IdOutput TABLE (ID INT NOT NULL);\r\n\r\n\tINSERT INTO input.Tier4REC(FY, [Name], [Description], QuantityAlignmentAdjustment, CreatedBy, ModifiedBy)\r\n\tOUTPUT INSERTED.ID INTO @IdOutput\r\n\tVALUES (@fy, @name, @description, @QuantityAlignmentAdjustment, @actionBy, @actionBy);\r\n\r\n\tSELECT @id = ID FROM @IdOutput;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.043000",
      "last_altered": "2025-08-25 15:54:06.043000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@QuantityAlignmentAdjustment",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 5,
        "precision": 5,
        "scale": 2,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@id",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_Tier4RECCreate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_Tier4RECCreate` is designed to insert a new record into the `input.Tier4REC` table. It captures details such as fiscal year, name, description, and a quantity alignment adjustment value. The procedure also records who performed the action, defaulting to 'SYSTEM' if not specified. After insertion, it outputs the newly created record's ID.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single insert operation with an output parameter to return the inserted record's ID. It does not involve complex logic, conditional statements, or multiple table interactions.\n\n#### 3. Input Parameters\n- `@fy AS INT`: Represents the fiscal year for the record.\n- `@name AS VARCHAR(250)`: The name associated with the record.\n- `@description AS VARCHAR(500)`: A description of the record.\n- `@QuantityAlignmentAdjustment AS DECIMAL(5,2)`: A decimal value indicating the quantity alignment adjustment.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The user or system identifier performing the action, defaulting to 'SYSTEM'.\n- `@id AS INT OUTPUT`: An output parameter to capture and return the ID of the newly inserted record.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance by reducing network traffic.\n- A table variable `@IdOutput` is declared to temporarily store the ID of the newly inserted record.\n- An `INSERT` statement adds a new record to the `input.Tier4REC` table with the provided parameters. The `OUTPUT` clause captures the `ID` of the inserted record into `@IdOutput`.\n- The procedure then selects the ID from `@IdOutput` and assigns it to the output parameter `@id`, allowing the calling process to retrieve the new record's ID.\n\n#### 5. Performance Considerations\n- The use of `SET NOCOUNT ON` is a good practice to reduce unnecessary network traffic.\n- The procedure's performance is efficient for its purpose, as it involves a single insert operation and minimal logic.\n- The use of a table variable for capturing the output ID is efficient for small datasets, as it resides in memory.\n\n#### 6. Potential Issues or Risks\n- The procedure does not include error handling. If the insert operation fails, the calling application may not receive adequate feedback.\n- There is no validation of input parameters within the procedure. Invalid or malicious input could lead to data integrity issues.\n- The procedure assumes that the `input.Tier4REC` table has an `ID` column that is auto-incremented or otherwise generated upon insertion. If this assumption is incorrect, the procedure will fail.\n- The default value for `@actionBy` is 'SYSTEM', which may not always be appropriate. Consider requiring explicit user input for better audit trails.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 991,
      "api_response_id": "chatcmpl-C8ViiclSO2fe165Nb8Luz57IeVVX8"
    },
    "analysis_timestamp": "2025-08-25 13:56:39"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_Tier4RECDelete",
      "definition": "CREATE PROCEDURE [input].[USP_Tier4RECDelete]\r\n(\r\n\t@id AS INT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDELETE FROM input.Tier4REC WHERE Id = @id;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.047000",
      "last_altered": "2025-08-25 15:54:06.047000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_Tier4RECDelete",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_Tier4RECDelete` is designed to delete a record from the `Tier4REC` table within the `input` schema of a Microsoft SQL Server database. The procedure takes an identifier for the record to be deleted and an optional parameter indicating who is performing the action, defaulting to 'SYSTEM' if not specified.\n\n#### 2. Complexity Level: Low\nThe complexity level of this stored procedure is low. It performs a straightforward operation: deleting a single record from a table based on a primary key or unique identifier. The logic is simple, with no conditional statements, loops, or complex operations.\n\n#### 3. Input Parameters\n- `@id AS INT`: This parameter is the primary key or unique identifier of the record in the `Tier4REC` table that needs to be deleted. It is a required parameter.\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: This optional parameter specifies the user or system entity performing the delete operation. It defaults to 'SYSTEM' if not provided. Although it is included in the procedure signature, it is not utilized within the procedure body.\n\n#### 4. Business Logic and Workflow\nThe business logic of this procedure is straightforward:\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages to the client, which can improve performance by reducing network traffic.\n- It then executes a `DELETE` statement on the `Tier4REC` table, targeting the record with the `Id` matching the provided `@id` parameter.\n- The procedure does not include any error handling, logging, or additional business logic beyond the deletion operation.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `Id` column in the `Tier4REC` table is indexed, ideally as a primary key or unique index, to optimize the performance of the `DELETE` operation.\n- **NOCOUNT ON**: The use of `SET NOCOUNT ON` is a good practice as it reduces unnecessary network traffic by suppressing the message that indicates the number of rows affected by the `DELETE` statement.\n- **Transaction Management**: The procedure does not explicitly manage transactions. If this procedure is part of a larger transaction, it should be called within an appropriate transaction scope to ensure data integrity.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Deleting records without checking for dependencies or constraints (such as foreign keys) can lead to orphaned records in related tables. Ensure that referential integrity is maintained.\n- **Error Handling**: The procedure lacks error handling. If the `DELETE` operation fails (e.g., due to a foreign key constraint violation), the procedure will terminate with an error. Consider adding TRY...CATCH blocks to handle exceptions gracefully.\n- **Logging and Auditing**: The `@actionBy` parameter is not used within the procedure. If auditing of delete actions is required, consider implementing logging to capture who performed the deletion and when.\n- **Security**: Ensure that appropriate permissions are set on the procedure and the underlying table to prevent unauthorized deletions. Only users with the necessary privileges should be able to execute this procedure.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 933,
      "api_response_id": "chatcmpl-C8VirtCZhbYkoxa5tncy9KvWDUoQf"
    },
    "analysis_timestamp": "2025-08-25 13:56:49"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_Tier4RECRetrieve",
      "definition": "CREATE PROCEDURE [input].[USP_Tier4RECRetrieve]\r\n(\r\n\t@FY AS INT = NULL\r\n\t,@Id AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @IsInUse AS BIT = 0;\r\n\r\n\tIF (@Id IS NOT NULL)\r\n\tBEGIN\r\n\t   SELECT @IsInUse= CASE WHEN EXISTS (SELECT 1 FROM budget.Scenario AS S\r\n\t\t\tINNER JOIN input.Tier4REC AS T ON T.FY = S.FY\r\n\t\tWHERE S.[Status] = 'CALCULATED' AND T.Id = @Id) THEN 1 ELSE 0 END;\r\n\tEND;\r\n\r\n\tSELECT Id\r\n\t\t,[Name]\r\n\t\t,[Description]\r\n\t\t,FY\r\n\t\t,QuantityAlignmentAdjustment\r\n\t\t,CreatedBy\r\n\t\t,CreatedDate\r\n\t\t,ModifiedBy\r\n\t\t,ModifiedDate\r\n\t\t,Active\r\n\t\t,Locked\r\n\t\t,@IsInUse AS UsedByOtherCalculatedScenario\r\n\tFROM input.vwTier4REC\r\n\tWHERE Id = ISNULL(@Id, Id) AND FY = ISNULL(@FY, FY)\r\n\tORDER BY FY DESC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.050000",
      "last_altered": "2025-08-25 15:54:06.050000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@FY",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@Id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_Tier4RECRetrieve",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_Tier4RECRetrieve` is designed to retrieve records from the `input.vwTier4REC` view based on optional fiscal year (`FY`) and identifier (`Id`) parameters. It also checks if a specific record is used in any calculated scenario within the `budget.Scenario` table. The procedure returns a set of columns from the view along with an additional column indicating if the record is used by another calculated scenario.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a simple conditional check and a single SELECT statement. It does not involve complex logic, multiple joins, or nested queries, making it relatively easy to understand and maintain.\n\n#### 3. Input Parameters\n- `@FY AS INT = NULL`: An optional parameter representing the fiscal year. If provided, it filters the records by fiscal year.\n- `@Id AS INT = NULL`: An optional parameter representing the unique identifier of a record. If provided, it filters the records by this identifier.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n2. **Transaction Isolation Level**: It sets the transaction isolation level to `READ UNCOMMITTED`, allowing dirty reads and potentially improving performance by not acquiring shared locks.\n3. **Check Record Usage**: If `@Id` is provided, the procedure checks if the record with this `Id` is used in any scenario with a status of 'CALCULATED' in the `budget.Scenario` table. This is done using an `EXISTS` clause, and the result is stored in the `@IsInUse` variable.\n4. **Data Retrieval**: The procedure retrieves records from the `input.vwTier4REC` view, filtering by `Id` and `FY` if they are provided. It includes an additional column `UsedByOtherCalculatedScenario` to indicate if the record is used in a calculated scenario.\n5. **Ordering**: The results are ordered by fiscal year in descending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: This isolation level can improve performance by reducing locking overhead but may return uncommitted data, leading to potential inconsistencies.\n- **Index Usage**: The performance of the SELECT statement depends on the indexing of the `vwTier4REC` view and the `budget.Scenario` table. Proper indexing on `Id`, `FY`, and `Status` can enhance query performance.\n- **Conditional Logic**: The use of `EXISTS` is efficient for checking the presence of records and should perform well if the `budget.Scenario` table is indexed appropriately.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to reading uncommitted changes, which might not be suitable for all business scenarios, especially where data consistency is critical.\n- **NULL Handling**: The procedure uses `ISNULL` to handle NULL parameters, which is appropriate but assumes that NULL values in the database are not significant for filtering.\n- **Scalability**: As the data grows, the performance might degrade if the underlying tables and views are not indexed properly.\n- **Concurrency**: While `READ UNCOMMITTED` reduces locking, it might lead to concurrency issues if other operations depend on consistent reads.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1182,
      "api_response_id": "chatcmpl-C8Vj0Ep0ZzorVKvvYrw4dLe8ojG9a"
    },
    "analysis_timestamp": "2025-08-25 13:57:04"
  },
  {
    "procedure_info": {
      "schema": "input",
      "name": "USP_Tier4RECUpdate",
      "definition": "CREATE PROCEDURE [input].[USP_Tier4RECUpdate]\r\n(\r\n\t@id AS INT\r\n\t,@fy AS INT\r\n\t,@name AS VARCHAR(250)\r\n\t,@description AS VARCHAR(500)\r\n\t,@QuantityAlignmentAdjustment AS DECIMAL(5,2)\r\n\t,@active AS BIT\r\n\t,@actionBy AS VARCHAR(25) = 'SYSTEM'\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tUPDATE input.Tier4REC\r\n\tSET FY = @fy\r\n\t\t,[Name] = @name\r\n\t\t,[Description] = @description\r\n\t\t,QuantityAlignmentAdjustment = @QuantityAlignmentAdjustment\r\n\t\t,Active\t= @active\r\n\t\t,ModifiedBy\t= @actionBy\r\n\t\t,ModifiedDate = GETDATE()\r\n\tWHERE ID = @id;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.057000",
      "last_altered": "2025-08-25 15:54:06.057000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@id",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@name",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 250,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@description",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 500,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@QuantityAlignmentAdjustment",
        "data_type": "decimal",
        "mode": "IN",
        "max_length": 5,
        "precision": 5,
        "scale": 2,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@active",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 6,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 7,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_Tier4RECUpdate",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_Tier4RECUpdate` is designed to update a record in the `input.Tier4REC` table. It modifies specific fields of a record identified by a unique `ID`. The procedure updates fields such as fiscal year, name, description, quantity alignment adjustment, active status, and records the user who performed the update along with the current timestamp.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `UPDATE` statement with no conditional logic or complex operations. It directly updates a record based on the provided parameters.\n\n#### 3. Input Parameters\n- `@id AS INT`: The unique identifier of the record to be updated in the `Tier4REC` table.\n- `@fy AS INT`: The fiscal year to be set for the record.\n- `@name AS VARCHAR(250)`: The name to be updated in the record.\n- `@description AS VARCHAR(500)`: The description to be updated in the record.\n- `@QuantityAlignmentAdjustment AS DECIMAL(5,2)`: The quantity alignment adjustment value to be updated.\n- `@active AS BIT`: A flag indicating whether the record is active (1) or inactive (0).\n- `@actionBy AS VARCHAR(25) = 'SYSTEM'`: The username or identifier of the person or system making the update. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n- The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can reduce network traffic.\n- It performs an `UPDATE` operation on the `input.Tier4REC` table, setting the specified fields to the values provided by the input parameters.\n- The `ModifiedBy` field is updated with the `@actionBy` parameter, and `ModifiedDate` is set to the current date and time using `GETDATE()`.\n- The update is applied to the record where the `ID` matches the `@id` parameter.\n\n#### 5. Performance Considerations\n- The procedure's performance is primarily dependent on the indexing of the `ID` column in the `Tier4REC` table. An indexed `ID` column will ensure efficient lookups and updates.\n- The use of `SET NOCOUNT ON` is a good practice to reduce unnecessary network traffic, especially in environments where the procedure is called frequently.\n- The procedure does not include any transaction handling, which is acceptable given its simplicity, but could be considered if the procedure were to be expanded.\n\n#### 6. Potential Issues or Risks\n- If the `ID` provided does not exist in the `Tier4REC` table, the procedure will execute without error but will not update any records. This could lead to silent failures if not handled by the calling application.\n- There is no validation of input parameters within the procedure. Invalid or unexpected data types could cause runtime errors or data integrity issues.\n- The procedure assumes that the `ModifiedBy` and `ModifiedDate` fields are present in the `Tier4REC` table. If these fields are missing or have different names, the procedure will fail.\n- The default value for `@actionBy` is 'SYSTEM', which may not be appropriate for all use cases. It is important to ensure that the calling application provides a meaningful value when necessary.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1071,
      "api_response_id": "chatcmpl-C8VjGY2guOkqaCMLcAR5en32MNOyj"
    },
    "analysis_timestamp": "2025-08-25 13:57:14"
  },
  {
    "procedure_info": {
      "schema": "Preload",
      "name": "USP_PreloadAgencies",
      "definition": "CREATE PROCEDURE [Preload].[USP_PreloadAgencies]\r\n(\r\n\t@fy AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSET @fy = ISNULL(@fy, DATEPART(yyyy, GETDATE()) + 1);\r\n\r\n\t-- if the agency list is populated already for the given FY, do not do it again\r\n\tIF (@fy = SOME(SELECT FY FROM Preload.AgencyByFY))\r\n\tBEGIN\r\n\t\tRETURN;\r\n\tEND;\r\n\r\n\tINSERT INTO Preload.Agency(AgencyId,\r\n\t\tAgencyCodeOEC,\r\n\t\tAgencyName,\r\n\t\tAgencyDescription,\r\n\t\tCreatedDate,\r\n\t\tCreatedBy,\r\n\t\tModifiedDate,\r\n\t\tModifiedBy,\r\n\t\tAgencyFundingSeqId,\r\n\t\tFundingSourceDescription)\r\n\tSELECT vw.AgencyId,\r\n\t\tvw.AgencyCodeOEC,\r\n\t\tvw.AgencyName,\r\n\t\tvw.AgencyDescription,\r\n\t\tGETDATE() AS CreatedDate,\r\n\t\t'dbo' AS CreatedBy,\r\n\t\tGETDATE() AS ModifiedDate,\r\n\t\t'dbo' AS ModifiedBy,\r\n\t\tafa.AgencyFundingSeqId,\r\n\t\tfund.FundingSourceDescription\r\n\tFROM EC3DB.BudgetApp_vwAgencies AS vw\r\n\t\tLEFT JOIN EC3DB.Billing_AgencyFundingAssignments AS afa ON vw.AgencyId = afa.AgencyDivisionSeqId\r\n\t\tLEFT JOIN EC3DB.Billing_AgencyFunding AS fund ON afa.AgencyFundingSeqId = fund.AgencyFundingSeqId\r\n\tWHERE vw.Active = 1 AND vw.AgencyId NOT IN (SELECT AgencyId FROM Preload.Agency);\r\n\t\r\n\tINSERT INTO Preload.AgencyByFY(FY, AgencyId)\r\n\tSELECT @fy, AgencyId\r\n\tFROM EC3DB.BudgetApp_vwAgencies\r\n\tWHERE Active = 1;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.060000",
      "last_altered": "2025-08-25 15:54:06.060000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_PreloadAgencies",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_PreloadAgencies` is designed to populate two tables, `Preload.Agency` and `Preload.AgencyByFY`, with data from the `EC3DB.BudgetApp_vwAgencies` view and related tables. It ensures that agency data for a specified fiscal year (FY) is loaded only if it hasn't been loaded already. The procedure uses a default fiscal year based on the current year if none is provided.\n\n#### 2. Complexity Level: Medium\nThe procedure involves conditional logic, multiple table joins, and data insertion operations. While the logic is straightforward, the use of joins and conditional checks adds a moderate level of complexity.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: This parameter represents the fiscal year for which the agency data should be preloaded. If not provided, it defaults to the next calendar year.\n\n#### 4. Business Logic and Workflow\n1. **Set Default Fiscal Year**: If `@fy` is not provided, it defaults to the next calendar year (`DATEPART(yyyy, GETDATE()) + 1`).\n2. **Check Existing Data**: The procedure checks if the `Preload.AgencyByFY` table already contains data for the specified fiscal year. If it does, the procedure exits early to prevent duplicate data loading.\n3. **Insert into Preload.Agency**: \n   - Data is selected from `EC3DB.BudgetApp_vwAgencies` and joined with `EC3DB.Billing_AgencyFundingAssignments` and `EC3DB.Billing_AgencyFunding` to gather additional funding information.\n   - Only active agencies (`vw.Active = 1`) that are not already in `Preload.Agency` are inserted.\n   - The current date and a default user (`'dbo'`) are used for the `CreatedDate`, `CreatedBy`, `ModifiedDate`, and `ModifiedBy` fields.\n4. **Insert into Preload.AgencyByFY**:\n   - Inserts the fiscal year and agency IDs for active agencies into `Preload.AgencyByFY`.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that `Preload.Agency`, `Preload.AgencyByFY`, and the source tables/views have appropriate indexes to optimize the `SELECT` and `INSERT` operations.\n- **Concurrency**: The procedure does not use explicit transaction handling, which could lead to issues if multiple instances run concurrently.\n- **Data Volume**: The performance may degrade with large datasets due to the absence of batch processing or pagination.\n\n#### 6. Potential Issues or Risks\n- **Concurrency Issues**: Without transaction management, concurrent executions could lead to race conditions, especially if the procedure is triggered simultaneously for the same fiscal year.\n- **Data Integrity**: The procedure assumes that the data in `EC3DB.BudgetApp_vwAgencies` and related tables is accurate and consistent. Any discrepancies could lead to incorrect data being loaded.\n- **Scalability**: As the dataset grows, the lack of batch processing could lead to longer execution times and potential timeouts.\n- **Error Handling**: The procedure lacks error handling mechanisms, which could result in unhandled exceptions and incomplete data loads in case of failures.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1272,
      "api_response_id": "chatcmpl-C8VjQYqdj1z77Gm44500VhEARvya6"
    },
    "analysis_timestamp": "2025-08-25 13:57:29"
  },
  {
    "procedure_info": {
      "schema": "Preload",
      "name": "USP_PreloadBillingPeriod",
      "definition": "CREATE PROCEDURE [Preload].[USP_PreloadBillingPeriod]\r\n(\r\n\t@fy AS INT = NULL\r\n\t,@actionBy AS VARCHAR(25) = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSET @fy = ISNULL(@fy, DATEPART(yyyy, GETDATE()) + 1);\r\n\tSET @actionBy = ISNULL(@actionBy, 'SYSTEM');\r\n\r\n\tINSERT INTO Preload.BillingPeriod\r\n\t\t(BudgetBillingPeriod,\r\n\t\tBillingPeriod,\r\n\t\tCreatedDate,\r\n\t\tCreatedBy)\r\n\tSELECT CASE WHEN SUBSTRING(BillingPeriod, 5, 2) > '06' THEN BillingPeriod + 100\r\n\t\tELSE BillingPeriod + 200 END AS BudgetBillingPeriod,\r\n\t\tBillingPeriod,\r\n\t\tGETDATE() AS CreatedDate,\r\n\t\t@actionBy AS CreatedBy\r\n\tFROM EC3DB.Factors_DegreeDayBase\r\n\tWHERE CONVERT(INT, SUBSTRING(BillingPeriod, 1, 4)) = @fy - 2\r\n\t\tAND BillingPeriod NOT IN (SELECT BillingPeriod FROM Preload.BillingPeriod);\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.063000",
      "last_altered": "2025-08-25 15:54:06.063000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_PreloadBillingPeriod",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_PreloadBillingPeriod` is designed to populate the `Preload.BillingPeriod` table with billing period data derived from the `EC3DB.Factors_DegreeDayBase` table. It calculates a new `BudgetBillingPeriod` based on existing `BillingPeriod` values, ensuring that only unique entries are inserted. The procedure defaults to using the next fiscal year and a default action by user if not provided.\n\n#### 2. Complexity Level: Medium\nThe procedure involves conditional logic for calculating a new field, uses default parameter values, and performs a subquery to ensure uniqueness, which adds moderate complexity. The logic is straightforward but requires understanding of date manipulation and subquery filtering.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: Represents the fiscal year for which the billing periods are to be preloaded. If not provided, it defaults to the next calendar year.\n- `@actionBy AS VARCHAR(25) = NULL`: Indicates the user or system responsible for the action. Defaults to 'SYSTEM' if not specified.\n\n#### 4. Business Logic and Workflow\n1. **Default Parameter Handling**: \n   - If `@fy` is not provided, it defaults to the next calendar year.\n   - If `@actionBy` is not provided, it defaults to 'SYSTEM'.\n   \n2. **Data Insertion**:\n   - The procedure inserts data into `Preload.BillingPeriod` with the following fields:\n     - `BudgetBillingPeriod`: Calculated based on the `BillingPeriod`. If the month part of `BillingPeriod` is greater than '06', 100 is added; otherwise, 200 is added.\n     - `BillingPeriod`: Directly taken from `EC3DB.Factors_DegreeDayBase`.\n     - `CreatedDate`: Set to the current date and time.\n     - `CreatedBy`: Set to the value of `@actionBy`.\n   \n3. **Filtering Logic**:\n   - The `BillingPeriod` is selected from `EC3DB.Factors_DegreeDayBase` where the year part matches `@fy - 2`.\n   - Ensures that only `BillingPeriod` values not already present in `Preload.BillingPeriod` are inserted.\n\n#### 5. Performance Considerations\n- **Subquery for Uniqueness**: The subquery `(SELECT BillingPeriod FROM Preload.BillingPeriod)` could become a performance bottleneck if `Preload.BillingPeriod` is large. Indexing on `BillingPeriod` could mitigate this.\n- **Date Manipulation**: The use of `SUBSTRING` and `CONVERT` functions for date manipulation is efficient for small datasets but could be optimized for larger datasets.\n- **Default Value Calculation**: The default calculation for `@fy` involves a simple date function, which is efficient.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: If `EC3DB.Factors_DegreeDayBase` contains malformed `BillingPeriod` values, the `SUBSTRING` and `CONVERT` operations could fail.\n- **Concurrency**: If multiple instances of this procedure run simultaneously, there could be race conditions leading to duplicate entries unless proper transaction isolation levels are set.\n- **Scalability**: As the dataset grows, the performance of the subquery checking for existing `BillingPeriod` entries could degrade without proper indexing.\n- **Hardcoded Logic**: The logic for determining `BudgetBillingPeriod` is hardcoded, which may not adapt well to changes in business rules without modifying the procedure.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1178,
      "api_response_id": "chatcmpl-C8VjefMVUi4PaYPQ3ztbKtMmxaHmV"
    },
    "analysis_timestamp": "2025-08-25 13:57:44"
  },
  {
    "procedure_info": {
      "schema": "Preload",
      "name": "USP_PreloadBudgetGroup",
      "definition": "CREATE PROCEDURE [Preload].[USP_PreloadBudgetGroup]\r\n(\r\n\t@fy AS INT = NULL\r\n\t,@actionBy AS VARCHAR(25) = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSET @fy = ISNULL(@fy, DATEPART(yyyy, GETDATE()) + 1);\r\n\tSET @actionBy = ISNULL(@actionBy, 'SYSTEM');\r\n\r\n\t-- if the Budget Group list is populated already for the given FY, do not do it again\r\n\tIF (@fy = SOME(SELECT FY FROM Preload.BudgetGroupByFY))\r\n\tBEGIN\r\n\t\tRETURN;\r\n\tEND;\r\n\r\n\tINSERT INTO Preload.BudgetGroup\r\n\t\t(BudgetGroupID,\r\n\t\tBudgetGroupName,\r\n\t\tBudgetGroupDescription,\r\n\t\tEnergyType,\r\n\t\tEnergyUnit,\r\n\t\tCreatedDate,\r\n\t\tCreatedBy,\r\n\t\tModifiedDate,\r\n\t\tModifiedBy)\r\n\tSELECT BudgetGroupID,\r\n\t\tBudgetGroupName,\r\n\t\tBudgetGroupDescription,\r\n\t\tEnergyType,\r\n\t\tCASE WHEN EnergyType = 'STM' THEN 'Mlbs'\r\n\t\t\tWHEN EnergyType = 'GAS' THEN 'therms'\r\n\t\t\tWHEN EnergyType = 'CHW' THEN 'Mlbs'\r\n\t\t\tELSE 'kWh' END EnergyUnit,\r\n\t\tGETDATE() AS CreatedDate,\r\n\t\t@actionBy AS CreatedBy,\r\n\t\tGETDATE() AS ModifiedDate,\r\n\t\t@actionBy AS ModifiedBy\r\n\tFROM EC3DB.BudgetApp_vwBudgetGroups\r\n\tWHERE Active = 1 AND BudgetGroupID NOT IN (SELECT BudgetGroupID FROM Preload.BudgetGroup);\r\n\t\r\n\r\n\tINSERT INTO Preload.BudgetGroupByFY (FY, BudgetGroupID)\r\n\tSELECT @fy, BudgetGroupID\r\n\tFROM EC3DB.BudgetApp_vwBudgetGroups\r\n\tWHERE Active = 1;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.067000",
      "last_altered": "2025-08-25 15:54:06.067000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_PreloadBudgetGroup",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_PreloadBudgetGroup` is designed to preload budget group data into a specific schema (`Preload`) for a given fiscal year (`FY`). It checks if the budget group data for the specified fiscal year is already populated in the `Preload.BudgetGroupByFY` table. If not, it inserts new budget group records from a view (`EC3DB.BudgetApp_vwBudgetGroups`) into the `Preload.BudgetGroup` table and associates them with the fiscal year in the `Preload.BudgetGroupByFY` table.\n\n#### 2. Complexity Level: Medium\nThe procedure involves conditional logic, data transformation, and multiple insert operations. It interacts with two tables and a view, making it moderately complex due to the need for ensuring data integrity and handling potential duplicates.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: Represents the fiscal year for which the budget group data is to be preloaded. If not provided, it defaults to the next calendar year.\n- `@actionBy AS VARCHAR(25) = NULL`: Represents the user or system identifier performing the action. Defaults to 'SYSTEM' if not specified.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: \n   - The procedure sets `@fy` to the next calendar year if it is not provided.\n   - Sets `@actionBy` to 'SYSTEM' if not provided.\n\n2. **Check for Existing Data**:\n   - It checks if the budget group data for the specified fiscal year already exists in `Preload.BudgetGroupByFY`. If it does, the procedure exits early to prevent duplicate data loading.\n\n3. **Data Insertion**:\n   - **Insert into `Preload.BudgetGroup`**: \n     - Selects active budget groups from `EC3DB.BudgetApp_vwBudgetGroups` that are not already in `Preload.BudgetGroup`.\n     - Transforms the `EnergyType` to determine the `EnergyUnit`.\n     - Inserts the selected data along with the current date and `@actionBy` as the creator and modifier.\n\n   - **Insert into `Preload.BudgetGroupByFY`**:\n     - Associates each budget group with the specified fiscal year by inserting into `Preload.BudgetGroupByFY`.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that `Preload.BudgetGroupByFY` and `Preload.BudgetGroup` have appropriate indexes on `FY` and `BudgetGroupID` to optimize the `SELECT` and `INSERT` operations.\n- **Concurrency**: The procedure does not include explicit transaction handling, which could lead to issues in a high-concurrency environment.\n- **View Performance**: The performance of the `EC3DB.BudgetApp_vwBudgetGroups` view can impact the procedure, especially if it involves complex joins or aggregations.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: The procedure assumes that `BudgetGroupID` is unique and consistent across the view and the `Preload.BudgetGroup` table. Any discrepancies could lead to data integrity issues.\n- **Concurrency**: Without explicit transaction management, there is a risk of race conditions if multiple instances of the procedure run simultaneously.\n- **Default Values**: The use of default values for `@fy` and `@actionBy` could lead to unintended data loading if not carefully managed.\n- **Error Handling**: The procedure lacks error handling, which could result in unhandled exceptions and partial data loads in case of failures.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1338,
      "api_response_id": "chatcmpl-C8Vjt9OFGr03rRWDM3bEHibjJu9qI"
    },
    "analysis_timestamp": "2025-08-25 13:57:55"
  },
  {
    "procedure_info": {
      "schema": "Preload",
      "name": "USP_PreloadDegreeDay",
      "definition": "CREATE PROCEDURE [Preload].[USP_PreloadDegreeDay]\r\n(\r\n\t@fy AS INT = NULL\r\n\t,@actionBy AS VARCHAR(25) = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tSET @fy = ISNULL(@fy, DATEPART(yyyy, GETDATE()) + 1);\r\n\tSET @actionBy = ISNULL(@actionBy, 'SYSTEM');\r\n\r\n\tDELETE Preload.DegreeDay\r\n\tWHERE BillingPeriod / 100 = @fy - 2;\r\n\r\n\tINSERT INTO Preload.DegreeDay\r\n\t\t(BillingPeriod,\r\n\t\t[MonthName],\r\n\t\tActualCoolingDegreeDays,\r\n\t\tActualHeatingDegreeDays,\r\n\t\tNormalCoolingDegreeDays,\r\n\t\tNormalHeatingDegreeDays,\r\n\t\tCreatedDate,\r\n\t\tCreatedBy,\r\n\t\tModifiedDate,\r\n\t\tModifiedBy)\r\n\tSELECT CONVERT(INT, ddb.BillingPeriod),\r\n\t\thist.[MonthName],\r\n\t\tddb.BaseCoolingDegreeDays,\r\n\t\tddb.BaseHeatingDegreeDays,\r\n\t\thist.NormalCoolingDegreeDays,\r\n\t\thist.NormalHeatingDegreeDays,\r\n\t\tGETDATE() AS CreatedDate,\r\n\t\t@actionBy AS CreatedBy,\r\n\t\tGETDATE() AS ModifiedDate,\r\n\t\t@actionBy AS ModifiedBy\r\n\tFROM EC3DB.Factors_DegreeDayBase AS ddb\r\n\t\tINNER JOIN EC3DB.Factors_DegreeDayNormalized30YearAverage AS hist ON ddb.MM = hist.MM\r\n\tWHERE CONVERT(INT, SUBSTRING(ddb.BillingPeriod, 1, 4)) = @fy - 2;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.070000",
      "last_altered": "2025-08-25 15:54:06.070000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_PreloadDegreeDay",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_PreloadDegreeDay` is designed to manage data related to degree days, which are used in energy consumption analysis. It operates within the `Preload` schema and primarily interacts with the `Preload.DegreeDay` table. The procedure deletes old records and inserts new ones based on data from two external tables: `EC3DB.Factors_DegreeDayBase` and `EC3DB.Factors_DegreeDayNormalized30YearAverage`. The procedure targets data from two fiscal years prior to the current or specified year.\n\n#### 2. Complexity Level: Medium\nThe complexity is considered medium due to the following factors:\n- It involves conditional logic for setting default parameter values.\n- It performs both DELETE and INSERT operations.\n- It includes a JOIN operation between two tables.\n- It uses date manipulation and conversion functions.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: Represents the fiscal year. If not provided, it defaults to the next calendar year (`DATEPART(yyyy, GETDATE()) + 1`).\n- `@actionBy AS VARCHAR(25) = NULL`: Represents the user or system performing the action. Defaults to 'SYSTEM' if not specified.\n\n#### 4. Business Logic and Workflow\n1. **Parameter Initialization**: \n   - If `@fy` is not provided, it defaults to the next calendar year.\n   - If `@actionBy` is not provided, it defaults to 'SYSTEM'.\n\n2. **Data Deletion**:\n   - Deletes records from `Preload.DegreeDay` where the `BillingPeriod` corresponds to two fiscal years prior to the specified or default fiscal year (`@fy - 2`).\n\n3. **Data Insertion**:\n   - Inserts new records into `Preload.DegreeDay` by selecting data from `EC3DB.Factors_DegreeDayBase` and `EC3DB.Factors_DegreeDayNormalized30YearAverage`.\n   - The selection is based on matching the fiscal year two years prior (`@fy - 2`).\n   - The `BillingPeriod` is converted to an integer, and the `MonthName` and degree day values are retrieved.\n   - Timestamps and user information are recorded for auditing purposes.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that `BillingPeriod` in `Preload.DegreeDay` and `EC3DB.Factors_DegreeDayBase` is indexed to optimize DELETE and SELECT operations.\n- **Batch Processing**: If the dataset is large, consider batching the DELETE and INSERT operations to manage transaction log growth and reduce locking.\n- **Concurrency**: The procedure may cause locking issues due to DELETE operations. Consider using transaction isolation levels or row versioning if concurrency is a concern.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: The DELETE operation removes all records for a specific fiscal year without archiving. Ensure that this data is not needed elsewhere or is backed up.\n- **Parameter Defaults**: The default fiscal year calculation (`DATEPART(yyyy, GETDATE()) + 1`) assumes the fiscal year aligns with the calendar year. This may not be accurate for all organizations.\n- **Error Handling**: The procedure lacks error handling. Consider adding TRY...CATCH blocks to manage exceptions and log errors.\n- **Hardcoded Values**: The procedure uses hardcoded logic for fiscal year calculations, which may require updates if business rules change.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1251,
      "api_response_id": "chatcmpl-C8Vk4APbQ2XTKnArQlTL2x0j7FHA6"
    },
    "analysis_timestamp": "2025-08-25 13:58:11"
  },
  {
    "procedure_info": {
      "schema": "Preload",
      "name": "USP_PreloadEC3BaseData",
      "definition": "CREATE PROCEDURE [Preload].[USP_PreloadEC3BaseData]\r\n(\r\n\t@fy AS INT = NULL\r\n\t,@publishedMonth AS INT\r\n\t,@actionBy AS VARCHAR(25) = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @baseYear AS INT, @createdDate AS DATETIME = GETDATE(), @streetLightingBudgetGroupDEM AS INT = 7, @excessDistBudgetGroupDEMs AS input.UDT_IDList\r\n\t\t,@pollutionBudgetGroupDEMs AS input.UDT_IDList, @streetLightingBudgetGroupDEMs AS input.UDT_IDList, @TranName AS VARCHAR(20) = 'TransEC3BaseData'\r\n\t\t,@errMsg AS VARCHAR(255);\r\n\r\n\tSELECT @fy = ISNULL(@fy, DATEPART(yyyy, GETDATE())+1), @actionBy = ISNULL(@actionBy, 'SYSTEM');\r\n\t-- Why is this 2 years prior by default\r\n\t-- We should pull in the selected base year here\r\n\tSET @baseYear = @fy-2;\r\n\r\n\tINSERT INTO @excessDistBudgetGroupDEMs (ID) VALUES (15), (48);\r\n\tINSERT INTO @pollutionBudgetGroupDEMs (ID) VALUES (5), (6);\r\n\tINSERT INTO @streetLightingBudgetGroupDEMs (ID) VALUES (7), (21);\r\n\r\n\tBEGIN TRY\r\n\t\tBEGIN TRAN @TranName;\r\n\r\n\t\t-- 1. check Preload.DegreeDay and Preload.BudgetGroup tables\r\n\t\tIF NOT EXISTS (SELECT 1 FROM Preload.DegreeDay WHERE BillingPeriod/100 = @baseYear)\r\n\t\tBEGIN\r\n\t\t\tSET @errMsg = CONCAT('There is no ', CAST(@baseYear AS VARCHAR(4)), '(BaseYear) data in Preload.DegreeDay table.');\r\n\t\t\tTHROW 88001, @errMsg, 1;\r\n\t\tEND;\r\n\r\n\t\tIF NOT EXISTS (SELECT 1 FROM Preload.BudgetGroupByFY WHERE FY = @fy)\r\n\t\tBEGIN\r\n\t\t\tSET @errMsg = CONCAT('There is no ', CAST(@fy AS VARCHAR(4)), '(FY) data in Preload.BudgetGroup table.');\r\n\t\t\tTHROW 88002, @errMsg, 1;\r\n\t\tEND;\r\n\r\n\t\t-- 2. delete previous preload\r\n\t\tDELETE FROM Preload.EC3BaseData WHERE FY = @fy;\r\n\r\n\t\t-- 3. insert FROM EC3 Database.Published.AccountLevelRawDataForCurrentPeriod\r\n\t\tWITH preloadTbl AS(SELECT ep.BillingPeriod\r\n\t\t\t,ep.AgencyCodeOEC\r\n\t\t\t,ep.BillingCycle\r\n\t\t\t,ep.UtilityCompany\r\n\t\t\t,ep.UtilityCompanySeqId\r\n\t\t\t,ep.IsTimeOfDayAccount\r\n\t\t\t,ep.CurrentAccountNumber\r\n\t\t\t,ep.DeliveryTariffRate\r\n\t\t\t,ep.EnergyUnit\r\n\t\t\t,ep.EnergyType AS EnergyType\r\n\t\t\t,ep.BudgetGroupDEM AS BudgetGroupDEM\r\n\t\t\t,ep.RevisedBilledAmount\r\n\t\t\t,CASE WHEN ep.EnergyUnit = 'GALLON' THEN 50.00 * ep.AccountEnergyUsage\r\n\t\t\t\tELSE ep.AccountEnergyUsage END AS AccountEnergyUsage\r\n\t\t\t,ISNULL(ep.AccountDemandUsage, 0) AS AccountDemandUsage\r\n\t\t\t,ISNULL(ep.OnPeakEnergyUsage, 0) AS OnPeakEnergyUsage\r\n\t\t\t,ISNULL(ep.OffPeakEnergyUsage, 0) AS OffPeakEnergyUsage\r\n\t\t\t,ISNULL(ep.RevisedReactivePowerDollars, 0) AS RevisedReactivePowerDollars\r\n\t\t\t,ISNULL(ep.AccountReactivePowerEnergy, 0) AS AccountReactivePowerEnergy\r\n\t\t\t,ep.IsMinimumBilledCharged\r\n\t\t\t,ISNULL(ep.MinimumBilledDemandDollars, 0) AS MinimumBilledDemandDollars\r\n\t\t\t,ISNULL(ep.MinimumBilledDemandUsage, 0) AS MinimumBilledDemandUsage\r\n\t\t\t,ep.IsDeliveryMinimumBilledFlag\r\n\t\t\t,ISNULL(ep.DeliveryMinimumBilledAmount, 0) AS DeliveryMinimumBilledAmount\r\n\t\t\t,ISNULL(ep.DeliveryMinimumBilledDemand, 0) AS DeliveryMinimumBilledDemand\r\n\t\t\t,ISNULL(ep.MinimumBilledEnergyDollars, 0) AS MinimumBilledEnergyDollars\r\n\t\t\t,ISNULL(ep.MinimumBilledEnergyUsage, 0) AS MinimumBilledEnergyUsage\r\n\t\t\t,ISNULL(ep.StreetLightingFacilityPoints, 0) AS DeliveryStreetLightingFacilityPoints\r\n\t\t\t,ISNULL(ep.CustomerLevelAdjustmentAmount, 0) AS CustomerLevelAdjustmentAmount\r\n\t\t\t,ISNULL(ep.CommodityAllocationCharge, 0) AS CommodityAllocationCharge\r\n\t\t\t,ISNULL(ep.DeliveryAllocationCharge, 0) AS DeliveryAllocationCharge\r\n\t\tFROM EC3DB.Published_AccountLevelRawDataForCurrentPeriod AS ep\r\n\t\t\tINNER JOIN EC3DB.Billing_UtilityTariffRateInformation AS euti ON ep.UtilityTariffRateInformationSeqId = euti.UtilityTariffRateInformationSeqId\r\n\t\tWHERE (SUBSTRING(ep.BillingPeriod, 1, 4) = CAST(@baseYear AS VARCHAR(4)))\r\n\t\t\tAND ep.AccountStatus NOT IN ('28'))\r\n\r\n\t\tINSERT INTO Preload.EC3BaseData(AgencyCodeOEC\r\n\t\t\t,BudgetGroupDEM\r\n\t\t\t,BillingPeriod\r\n\t\t\t,BaseEnergyUsage\r\n\t\t\t,BaseDemandUsage\r\n\t\t\t,BaseBilledDollars\r\n\t\t\t,NumberOfDistinctAccounts\r\n\t\t\t,AdditionalProductionDemandUnitsBilled\r\n\t\t\t,AdditionalDeliveryDemandUnitsBilled\r\n\t\t\t,Additional062MinimumBilledEnergyUsageUnits\r\n\t\t\t,BaseOnPeakEnergyUsage\r\n\t\t\t,BaseOffPeakEnergyUsage\r\n\t\t\t,BaseAccountReactivePowerEnergy\r\n\t\t\t,DeliveryStreetLightingFacilityPoints\r\n\t\t\t,StreetLightingFacilityPoints\r\n\t\t\t,CommodityAllocationChargeAdder\r\n\t\t\t,DeliveryAllocationChargeAdder\r\n\t\t\t,IsNotBilled\r\n\t\t\t,CreatedDate\r\n\t\t\t,CreatedBy)\r\n\t\tSELECT AgencyCodeOEC\r\n\t\t\t,BudgetGroupDEM\r\n\t\t\t,BillingPeriod\r\n\t\t\t,SUM(AccountEnergyUsage) AS EnergyUsage\r\n\t\t\t,SUM(ISNULL(AccountDemandUsage, 0)) AS DemandUsage\r\n\t\t\t,SUM(RevisedBilledAmount) AS BilledDollars\r\n\t\t\t,COUNT(DISTINCT CurrentAccountNumber) AS NumberOfDistinctAccounts\r\n\t\t\t,SUM(CASE WHEN IsMinimumBilledCharged = 'Y' THEN MinimumBilledDemandUsage - ISNULL(AccountDemandUsage, 0)\r\n\t\t\t\tELSE 0 END) AS AdditionalProductionDemandUnitsBilled\r\n\t\t\t,SUM(CASE WHEN IsDeliveryMinimumBilledFlag = 'Y' THEN DeliveryMinimumBilledDemand - ISNULL(AccountDemandUsage, 0)\r\n\t\t\t\tELSE 0 END) AS AdditionalDeliveryDemandUnitsBilled\r\n\t\t\t,SUM(CASE WHEN DeliveryTariffRate = '062' AND (50 - ISNULL(AccountEnergyUsage, 0) > 0) THEN 50 - ISNULL(AccountEnergyUsage, 0)\r\n\t\t\t\tELSE 0 END) AS Additional062MinimumBilledEnergyUsageUnits\r\n\t\t\t,SUM(OnPeakEnergyUsage) AS OnPeakEnergyUsage\r\n\t\t\t,SUM(OffPeakEnergyUsage) AS OffPeakEnergyUsage\r\n\t\t\t,SUM(AccountReactivePowerEnergy) AS BaseAccountReactivePowerEnergy\r\n\t\t\t,SUM(ISNULL(DeliveryStreetLightingFacilityPoints, 0)) AS DeliveryStreetLightingFacilityPoints\r\n\t\t\t,0 AS StreetLightingFacilityPoints\r\n\t\t\t,SUM(ISNULL(CustomerLevelAdjustmentAmount, 0) + ISNULL(CommodityAllocationCharge, 0)) AS CommodityAllocationChargeAdder\r\n\t\t\t,SUM(ISNULL(DeliveryAllocationCharge, 0)) AS DeliveryAllocationChargeAdder\r\n\t\t\t,0 AS IsNotBilled\r\n\t\t\t,@createdDate\r\n\t\t\t,@actionBy\r\n\t\tFROM preloadTbl\r\n\t\tGROUP BY AgencyCodeOEC, BudgetGroupDEM, BillingPeriod;\r\n\r\n\t\t-- 4. Insert Missing billing records for existing Agency-BudgetGroups\r\n\t\tWITH notBilledAgcBGrpTbl AS(SELECT AgencyCodeOEC, BudgetGroupDEM\r\n\t\t\tFROM preload.ec3basedata\r\n\t\t\tWHERE FY = @fy\r\n\t\t\tGROUP BY AgencyCodeOEC, BudgetGroupDEM\r\n\t\t\tHAVING COUNT(1) < 12)\r\n\t\t,billingPeriodTbl AS (SELECT DISTINCT BillingPeriod\r\n\t\t\tFROM Preload.EC3BaseData\r\n\t\t\tWHERE FY = @fy)\r\n\t\t,notBilledAgcBGrpBillingPrdTbl AS (SELECT N.AgencyCodeOEC, N.BudgetGroupDEM, A.BillingPeriod\r\n\t\t\tFROM notBilledAgcBGrpTbl AS N CROSS JOIN billingPeriodTbl AS A\r\n\t\t\tEXCEPT SELECT a.AgencyCodeOEC, a.BudgetGroupDEM, a.BillingPeriod\r\n\t\t\tFROM preload.ec3basedata AS a\r\n\t\t\t\tINNER JOIN notBilledAgcBGrpTbl AS b ON a.AgencyCodeOEC = b.AgencyCodeOEC AND a.BudgetGroupDEM = b.BudgetGroupDEM\r\n\t\t\tWHERE a.FY = @fy)\r\n\t\tINSERT INTO Preload.EC3BaseData(AgencyCodeOEC\r\n\t\t\t,BudgetGroupDEM\r\n\t\t\t,BillingPeriod\r\n\t\t\t,BaseEnergyUsage\r\n\t\t\t,BaseDemandUsage\r\n\t\t\t,BaseBilledDollars\r\n\t\t\t,NumberOfDistinctAccounts\r\n\t\t\t,AdditionalProductionDemandUnitsBilled\r\n\t\t\t,AdditionalDeliveryDemandUnitsBilled\r\n\t\t\t,Additional062MinimumBilledEnergyUsageUnits\r\n\t\t\t,BaseOnPeakEnergyUsage\r\n\t\t\t,BaseOffPeakEnergyUsage\r\n\t\t\t,BaseAccountReactivePowerEnergy\r\n\t\t\t,DeliveryStreetLightingFacilityPoints\r\n\t\t\t,StreetLightingFacilityPoints\r\n\t\t\t,CommodityAllocationChargeAdder\r\n\t\t\t,DeliveryAllocationChargeAdder\r\n\t\t\t,IsNotBilled\r\n\t\t\t,CreatedDate\r\n\t\t\t,CreatedBy)\r\n\t\tSELECT AgencyCodeOEC\r\n\t\t\t,BudgetGroupDEM\r\n\t\t\t,BillingPeriod\r\n\t\t\t,0 AS EnergyUsage\r\n\t\t\t,0 AS DemandUsage\r\n\t\t\t,0 AS BilledDollars\r\n\t\t\t,1 AS NumberOfDistinctAccounts\r\n\t\t\t,0 AS AdditionalProductionDemandUnitsBilled\r\n\t\t\t,0 AS AdditionalDeliveryDemandUnitsBilled\r\n\t\t\t,0 AS Additional062MinimumBilledEnergyUsageUnits\r\n\t\t\t,0 AS OnPeakEnergyUsage\r\n\t\t\t,0 AS OffPeakEnergyUsage\r\n\t\t\t,0 AS BaseAccountReactivePowerEnergy\r\n\t\t\t,0 AS DeliveryStreetLightingFacilityPoints\r\n\t\t\t,0 AS StreetLightingFacilityPoints\r\n\t\t\t,0 AS CommodityAllocationChargeAdder\r\n\t\t\t,0 AS DeliveryAllocationChargeAdder\r\n\t\t\t,1 AS IsNotBilled\r\n\t\t\t,@createdDate\r\n\t\t\t,@actionBy\r\n\t\tFROM notBilledAgcBGrpBillingPrdTbl;\r\n\r\n\t\t-- 5. Update StreetLightingFacilityPoints\r\n\t\tUPDATE B\r\n\t\tSET B.StreetLightingFacilityPoints = S.DeliveryStreetLightingFacilityPoints\r\n\t\tFROM Preload.EC3BaseData AS B\r\n\t\t\tINNER JOIN (SELECT Eab.BillingPeriodRevision, SUM(eabe.DeliveryStreetLightingFacilityPoints) AS DeliveryStreetLightingFacilityPoints\r\n\t\t\tFROM EC3DB.Billing_AccountBilling AS Eab\r\n\t\t\t\tINNER JOIN EC3DB.Billing_AccountBillingElectric AS eabe ON Eab.AccountBillingSeqId = eabe.MonthlyAccountBillingChargesElectric\r\n\t\t\tWHERE SUBSTRING(Eab.BillingPeriodRevision, 1, 4) = CAST(@baseYear AS VARCHAR(4))\r\n\t\t\tGROUP BY Eab.BillingPeriodRevision) AS S ON B.BillingPeriod%100 = CAST(S.BillingPeriodRevision AS INT)%100\r\n\t\tWHERE B.FY = @fy\r\n\t\t\tAND B.BudgetGroupDEM = @streetLightingBudgetGroupDEM;\r\n\r\n\t\t-- 6. Normalize Usages\r\n\t\tWITH minTbl AS(SELECT a.PreloadBillingDataSeqId\r\n\t\t\t\t,c.EnergyType\r\n\t\t\t\t,b.IsHeatingDegreeDayPeriod\r\n\t\t\t\t,b.NormalCoolingDegreeDays\r\n\t\t\t\t,b.NormalHeatingDegreeDays\r\n\t\t\t\t,b.ActualCoolingDegreeDays\r\n\t\t\t\t,b.ActualHeatingDegreeDays\r\n\t\t\t\t,MIN(ISNULL(a.BaseDemandUsage, 0)) OVER (PARTITION BY a.AgencyCodeOEC, a.BudgetGroupDEM) AS MinimumBaseDemandUsage\r\n\t\t\t\t,MIN(ISNULL(a.BaseOnPeakEnergyUsage, 0)) OVER (PARTITION BY a.AgencyCodeOEC, a.BudgetGroupDEM) AS MinimumBaseOnPeakEnergyUsage\r\n\t\t\t\t,MIN(ISNULL(a.BaseOffPeakEnergyUsage, 0)) OVER (PARTITION BY a.AgencyCodeOEC, a.BudgetGroupDEM) AS MinimumBaseOffPeakEnergyUsage\r\n\t\t\tFROM Preload.EC3BaseData AS a\r\n\t\t\t\tINNER JOIN Preload.DegreeDay AS b ON a.billingperiod = b.billingperiod\r\n\t\t\t\tINNER JOIN Preload.BudgetGroup AS c ON a.BudgetGroupDEM = c.BudgetGroupID\r\n\t\t\tWHERE a.FY = @fy)\r\n\t\tUPDATE B\r\n\t\tSET\tNormalizedOnPeakEnergyUsage =\r\n\t\t\tCASE WHEN B.BudgetGroupDEM IN (SELECT ID FROM @pollutionBudgetGroupDEMs UNION SELECT ID FROM @streetLightingBudgetGroupDEMs) THEN ISNULL(B.BaseOnPeakEnergyUsage, 0)\r\n\t\t\tELSE CASE WHEN C.IsHeatingDegreeDayPeriod = 'Y' AND C.EnergyType IN ('GAS', 'STM') AND C.NormalHeatingDegreeDays <> 0\r\n\t\t\t\t\tTHEN ((B.BaseOnPeakEnergyUsage - C.MinimumBaseOnPeakEnergyUsage) * (C.NormalHeatingDegreeDays * 1.00 / C.ActualHeatingDegreeDays) + C.MinimumBaseOnPeakEnergyUsage)\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'Y' AND C.EnergyType IN ('GAS', 'STM') AND C.NormalHeatingDegreeDays = 0 THEN B.BaseOnPeakEnergyUsage\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'N' AND C.EnergyType IN ('GAS', 'STM') THEN B.BaseOnPeakEnergyUsage\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod\t= 'N' AND C.EnergyType IN ('ELE', 'CHW') AND C.NormalCoolingDegreeDays <> 0\r\n\t\t\t\tTHEN ((B.BaseOnPeakEnergyUsage - C.MinimumBaseOnPeakEnergyUsage) * (C.NormalCoolingDegreeDays * 1.00 / C.ActualCoolingDegreeDays) + C.MinimumBaseOnPeakEnergyUsage)\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'N' AND C.EnergyType IN ('ELE', 'CHW') AND C.NormalCoolingDegreeDays = 0 THEN B.BaseOnPeakEnergyUsage\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'Y' AND C.EnergyType IN ('ELE', 'CHW') THEN B.BaseOnPeakEnergyUsage\r\n\t\t\t\tELSE -9999999999 END\r\n\t\t\tEND\r\n\t\t\t,NormalizedOffPeakEnergyUsage =\r\n\t\t\tCASE WHEN B.BudgetGroupDEM IN (SELECT ID FROM @pollutionBudgetGroupDEMs UNION SELECT ID FROM @streetLightingBudgetGroupDEMs) THEN ISNULL(B.BaseOffPeakEnergyUsage, 0)\r\n\t\t\tELSE CASE WHEN C.IsHeatingDegreeDayPeriod = 'Y' AND C.EnergyType IN ('GAS', 'STM') AND C.NormalHeatingDegreeDays <> 0\r\n\t\t\t\t\tTHEN ((B.BaseOffPeakEnergyUsage - C.MinimumBaseOffPeakEnergyUsage) * (C.NormalHeatingDegreeDays * 1.00 / C.ActualHeatingDegreeDays) + C.MinimumBaseOffPeakEnergyUsage)\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'Y' AND C.EnergyType IN ('GAS', 'STM') AND C.NormalHeatingDegreeDays = 0 THEN B.BaseOffPeakEnergyUsage\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'N' AND C.EnergyType IN ('GAS', 'STM') THEN B.BaseOffPeakEnergyUsage\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'N' AND C.EnergyType IN ('ELE', 'CHW')\r\n\t\t\t\t\tTHEN ((B.BaseOffPeakEnergyUsage - C.MinimumBaseOffPeakEnergyUsage) * (C.NormalCoolingDegreeDays * 1.00 / C.ActualCoolingDegreeDays) + C.MinimumBaseOffPeakEnergyUsage)\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'Y' AND C.EnergyType IN ('ELE', 'CHW') THEN B.BaseOffPeakEnergyUsage\r\n\t\t\t\tELSE -9999999999 END\r\n\t\t\tEND\r\n\t\t\t,NormalizedDemandUsage =\r\n\t\t\tCASE WHEN B.BudgetGroupDEM IN (SELECT ID FROM @pollutionBudgetGroupDEMs UNION SELECT ID FROM @streetLightingBudgetGroupDEMs) THEN ISNULL(B.BaseDemandUsage, 0)\r\n\t\t\tELSE CASE WHEN C.EnergyType IN ('GAS', 'STM')  THEN ISNULL(B.BaseDemandUsage, 0)\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'N' AND C.EnergyType IN ('ELE', 'CHW') AND C.NormalCoolingDegreeDays <> 0\r\n\t\t\t\t\tTHEN ((ISNULL(B.BaseDemandUsage, 0) - ISNULL(C.MinimumBaseDemandUsage, 0)) * (C.NormalCoolingDegreeDays * 1.00 / C.ActualCoolingDegreeDays) + ISNULL(C.MinimumBaseDemandUsage, 0))\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'N' AND C.EnergyType IN ('ELE', 'CHW') AND C.NormalCoolingDegreeDays = 0  THEN ISNULL(B.BaseDemandUsage, 0)\r\n\t\t\t\tWHEN C.IsHeatingDegreeDayPeriod = 'Y' AND C.EnergyType IN ('ELE', 'CHW') THEN ISNULL(B.BaseDemandUsage, 0)\r\n\t\t\t\tELSE -9999999999 END\r\n\t\t\tEND\r\n\t\tFROM Preload.EC3BaseData AS B\r\n\t\t\tINNER JOIN minTbl AS C ON C.PreloadBillingDataSeqid = B.PreloadBillingDataSeqid\r\n\t\tWHERE B.FY = @fy AND B.BudgetGroupDEM NOT IN (SELECT ID FROM @excessDistBudgetGroupDEMs);\r\n\t\t\r\n\t\t-- 7. Special handling for NormalizedEnergyUsage and NormalizedAccountReactivePowerEnergy Columns\r\n\t\tUPDATE Preload.EC3BaseData\r\n\t\tSET NormalizedEnergyUsage = CASE WHEN BudgetGroupDEM IN (SELECT ID FROM @pollutionBudgetGroupDEMs UNION SELECT ID FROM @streetLightingBudgetGroupDEMs) THEN ISNULL(BaseEnergyUsage, 0)\r\n\t\t\t\tELSE NormalizedOnPeakEnergyUsage + NormalizedOffPeakEnergyUsage END\r\n\t\t\t,NormalizedAccountReactivePowerEnergy = BaseAccountReactivePowerEnergy\r\n\t\tWHERE FY = @fy AND BudgetGroupDEM NOT IN (SELECT ID FROM @excessDistBudgetGroupDEMs);\r\n\r\n\t\tCOMMIT TRAN @TranName;\r\n\r\n\t\tSELECT COUNT(1) AS Preload_EC3BaseData_RowCount, COUNT(1)/12 AS Agency_BudgetGroup_Pair_Count FROM Preload.EC3BaseData WHERE FY = @fy;\r\n\tEND TRY\r\n\tBEGIN CATCH\r\n\t    SELECT ERROR_NUMBER() AS ErrorNumber, ERROR_STATE() AS ErrorState, ERROR_MESSAGE() AS ErrorMessage, ERROR_LINE () AS ErrorLine;\r\n\r\n\t\tIF (@@TRANCOUNT > 0)\r\n\t\tBEGIN\r\n\t\t\tROLLBACK TRAN @TranName;\r\n\t\tEND;\r\n\tEND CATCH;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.087000",
      "last_altered": "2025-08-25 15:54:06.087000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@publishedMonth",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_PreloadEC3BaseData",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_PreloadEC3BaseData` is designed to preload energy consumption and billing data into a table named `Preload.EC3BaseData`. It processes data for a specified fiscal year and published month, performing several operations including data validation, deletion of previous data, insertion of new data, and normalization of energy usage. The procedure ensures that the data is consistent and complete for the given fiscal year by checking for missing records and handling them appropriately.\n\n#### 2. Complexity Level: High\nThe procedure is complex due to its multiple steps, use of temporary tables, conditional logic, and error handling. It involves data validation, transformation, and normalization processes, which require a deep understanding of the underlying data structures and business rules.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: Represents the fiscal year for which the data is being preloaded. If not provided, it defaults to the next year.\n- `@publishedMonth AS INT`: Specifies the month for which the data is being processed. This parameter is mandatory.\n- `@actionBy AS VARCHAR(25) = NULL`: Indicates the user or system initiating the procedure. Defaults to 'SYSTEM' if not provided.\n\n#### 4. Business Logic and Workflow\n1. **Initialization and Defaults**: Sets default values for fiscal year and action initiator. Calculates the base year as two years prior to the fiscal year.\n2. **Data Validation**: Checks for the existence of required data in `Preload.DegreeDay` and `Preload.BudgetGroupByFY` tables. Throws errors if data is missing.\n3. **Data Deletion**: Deletes existing records for the specified fiscal year from `Preload.EC3BaseData`.\n4. **Data Insertion**: \n   - Inserts data from `EC3DB.Published_AccountLevelRawDataForCurrentPeriod` into a temporary table `preloadTbl`.\n   - Aggregates and inserts processed data into `Preload.EC3BaseData`.\n5. **Handling Missing Records**: Identifies and inserts missing billing records for agency-budget group pairs that do not have complete data for all months.\n6. **Data Update**: Updates `StreetLightingFacilityPoints` based on data from `EC3DB.Billing_AccountBilling`.\n7. **Normalization**: Normalizes energy usage data based on degree days and energy type.\n8. **Final Adjustments**: Updates normalized energy usage and reactive power energy columns.\n9. **Transaction Management**: Uses transactions to ensure data integrity, with error handling to rollback in case of failures.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the tables involved, especially those with large datasets like `Preload.EC3BaseData`, are properly indexed to optimize query performance.\n- **Batch Processing**: Consider processing data in smaller batches if the dataset is large to avoid locking and performance degradation.\n- **Concurrency**: The use of transactions and potential locking should be monitored to prevent blocking issues in a multi-user environment.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: The procedure assumes that the data in source tables is accurate and complete. Any discrepancies could lead to incorrect preloading.\n- **Error Handling**: While the procedure includes error handling, it may not cover all possible exceptions, especially those related to data inconsistencies.\n- **Scalability**: As data volume grows, the procedure may face performance bottlenecks, particularly during the aggregation and normalization steps.\n- **Hardcoded Values**: The use of hardcoded values for budget group IDs and other parameters could lead to maintenance challenges if these values change.\n- **Resource Utilization**: The procedure may consume significant resources during execution, impacting other operations on the database server.",
      "complexity": "High",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 5148,
      "api_response_id": "chatcmpl-C8VkKYVCE7RrSz0tmg4G5ciGxl8I1"
    },
    "analysis_timestamp": "2025-08-25 13:58:37"
  },
  {
    "procedure_info": {
      "schema": "Preload",
      "name": "USP_PreloadEC3BaseData_InsertNewSet",
      "definition": "\r\nCREATE PROCEDURE [Preload].[USP_PreloadEC3BaseData_InsertNewSet]\r\n\t@fy AS INT = NULL\r\n\t,@actionBy AS VARCHAR(25) = NULL\r\n\t,@agencyCodeOEC AS VARCHAR(6)\r\n\t,@budgetGroupDEM AS INT\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\r\n\tDECLARE @baseYear AS INT\r\n\tDECLARE @createdDate AS DATETIME = GETDATE();\r\n\tDECLARE @streetLightingBudgetGroupDEM AS INT = 7;\r\n\r\n\tSET @fy = ISNULL(@fy, DATEPART(yyyy, GETDATE())+1)\r\n\tSET @actionBy = ISNULL(@actionBy, 'SYSTEM')\r\n\tSET @baseYear = @fy - 2\r\n\r\n\tIF NOT EXISTS (SELECT 1 FROM Preload.EC3BaseData WHERE FY = @fy AND AgencyCodeOEC = @agencyCodeOEC AND BudgetGroupDEM = @budgetGroupDEM)\r\n\tBEGIN\r\n\t-- 1. Insert new billing records for input Agency-BudgetGroup\r\n\t\tWITH newAgcBGrpBillingPrdTbl AS\r\n\t\t(\r\n\t\t\tSELECT DISTINCT @agencyCodeOEC AS AgencyCodeOEC, @budgetGroupDEM AS BudgetGroupDEM, BillingPeriod\r\n\t\t\tFROM Preload.EC3BaseData\r\n\t\t)\r\n\t\tINSERT INTO [Preload].[EC3BaseData] ([AgencyCodeOEC]\r\n\t\t\t\t,[BudgetGroupDEM]\r\n\t\t\t\t,[BillingPeriod]\r\n\t\t\t\t,[BaseEnergyUsage]\r\n\t\t\t\t,[BaseDemandUsage]\r\n\t\t\t\t,[BaseBilledDollars]\r\n\t\t\t\t,[NumberOfDistinctAccounts]\r\n\t\t\t\t,[AdditionalProductionDemandUnitsBilled]\r\n\t\t\t\t,[AdditionalDeliveryDemandUnitsBilled]\r\n\t\t\t\t,[Additional062MinimumBilledEnergyUsageUnits]\r\n\t\t\t\t,[BaseOnPeakEnergyUsage]\r\n\t\t\t\t,[BaseOffPeakEnergyUsage]\r\n\t\t\t\t,[BaseAccountReactivePowerEnergy]\r\n\t\t\t\t,[DeliveryStreetLightingFacilityPoints]\r\n\t\t\t\t,[StreetLightingFacilityPoints]\r\n\t\t\t\t,[CommodityAllocationChargeAdder]\r\n\t\t\t\t,[DeliveryAllocationChargeAdder]\r\n\t\t\t\t,[IsNotBilled]\r\n\t\t\t\t,[CreatedDate]\r\n\t\t\t\t,[CreatedBy])\r\n\t\tSELECT AgencyCodeOEC\r\n\t\t\t\t,BudgetGroupDEM\r\n\t\t\t\t,BillingPeriod\r\n\t\t\t\t,0 AS EnergyUsage\r\n\t\t\t\t,0 AS DemandUsage\r\n\t\t\t\t,0 AS BilledDollars\r\n\t\t\t\t,0 AS NumberOfDistinctAccounts\r\n\t\t\t\t,0 AS AdditionalProductionDemandUnitsBilled\r\n\t\t\t\t,0 AS AdditionalDeliveryDemandUnitsBilled\r\n\t\t\t\t,0 AS Additional062MinimumBilledEnergyUsageUnits\r\n\t\t\t\t,0 AS OnPeakEnergyUsage\r\n\t\t\t\t,0 AS OffPeakEnergyUsage\r\n\t\t\t\t,0 AS BaseAccountReactivePowerEnergy\r\n\t\t\t\t,0 AS DeliveryStreetLightingFacilityPoints\r\n\t\t\t\t,0 AS StreetLightingFacilityPoints\r\n\t\t\t\t,0 AS CommodityAllocationChargeAdder\r\n\t\t\t\t,0 AS DeliveryAllocationChargeAdder\r\n\t\t\t\t,1 AS IsNotBilled\r\n\t\t\t\t,@createdDate\r\n\t\t\t\t,@actionBy\r\n\t\tFROM newAgcBGrpBillingPrdTbl;\r\n\r\n\t-- 2. Update StreetLightingFacilityPoints\r\n\t\tIF @budgetGroupDEM = @streetLightingBudgetGroupDEM\r\n\t\t\tUPDATE Preload.EC3BaseData\r\n\t\t\tSET StreetLightingFacilityPoints = ec3StreetLighting.DeliveryStreetLightingFacilityPoints\r\n\t\t\tFROM \r\n\t\t\t(\r\n\t\t\t\tSELECT Eab.BillingPeriodRevision, SUM(eabe.DeliveryStreetLightingFacilityPoints) AS DeliveryStreetLightingFacilityPoints\r\n\t\t\t\tFROM EC3DB.Billing_AccountBilling AS Eab INNER JOIN EC3DB.Billing_AccountBillingElectric AS eabe\r\n\t\t\t\t\tON Eab.AccountBillingSeqId = eabe.MonthlyAccountBillingChargesElectric\r\n\t\t\t\tWHERE (Eab.OriginalAccountNumber > '8') AND SUBSTRING(Eab.BillingPeriodRevision, 1, 4) = '2012'\r\n\t\t\t\tGROUP BY Eab.BillingPeriodRevision\r\n\t\t\t) AS ec3StreetLighting\r\n\t\t\tWHERE Preload.EC3BaseData.FY = @fy \r\n\t\t\t\tAND Preload.EC3BaseData.AgencyCodeOEC = @agencyCodeOEC\r\n\t\t\t\tAND Preload.EC3BaseData.BudgetGroupDEM = @budgetGroupDEM \r\n\t\t\t\tAND Preload.EC3BaseData.BillingPeriod = ec3StreetLighting.BillingPeriodRevision;\r\n\tEND --end if\r\nEND\r\n",
      "created": "2025-08-25 15:54:06.093000",
      "last_altered": "2025-08-25 15:54:06.093000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyCodeOEC",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupDEM",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_PreloadEC3BaseData_InsertNewSet",
      "explanation": "#### 1. Overview\n\nThe stored procedure `USP_PreloadEC3BaseData_InsertNewSet` is designed to insert new records into the `Preload.EC3BaseData` table for a specified fiscal year, agency code, and budget group if such records do not already exist. It initializes these records with default values and updates specific fields if certain conditions are met. The procedure is part of a data preloading process, likely used to prepare or initialize data for further processing or reporting.\n\n#### 2. Complexity Level: Medium\n\nThe procedure involves conditional logic, the use of common table expressions (CTEs), and an update operation based on a join with another table. While not overly complex, it requires a good understanding of SQL operations and the specific business logic it implements.\n\n#### 3. Input Parameters\n\n- `@fy AS INT = NULL`: Represents the fiscal year for which data is being inserted. Defaults to the next year if not provided.\n- `@actionBy AS VARCHAR(25) = NULL`: Indicates who is performing the action. Defaults to 'SYSTEM' if not provided.\n- `@agencyCodeOEC AS VARCHAR(6)`: Specifies the agency code for which data is being inserted. This is a required parameter.\n- `@budgetGroupDEM AS INT`: Specifies the budget group for which data is being inserted. This is a required parameter.\n\n#### 4. Business Logic and Workflow\n\n1. **Initialization**: \n   - Sets default values for `@fy` and `@actionBy` if they are not provided.\n   - Calculates `@baseYear` as two years prior to the fiscal year.\n\n2. **Existence Check**:\n   - Checks if records for the specified fiscal year, agency code, and budget group already exist in the `Preload.EC3BaseData` table.\n\n3. **Insertion**:\n   - If no existing records are found, it inserts new records with default values (mostly zeros) for various fields, using a CTE to determine distinct billing periods.\n\n4. **Conditional Update**:\n   - If the budget group matches a predefined street lighting budget group, it updates the `StreetLightingFacilityPoints` field based on aggregated data from another table (`EC3DB.Billing_AccountBilling` and `EC3DB.Billing_AccountBillingElectric`).\n\n#### 5. Performance Considerations\n\n- **Indexing**: The performance of the existence check and update operations can be significantly affected by the presence or absence of appropriate indexes on the `Preload.EC3BaseData` table, particularly on the `FY`, `AgencyCodeOEC`, and `BudgetGroupDEM` columns.\n- **CTE Usage**: The use of a CTE for selecting distinct billing periods is efficient for this purpose, but the underlying query should be optimized to ensure it does not become a bottleneck.\n- **Update Operation**: The update operation involves a join with another table, which can be resource-intensive if the tables are large and not properly indexed.\n\n#### 6. Potential Issues or Risks\n\n- **Concurrency**: If multiple instances of this procedure are run simultaneously with the same parameters, it could lead to race conditions or duplicate data unless proper locking mechanisms are in place.\n- **Data Integrity**: The procedure assumes that the default values being inserted are appropriate for all scenarios, which may not always be the case. This could lead to incorrect data being preloaded.\n- **Hardcoded Values**: The procedure uses hardcoded values (e.g., `2012` in the update query), which could lead to maintenance challenges and potential errors if the logic needs to be adapted for different timeframes.\n- **Scalability**: As the volume of data grows, the performance of the procedure may degrade if not optimized, particularly the update operation which involves aggregation and joining with another table.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1910,
      "api_response_id": "chatcmpl-C8VkkMr9G1eRIuKgq7uDk1s3L6S33"
    },
    "analysis_timestamp": "2025-08-25 13:59:07"
  },
  {
    "procedure_info": {
      "schema": "Preload",
      "name": "USP_PreloadTier4REC",
      "definition": "CREATE PROCEDURE [Preload].[USP_PreloadTier4REC]\r\n(\r\n\t@fy AS INT = NULL\r\n\t,@scenarioId AS INT = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tDELETE FROM budget.StagingBudget\r\n\tWHERE FY = ISNULL(@fy, FY)\r\n\t\tAND ScenarioId = ISNULL(@scenarioId, ScenarioId)\r\n\t\tAND BudgetGroupID = 77;\r\n\r\n\tINSERT INTO budget.StagingBudget(ScenarioId\r\n\t\t,BudgetStageID\r\n\t\t,AgencyCodeOEC\r\n\t\t,BudgetGroupID\r\n\t\t,BudgetBillingPeriod\r\n\t\t,EnergyDollars\r\n\t\t,TotalDollars\r\n\t\t,EnergyUsage)\r\n\t(SELECT SB.ScenarioId\r\n\t\t,SB.BudgetStageID\r\n\t\t,SB.AgencyCodeOEC\r\n\t\t,77 AS BudgetGroupID\r\n\t\t,SB.BudgetBillingPeriod\r\n\t\t,SUM(CASE WHEN ISNULL(BR.BudgetCommodityConsumption, 0) <> 0 THEN ((ISNULL(BR.BudgetCommodityConsumption, 0) + ISNULL(BR.BudgetCommodityConsumptionAdder, 0)) \r\n\t\t\t\t* ISNULL(BR.CommodityMultiplier, 0) \r\n\t\t\t\t* (ISNULL(SB.EnergyUsage, 0) + (ISNULL(SB.EnergyUsage, 0) * ISNULL(REC.QuantityAlignmentAdjustment, 0))))\r\n\t\t\tELSE 0 END) AS EnergyDollars\r\n\t\t,SUM(CASE WHEN ISNULL(BR.BudgetCommodityConsumption, 0) <> 0 THEN ((ISNULL(BR.BudgetCommodityConsumption, 0) + ISNULL(BR.BudgetCommodityConsumptionAdder, 0))\r\n\t\t\t\t* ISNULL(BR.CommodityMultiplier, 0) \r\n\t\t\t\t* (ISNULL(SB.EnergyUsage, 0) + (ISNULL(SB.EnergyUsage, 0) * ISNULL(REC.QuantityAlignmentAdjustment, 0))))\r\n\t\t\tELSE 0 END) AS TotalDollars\r\n\t\t,SUM(CASE WHEN ISNULL(BR.BudgetCommodityConsumption, 0) <> 0 THEN (ISNULL(SB.EnergyUsage, 0) + (ISNULL(SB.EnergyUsage, 0) * ISNULL(REC.QuantityAlignmentAdjustment, 0)))\r\n\t\t\tELSE 0 END) AS EnergyUsage\r\n\tFROM budget.StagingBudget AS SB\r\n\t\tINNER JOIN input.Tier4REC AS REC ON SB.FY = REC.FY\r\n\t\tINNER JOIN Preload.Agency AS A ON A.AgencyCodeOEC = SB.AgencyCodeOEC\r\n\t\tINNER JOIN input.vwBudgetRates AS BR ON BR.ScenarioId = SB.ScenarioId AND BR.BillingPeriod = SB.BudgetBillingPeriod AND BR.BudgetGroupID = 77\r\n\t\tINNER JOIN (SELECT DISTINCT AgencyId FROM Preload.AgencyByFY\r\n\t\t\tWHERE AgencyId NOT IN (SELECT DISTINCT AgencyId FROM Preload.Agency WHERE AgencyCodeOEC IN ('042002', '960000', '126036', '801002'))\r\n\t\t\t\tAND (ParentAgencyId NOT IN(SELECT DISTINCT AgencyId FROM Preload.Agency WHERE AgencyCodeOEC IN ('042002', '960000', '126036', '801002')) OR ParentAgencyID IS NULL)) AS FA ON FA.AgencyId = A.AgencyId\r\n\tWHERE SB.FY = ISNULL(@fy, SB.FY)\r\n\t\tAND SB.ScenarioId = ISNULL(@scenarioId, SB.ScenarioId)\r\n\t\tAND SB.BudgetGroupID IN (SELECT DISTINCT BudgetGroupID FROM Preload.BudgetGroup WHERE BudgetGroupName LIKE '%NYPA%')\r\n\tGROUP BY SB.ScenarioId, SB.BudgetStageID, SB.BudgetBillingPeriod, SB.AgencyCodeOEC\r\n\tUNION\r\n\tSELECT SB.ScenarioId\r\n\t\t,SB.BudgetStageID\r\n\t\t,SB.AgencyCodeOEC\r\n\t\t,77 AS BudgetGroupID\r\n\t\t,SB.BudgetBillingPeriod\r\n\t\t,0 AS EnergyDollars\r\n\t\t,0 AS TotalDollars\r\n\t\t,SUM(CASE WHEN ISNULL(BR.BudgetCommodityConsumption, 0) <> 0 THEN (ISNULL(SB.EnergyUsage, 0) + (ISNULL(SB.EnergyUsage, 0) * ISNULL(REC.QuantityAlignmentAdjustment, 0)))\r\n\t\t\tELSE 0 END) AS EnergyUsage\r\n\tFROM budget.StagingBudget AS SB\r\n\t\tINNER JOIN input.Tier4REC AS REC ON SB.FY = REC.FY\r\n\t\tINNER JOIN Preload.Agency AS A ON A.AgencyCodeOEC = SB.AgencyCodeOEC\r\n\t\tINNER JOIN input.vwBudgetRates AS BR ON BR.ScenarioId = SB.ScenarioId AND BR.BillingPeriod = SB.BudgetBillingPeriod AND BR.BudgetGroupID = 77\r\n\t\tINNER JOIN (SELECT DISTINCT AgencyId FROM Preload.AgencyByFY\r\n\t\t\tWHERE AgencyId IN (SELECT DISTINCT AgencyId FROM Preload.Agency WHERE AgencyCodeOEC IN ('042002', '960000', '126036', '801002'))\r\n\t\t\t\tOR ParentAgencyId IN(SELECT DISTINCT AgencyId FROM Preload.Agency WHERE AgencyCodeOEC IN ('042002', '960000', '126036', '801002'))) AS FA ON FA.AgencyId = A.AgencyId\r\n\tWHERE SB.FY = ISNULL(@fy, SB.FY)\r\n\t\tAND SB.ScenarioId = ISNULL(@scenarioId, SB.ScenarioId)\r\n\t\tAND SB.BudgetGroupID IN (SELECT DISTINCT BudgetGroupID FROM Preload.BudgetGroup WHERE BudgetGroupName LIKE '%NYPA%')\r\n\tGROUP BY SB.ScenarioId, SB.BudgetStageID, SB.BudgetBillingPeriod, SB.AgencyCodeOEC);\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.100000",
      "last_altered": "2025-08-25 15:54:06.100000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@scenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_PreloadTier4REC",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_PreloadTier4REC` is designed to manage data in the `budget.StagingBudget` table. It performs two main operations: deleting existing records based on certain criteria and inserting new aggregated data into the same table. The procedure is part of a larger budgeting system, dealing specifically with a budget group identified by `BudgetGroupID = 77`. It processes data related to energy usage and costs, likely for a specific fiscal year (`FY`) and scenario (`ScenarioId`).\n\n#### 2. Complexity Level: Medium\nThe complexity of this stored procedure is medium due to the following factors:\n- It involves multiple table joins and subqueries.\n- It uses conditional logic within aggregate functions.\n- It handles both deletion and insertion operations.\n- It includes a UNION operation to combine results from two different query sets.\n\n#### 3. Input Parameters\n- `@fy AS INT = NULL`: Represents the fiscal year. If not provided, the procedure defaults to using the fiscal year present in the data.\n- `@scenarioId AS INT = NULL`: Represents the scenario identifier. If not provided, the procedure defaults to using the scenario ID present in the data.\n\n#### 4. Business Logic and Workflow\n1. **Deletion Operation**:\n   - The procedure deletes records from `budget.StagingBudget` where the fiscal year and scenario ID match the provided parameters (or all records if parameters are NULL), and the `BudgetGroupID` is 77.\n\n2. **Insertion Operation**:\n   - The procedure inserts aggregated data into `budget.StagingBudget`:\n     - **First Query**: Aggregates data for agencies not in a specific list of codes. It calculates `EnergyDollars`, `TotalDollars`, and `EnergyUsage` using complex expressions involving multiple tables (`Tier4REC`, `Agency`, `vwBudgetRates`, and a subquery on `AgencyByFY`).\n     - **Second Query**: Similar to the first, but targets agencies within the specified list of codes. It only calculates `EnergyUsage`, setting `EnergyDollars` and `TotalDollars` to zero.\n\n3. **Grouping and Union**:\n   - Both queries group results by `ScenarioId`, `BudgetStageID`, `BudgetBillingPeriod`, and `AgencyCodeOEC`.\n   - The results of the two queries are combined using a UNION operation.\n\n#### 5. Performance Considerations\n- **Indexes**: Ensure that the columns used in joins and where clauses (`FY`, `ScenarioId`, `AgencyCodeOEC`, `BudgetBillingPeriod`, `BudgetGroupID`) are indexed to improve query performance.\n- **Aggregation**: The use of SUM and CASE statements within the aggregation can be computationally expensive, especially if the underlying tables are large.\n- **Subqueries**: The subquery in the join condition for `AgencyByFY` could be optimized or indexed to prevent performance bottlenecks.\n\n#### 6. Potential Issues or Risks\n- **NULL Handling**: The use of `ISNULL` in the WHERE clause and calculations could lead to unexpected results if not all scenarios are accounted for.\n- **Data Integrity**: The deletion step removes data based on the fiscal year and scenario ID, which could lead to data loss if not carefully managed.\n- **Concurrency**: If this procedure is run concurrently by multiple processes, it could lead to locking issues or race conditions, especially during the delete and insert operations.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions and incomplete transactions in case of failures.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 2172,
      "api_response_id": "chatcmpl-C8VlEmspchJS6BXPSZOlzSs5FDZmy"
    },
    "analysis_timestamp": "2025-08-25 13:59:18"
  },
  {
    "procedure_info": {
      "schema": "prerequisite",
      "name": "USP_AddNewFiscalYearAndBillingPeriod",
      "definition": "CREATE PROCEDURE [prerequisite].[USP_AddNewFiscalYearAndBillingPeriod]\r\n    @actionBy AS VARCHAR(25) = NULL\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n\r\n\tDECLARE @fy INT;\r\n\tSELECT @fy = (MAX(FY) + 1)  FROM [Preload].[BillingPeriod]  \r\n\r\n    SET @actionBy = ISNULL(@actionBy, 'SYSTEM');\r\n    DECLARE @increment INT = 1;\r\n\t \r\n    WHILE (@increment < 13)\r\n    BEGIN\r\n        IF @increment < 7\r\n            INSERT INTO [Preload].[BillingPeriod] ([BudgetBillingPeriod], [BillingPeriod], [CreatedDate], [CreatedBy])\r\n            VALUES (@fy * 100 + @increment, (@fy - 2) * 100 + @increment, GETDATE(), @actionBy);\r\n        ELSE\r\n            INSERT INTO [Preload].[BillingPeriod] ([BudgetBillingPeriod], [BillingPeriod], [CreatedDate], [CreatedBy])\r\n            VALUES ((@fy - 1) * 100 + @increment, (@fy - 2) * 100 + @increment, GETDATE(), @actionBy);\r\n\r\n        SET @increment = @increment + 1;\r\n    END;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.103000",
      "last_altered": "2025-08-25 15:54:06.103000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_AddNewFiscalYearAndBillingPeriod",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_AddNewFiscalYearAndBillingPeriod` is designed to add new records to the `BillingPeriod` table within the `Preload` schema. It calculates and inserts billing periods for a new fiscal year based on the existing data in the table. The procedure generates 12 new billing periods, corresponding to each month of the fiscal year, and assigns them a budget billing period and a billing period value. The procedure also logs the creation date and the user who performed the action.\n\n#### 2. Complexity Level: Medium\nThe complexity of this stored procedure is considered medium due to the following factors:\n- It involves dynamic calculation of fiscal year and billing periods.\n- It uses a loop to insert multiple records.\n- It includes conditional logic to determine the values for insertion.\n\n#### 3. Input Parameters\n- `@actionBy AS VARCHAR(25) = NULL`: This parameter is used to record the user who initiated the procedure. If not provided, it defaults to 'SYSTEM'.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages, which can improve performance.\n2. **Determine New Fiscal Year**: It calculates the new fiscal year (`@fy`) by selecting the maximum fiscal year (`FY`) from the `BillingPeriod` table and adding 1.\n3. **Default Action By**: If `@actionBy` is not provided, it defaults to 'SYSTEM'.\n4. **Loop for Insertion**: A `WHILE` loop runs from 1 to 12, representing each month of the fiscal year.\n   - **Conditional Logic**: \n     - For months 1 to 6, the `BudgetBillingPeriod` is calculated as `@fy * 100 + @increment`, and the `BillingPeriod` is `(@fy - 2) * 100 + @increment`.\n     - For months 7 to 12, the `BudgetBillingPeriod` is `(@fy - 1) * 100 + @increment`, and the `BillingPeriod` remains `(@fy - 2) * 100 + @increment`.\n   - **Insertion**: Each iteration inserts a new record into the `BillingPeriod` table with the calculated values, current date, and `@actionBy`.\n5. **Increment**: The loop counter `@increment` is increased by 1 after each iteration.\n\n#### 5. Performance Considerations\n- **Loop Overhead**: The use of a loop to insert records can be less efficient than set-based operations, especially if the number of iterations increases.\n- **Indexing**: Ensure that the `BillingPeriod` table is properly indexed to optimize the `SELECT MAX(FY)` query.\n- **Concurrency**: If multiple instances of this procedure run simultaneously, it could lead to race conditions or duplicate fiscal year entries.\n\n#### 6. Potential Issues or Risks\n- **Concurrency Issues**: Without proper locking or transaction management, concurrent executions could result in incorrect fiscal year calculations.\n- **Data Integrity**: If the `BillingPeriod` table does not have constraints to prevent duplicate fiscal years, this procedure could insert conflicting data.\n- **Error Handling**: The procedure lacks error handling, which could lead to unhandled exceptions and incomplete data insertion in case of failures.\n- **Scalability**: As the number of fiscal years grows, the performance of the `SELECT MAX(FY)` query could degrade if not properly indexed.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1195,
      "api_response_id": "chatcmpl-C8VlPSCuSHwDrCNZv3JtUyYvdwV3W"
    },
    "analysis_timestamp": "2025-08-25 13:59:26"
  },
  {
    "procedure_info": {
      "schema": "prerequisite",
      "name": "USP_CleanseNewFiscalYearPrerequisiteData",
      "definition": "\r\n\r\n-- ==========================================================================================\r\n-- Author:\t\tMei\r\n-- Create date: 6/27/2017\r\n-- Description:\tCleanse new fiscal year prerequisite Data so that wizard can repeat again\r\n-- ==========================================================================================\r\nCREATE PROCEDURE [prerequisite].[USP_CleanseNewFiscalYearPrerequisiteData] \r\n@fy INT -- = NULL\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n\r\n    --SET @fy = ISNULL(@fy, (YEAR(GETDATE()) + 2));\r\n\r\n    DELETE FROM [Preload].[BillingPeriod]\r\n    WHERE FY = @fy;\r\n\r\n    DELETE FROM [Preload].[AgencyByFY]\r\n    WHERE FY = @fy;\r\n\r\n    DELETE FROM [Preload].[BudgetGroupByFY]\r\n    WHERE FY = @fy;\r\n\r\n    DELETE FROM [Preload].[DegreeDay]\r\n    WHERE FY = @fy;\r\n\r\n    DELETE FROM [Preload].[EC3BaseData]\r\n    WHERE FY = @fy;\r\n\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.107000",
      "last_altered": "2025-08-25 15:54:06.107000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_CleanseNewFiscalYearPrerequisiteData",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_CleanseNewFiscalYearPrerequisiteData` is designed to delete records from several tables within the `Preload` schema that are associated with a specific fiscal year (`FY`). This procedure is intended to reset or cleanse data related to a new fiscal year, allowing a wizard or process to be repeated without interference from existing data.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving simple DELETE operations on multiple tables based on a single condition. There are no complex joins, subqueries, or conditional logic, which keeps the complexity low.\n\n#### 3. Input Parameters\n- `@fy INT`: This parameter represents the fiscal year for which the data should be cleansed. It is expected to be an integer value corresponding to the fiscal year.\n\n#### 4. Business Logic and Workflow\n1. **Parameter Handling**: The procedure accepts a fiscal year (`@fy`) as an input parameter. The commented-out line suggests that there was an intention to default this parameter to the current year plus two, but this logic is not active in the current version of the procedure.\n   \n2. **Data Deletion**: The procedure performs a series of DELETE operations on five tables within the `Preload` schema:\n   - `BillingPeriod`\n   - `AgencyByFY`\n   - `BudgetGroupByFY`\n   - `DegreeDay`\n   - `EC3BaseData`\n   \n   Each DELETE operation targets records where the `FY` column matches the provided fiscal year (`@fy`).\n\n3. **Purpose**: The primary goal is to remove data for a specific fiscal year, presumably to prepare the system for a new cycle or to allow a setup wizard to be rerun without conflicts from existing data.\n\n#### 5. Performance Considerations\n- **Indexing**: Ensure that the `FY` column in each table is indexed to optimize the DELETE operations. Without proper indexing, these operations could result in table scans, leading to performance degradation, especially if the tables are large.\n- **Transaction Management**: The procedure does not explicitly manage transactions. If atomicity is required (i.e., all deletions must succeed or fail together), consider wrapping the DELETE operations in a transaction.\n- **Locking and Blocking**: DELETE operations can cause locking and blocking issues, particularly if the tables are large or heavily accessed. Consider the impact on concurrent operations and evaluate the need for running this procedure during off-peak hours.\n\n#### 6. Potential Issues or Risks\n- **Data Loss**: The procedure permanently deletes data for the specified fiscal year. Ensure that this operation is intentional and that backups or other data recovery mechanisms are in place if needed.\n- **Parameter Validation**: There is no validation of the `@fy` parameter. Passing an incorrect or unintended fiscal year could result in unintended data loss.\n- **Concurrency**: If the procedure is executed concurrently with other operations that depend on the data being deleted, it could lead to inconsistencies or errors in those operations.\n- **Error Handling**: The procedure lacks error handling. Consider adding TRY...CATCH blocks to handle potential errors gracefully and log them for auditing purposes.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1064,
      "api_response_id": "chatcmpl-C8VlYegntpnvnQQpw9QS5h0igD2xv"
    },
    "analysis_timestamp": "2025-08-25 13:59:38"
  },
  {
    "procedure_info": {
      "schema": "prerequisite",
      "name": "USP_InsertAgenciesPrerequisite",
      "definition": "CREATE PROCEDURE [prerequisite].[USP_InsertAgenciesPrerequisite]\r\n(\r\n    @idList AS input.UDT_IDList READONLY\r\n    ,@fy AS INT\r\n    ,@actionBy AS VARCHAR(25) = NULL\r\n    ,@deleteExisting AS BIT = false\r\n)\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n\r\n    SET @actionBy = ISNULL(@actionBy, 'SYSTEM');\r\n\r\n    ------------- Part 1 ------------\r\n    DECLARE @idList2 AS input.UDT_IDList;\r\n\r\n    INSERT INTO @idList2\r\n    SELECT ID\r\n    FROM @idList\r\n    WHERE ID NOT IN (SELECT AgencyId FROM [Preload].[Agency]);\r\n\r\n    INSERT INTO Preload.Agency(AgencyId\r\n        ,AgencyCodeOEC\r\n        ,AgencyName\r\n        ,AgencyDescription\r\n        ,CreatedDate\r\n        ,CreatedBy\r\n        ,ModifiedDate\r\n        ,ModifiedBy\r\n        ,AgencyFundingSeqId\r\n        ,FundingSourceDescription)\r\n    SELECT vw.AgencyId\r\n        ,vw.AgencyCodeOEC\r\n        ,vw.AgencyName\r\n        ,vw.AgencyDescription\r\n        ,GETDATE() AS CreatedDate\r\n        ,@actionBy AS CreatedBy\r\n        ,GETDATE() AS [ModifiedDate]\r\n        ,@actionBy AS [ModifiedBy]\r\n        ,afa.AgencyFundingSeqId\r\n        ,fund.FundingSourceDescription\r\n    FROM EC3DB.BudgetApp_vwAgencies AS vw\r\n        LEFT JOIN EC3DB.Billing_AgencyFundingAssignments AS afa ON vw.AgencyId = afa.AgencyDivisionSeqId\r\n        LEFT JOIN EC3DB.Billing_AgencyFunding AS fund ON afa.AgencyFundingSeqId = fund.AgencyFundingSeqId\r\n    WHERE vw.AgencyId IN (SELECT ID FROM @idList2);\r\n\r\n    ------------- Part 2 ------------\r\n    IF (@deleteExisting <> 0 ) -- for new fiscal year, users should be able to remove, not for current FY and last FY\r\n    BEGIN\r\n        DELETE Preload.AgencyByFY\r\n        WHERE FY = @fy AND AgencyId NOT IN (SELECT ID FROM @idList\r\n            UNION\r\n            SELECT a.AgencyId AS ID\r\n            FROM Preload.Agency AS a\r\n                INNER JOIN prerequisite.vwAgencyCodesUsedByInputByFY AS v ON a.AgencyCodeOEC = v.AgencyCode\r\n            WHERE v.FY = @fy);\r\n    END;\r\n\r\n    DELETE @idList2;\r\n    INSERT INTO @idList2\r\n    SELECT ID\r\n    FROM @idList\r\n    WHERE ID NOT IN (SELECT AgencyId FROM Preload.AgencyByFY WHERE FY = @fy);\r\n\r\n    INSERT INTO Preload.AgencyByFY(FY\r\n        ,AgencyId\r\n        ,ParentAgencyId\r\n        ,AgencyDivisionHierarchy\r\n        ,CreatedDate\r\n        ,CreatedBy)\r\n    SELECT @fy\r\n        ,AgencyId\r\n        ,ParentAgencyId\r\n        ,AgencyDivisionHierarchy\r\n        ,GETDATE() AS CreatedDate\r\n        ,@actionBy AS CreatedBy\r\n    FROM EC3DB.BudgetApp_vwAgencies\r\n    WHERE Active = 1 AND AgencyId IN (SELECT ID FROM @idList2);\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.113000",
      "last_altered": "2025-08-25 15:54:06.113000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@idList",
        "data_type": "UDT_IDList",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@deleteExisting",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_InsertAgenciesPrerequisite",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_InsertAgenciesPrerequisite` is designed to manage agency data within a SQL Server database. It performs operations to insert new agency records into the `Preload.Agency` table and manage fiscal year-specific agency data in the `Preload.AgencyByFY` table. The procedure uses a user-defined table type `UDT_IDList` to handle a list of agency IDs and includes logic to optionally delete existing records for a specified fiscal year.\n\n#### 2. Complexity Level: Medium\n\n#### 3. Input Parameters\n- `@idList AS input.UDT_IDList READONLY`: A table-valued parameter containing a list of agency IDs to be processed.\n- `@fy AS INT`: An integer representing the fiscal year for which the operations are being performed.\n- `@actionBy AS VARCHAR(25) = NULL`: A string indicating the user or system performing the action. Defaults to 'SYSTEM' if not provided.\n- `@deleteExisting AS BIT = false`: A boolean flag indicating whether to delete existing records for the specified fiscal year. Defaults to `false`.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: \n   - The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages.\n   - The `@actionBy` parameter is set to 'SYSTEM' if it is `NULL`.\n\n2. **Part 1 - Insert into `Preload.Agency`**:\n   - A temporary table `@idList2` is declared to store agency IDs that are not already present in the `Preload.Agency` table.\n   - The procedure inserts these IDs into `@idList2` by checking against existing `AgencyId` values in `Preload.Agency`.\n   - It then inserts new agency records into `Preload.Agency` by joining with `EC3DB.BudgetApp_vwAgencies`, `EC3DB.Billing_AgencyFundingAssignments`, and `EC3DB.Billing_AgencyFunding` to gather necessary details.\n\n3. **Part 2 - Manage `Preload.AgencyByFY`**:\n   - If `@deleteExisting` is true, the procedure deletes records from `Preload.AgencyByFY` for the specified fiscal year that are not in the provided `@idList` or not used by the input fiscal year.\n   - The procedure clears `@idList2` and repopulates it with IDs not present in `Preload.AgencyByFY` for the specified fiscal year.\n   - Finally, it inserts new records into `Preload.AgencyByFY` for active agencies from `EC3DB.BudgetApp_vwAgencies` that are in `@idList2`.\n\n#### 5. Performance Considerations\n- **Table-Valued Parameter**: Using a table-valued parameter (`UDT_IDList`) is efficient for handling multiple IDs, reducing the need for multiple calls or complex string parsing.\n- **Indexing**: Ensure that `AgencyId` columns in `Preload.Agency` and `Preload.AgencyByFY` are indexed to optimize the `NOT IN` and `JOIN` operations.\n- **Batch Operations**: The procedure performs batch inserts, which are generally more efficient than individual inserts.\n- **Conditional Deletion**: The conditional deletion logic could be resource-intensive if the dataset is large, especially if `@deleteExisting` is true.\n\n#### 6. Potential Issues or Risks\n- **Concurrency**: The procedure does not include explicit transaction handling, which could lead to data inconsistency if multiple instances run concurrently.\n- **Error Handling**: There is no error handling mechanism, such as `TRY...CATCH`, which could lead to unhandled exceptions and partial data updates.\n- **Data Integrity**: The use of `NOT IN` with subqueries can lead to performance issues and potential data integrity problems if the subquery returns a large dataset.\n- **Default Values**: The default value for `@actionBy` as 'SYSTEM' might not always be appropriate, depending on the business context.\n- **Logical Errors**: The logic assumes that agency IDs are unique across fiscal years, which might not hold true if there are changes in agency structures or IDs over time.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1762,
      "api_response_id": "chatcmpl-C8VljDI8m0EkqhYU9CMcJhkFwwwT0"
    },
    "analysis_timestamp": "2025-08-25 13:59:49"
  },
  {
    "procedure_info": {
      "schema": "prerequisite",
      "name": "USP_InsertBudgetGroupsPrerequisite",
      "definition": "CREATE PROCEDURE [prerequisite].[USP_InsertBudgetGroupsPrerequisite]\r\n(\r\n    @idList AS input.UDT_IDList READONLY\r\n   ,@fy AS INT\r\n   ,@actionBy AS VARCHAR(25) = NULL\r\n   ,@deleteExisting AS BIT = FALSE\r\n)\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n\r\n    SET @actionBy = ISNULL(@actionBy, 'SYSTEM');\r\n\r\n    ------------- Part 1 ------------\r\n    DECLARE @idList2 AS input.UDT_IDList;\r\n\r\n    INSERT INTO @idList2\r\n    SELECT ID\r\n    FROM @idList\r\n    WHERE ID NOT IN (SELECT BudgetGroupID FROM Preload.BudgetGroup);\r\n\r\n    INSERT INTO [Preload].[BudgetGroup]\r\n        (BudgetGroupID,\r\n        BudgetGroupName,\r\n        BudgetGroupDescription,\r\n        EnergyType,\r\n        EnergyUnit,\r\n        CreatedDate,\r\n        CreatedBy,\r\n        ModifiedDate,\r\n        ModifiedBy)\r\n    SELECT BudgetGroupID,\r\n        BudgetGroupName,\r\n        BudgetGroupDescription,\r\n        EnergyType,\r\n        CASE WHEN EnergyType = 'STM' THEN 'MLBS'\r\n            WHEN EnergyType = 'GAS' THEN 'THERMS'\r\n            WHEN EnergyType = 'CHW' THEN 'MLBS'\r\n            ELSE 'KWH' END EnergyUnit,\r\n        GETDATE() AS CreatedDate,\r\n        @actionBy AS CreatedBy,\r\n        GETDATE() AS ModifiedDate,\r\n        @actionBy AS ModifiedBy\r\n    FROM EC3DB.BudgetApp_vwBudgetGroups\r\n    WHERE BudgetGroupID IN (SELECT ID FROM @idList2);\r\n\r\n    ------------- Part 2 ------------\r\n    IF @deleteExisting <> 0  -- for new fiscal year, users should be able to remove, not for current FY and last FY\r\n    BEGIN\r\n        DELETE Preload.BudgetGroupByFY\r\n        WHERE FY = @fy\r\n            AND BudgetGroupID NOT IN (SELECT ID FROM @idList\r\n                UNION\r\n                SELECT BudgetGroupID AS ID\r\n                FROM prerequisite.vwBudgetGroupsUsedByInputByFY\r\n                WHERE FY = @fy);\r\n    END;\r\n\r\n    DELETE @idList2;\r\n    INSERT INTO @idList2\r\n    SELECT ID\r\n    FROM @idList\r\n    WHERE ID NOT IN (SELECT BudgetGroupID FROM Preload.BudgetGroupByFY WHERE FY = @fy);\r\n\r\n    INSERT INTO [Preload].[BudgetGroupByFY]\r\n        (FY,\r\n        BudgetGroupID,\r\n        CreatedDate,\r\n        CreatedBy)\r\n    SELECT @fy,\r\n        BudgetGroupID,\r\n        GETDATE() AS CreatedDate,\r\n        @actionBy AS CreatedBy\r\n    FROM EC3DB.BudgetApp_vwBudgetGroups\r\n    WHERE BudgetGroupID IN (SELECT ID FROM @idList2);\r\n\r\n    IF NOT EXISTS (SELECT 1 FROM Preload.BudgetGroupByFY WHERE BudgetGroupID = 62 AND FY = @fy)\r\n    BEGIN\r\n        INSERT INTO [Preload].[BudgetGroupByFY]\r\n            (FY,\r\n            BudgetGroupID,\r\n            CreatedDate,\r\n            CreatedBy)\r\n        VALUES\r\n            (@fy,\r\n            62,\r\n            GETDATE(),\r\n            @actionBy);\r\n    END;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.120000",
      "last_altered": "2025-08-25 15:54:06.120000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@idList",
        "data_type": "UDT_IDList",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@deleteExisting",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_InsertBudgetGroupsPrerequisite",
      "explanation": "#### 1. Overview\n\nThe stored procedure `USP_InsertBudgetGroupsPrerequisite` is designed to manage budget group data for a specified fiscal year. It performs operations on two tables: `Preload.BudgetGroup` and `Preload.BudgetGroupByFY`. The procedure inserts new budget groups into these tables based on the input list of IDs and handles the deletion of existing records under certain conditions. It also ensures that a specific budget group (ID 62) is always present for the given fiscal year.\n\n#### 2. Complexity Level: Medium\n\nThe procedure involves multiple steps, including conditional logic, data insertion, and deletion operations. It interacts with user-defined table types and views, which adds to its complexity. However, the logic is straightforward and follows a clear sequence of operations.\n\n#### 3. Input Parameters\n\n- `@idList AS input.UDT_IDList READONLY`: A table-valued parameter containing a list of budget group IDs to be processed.\n- `@fy AS INT`: The fiscal year for which the budget groups are being managed.\n- `@actionBy AS VARCHAR(25) = NULL`: The user or system identifier performing the action. Defaults to 'SYSTEM' if not provided.\n- `@deleteExisting AS BIT = FALSE`: A flag indicating whether existing budget group records for the fiscal year should be deleted.\n\n#### 4. Business Logic and Workflow\n\n1. **Initialization**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of row count messages. It also ensures `@actionBy` is set to a default value if not provided.\n\n2. **Part 1 - Insert New Budget Groups**:\n   - A temporary list `@idList2` is created to store IDs not already present in `Preload.BudgetGroup`.\n   - New budget groups are inserted into `Preload.BudgetGroup` from the view `EC3DB.BudgetApp_vwBudgetGroups` based on `@idList2`.\n   - The `EnergyUnit` is determined based on the `EnergyType`.\n\n3. **Part 2 - Manage Budget Groups by Fiscal Year**:\n   - If `@deleteExisting` is true, existing records in `Preload.BudgetGroupByFY` for the specified fiscal year are deleted, except those still in use.\n   - New entries are inserted into `Preload.BudgetGroupByFY` for IDs not already present for the fiscal year.\n   - Ensures that budget group ID 62 is always present for the fiscal year.\n\n#### 5. Performance Considerations\n\n- **Table-Valued Parameters**: Efficient for passing large sets of data, but performance depends on the size of `@idList`.\n- **Conditional Deletion**: The deletion logic can be costly if the dataset is large, especially if `@deleteExisting` is true.\n- **Indexing**: Ensure that `Preload.BudgetGroup` and `Preload.BudgetGroupByFY` are properly indexed on `BudgetGroupID` and `FY` to optimize lookups and joins.\n\n#### 6. Potential Issues or Risks\n\n- **Concurrency**: The procedure does not include explicit transaction handling, which could lead to inconsistencies if multiple instances run concurrently.\n- **Data Integrity**: The procedure assumes that the view `EC3DB.BudgetApp_vwBudgetGroups` provides accurate and complete data. Any discrepancies could lead to incorrect data being inserted.\n- **Hardcoded Values**: The procedure hardcodes the insertion of budget group ID 62, which may not be flexible if business rules change.\n- **Error Handling**: There is no error handling mechanism, which could lead to unhandled exceptions and incomplete operations in case of failures.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1626,
      "api_response_id": "chatcmpl-C8VluUGUu6e9G9lI9b6BID2MamR38"
    },
    "analysis_timestamp": "2025-08-25 13:59:59"
  },
  {
    "procedure_info": {
      "schema": "prerequisite",
      "name": "USP_PreviewDegreeDay",
      "definition": "CREATE PROCEDURE [prerequisite].[USP_PreviewDegreeDay]\r\n    @actionBy AS VARCHAR(25) = NULL\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n    DECLARE @fy AS INT;\r\n\r\n    SELECT @fy = (MAX(FY) + 1)\r\n    FROM Preload.BillingPeriod;\r\n\r\n    SET @actionBy = ISNULL(@actionBy, 'SYSTEM');\r\n\r\n    SELECT CONVERT(INT, ddb.BillingPeriod) AS [BillingPeriod]\r\n        ,ddb.MM\r\n        ,hist.MonthName\r\n        ,ddb.BaseCoolingDegreeDays AS [ActualCoolingDegreeDays]\r\n        ,ddb.BaseHeatingDegreeDays AS [ActualHeatingDegreeDays]\r\n        ,hist.NormalCoolingDegreeDays AS [NormalCoolingDegreeDays]\r\n        ,hist.NormalHeatingDegreeDays AS [NormalHeatingDegreeDays]\r\n        ,(CASE WHEN CONVERT(INT, ddb.BillingPeriod) % (100) > (4) AND CONVERT(INT, ddb.BillingPeriod) % (100) < (10)\r\n            THEN 'N' ELSE 'Y' END) AS [IsHeatingDegreeDayPeriod]\r\n        ,GETDATE() AS CreatedDate\r\n        ,@actionBy AS CreatedBy\r\n        ,GETDATE() AS [ModifiedDate]\r\n        ,@actionBy AS [ModifiedBy]\r\n        ,@fy AS [FY]\r\n        ,@fy - 2 AS [BaseYear]\r\n    FROM EC3DB.Factors_DegreeDayBase AS ddb\r\n        INNER JOIN EC3DB.Factors_DegreeDayNormalized30YearAverage AS hist\r\n            ON ddb.MM = hist.MM\r\n    WHERE CONVERT(INT, SUBSTRING(ddb.BillingPeriod, 1, 4)) = @fy - 2;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.123000",
      "last_altered": "2025-08-25 15:54:06.123000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@actionBy",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 25,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_PreviewDegreeDay",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_PreviewDegreeDay` is designed to generate a preview of degree day data for a future fiscal year based on historical data. It calculates and returns a dataset that includes both actual and normal cooling and heating degree days, along with metadata such as creation and modification details. The procedure uses data from two tables: `Factors_DegreeDayBase` and `Factors_DegreeDayNormalized30YearAverage`, and it operates under a `READ UNCOMMITTED` transaction isolation level to avoid locking issues.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple operations, including data retrieval, conditional logic, and data transformation. It also involves joining tables and handling potential null values for input parameters, which adds to its complexity.\n\n#### 3. Input Parameters\n- `@actionBy AS VARCHAR(25) = NULL`: This parameter is used to record the user or system that initiated the procedure. If not provided, it defaults to 'SYSTEM'.\n\n#### 4. Business Logic and Workflow\n1. **Transaction Isolation Level**: The procedure sets the transaction isolation level to `READ UNCOMMITTED`, allowing it to read uncommitted changes from other transactions, which can improve performance by reducing locking but at the risk of reading dirty data.\n   \n2. **Fiscal Year Calculation**: It calculates the next fiscal year (`@fy`) by taking the maximum fiscal year from the `Preload.BillingPeriod` table and adding one.\n\n3. **Default ActionBy**: If `@actionBy` is not provided, it defaults to 'SYSTEM'.\n\n4. **Data Selection**: The procedure selects data from `Factors_DegreeDayBase` and `Factors_DegreeDayNormalized30YearAverage` tables, joining them on the month (`MM`).\n\n5. **Conditional Logic**: It determines whether a period is a heating degree day period based on the billing period's month.\n\n6. **Output Columns**: The output includes billing period, month, month name, actual and normal degree days, a flag for heating degree day period, creation and modification metadata, and fiscal year information.\n\n7. **Filtering**: The data is filtered to include only records where the billing period's year matches two years before the calculated fiscal year.\n\n#### 5. Performance Considerations\n- **Transaction Isolation Level**: Using `READ UNCOMMITTED` can improve performance by reducing locking but may lead to reading uncommitted or dirty data.\n- **Indexing**: Ensure that the columns used in joins and where clauses, such as `MM` and `BillingPeriod`, are indexed to improve query performance.\n- **Data Volume**: The performance may degrade with large datasets, especially if the tables involved are not properly indexed.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to dirty reads, where the data read might not be committed and could change.\n- **Null Handling**: If `@actionBy` is not provided, it defaults to 'SYSTEM', which might not always be the desired behavior.\n- **Assumptions on Fiscal Year**: The calculation of the fiscal year assumes that the `BillingPeriod` table is up-to-date and accurately reflects the current fiscal year.\n- **Hardcoded Logic**: The logic for determining the heating degree day period is hardcoded and may not adapt well to changes in business rules or calendar adjustments.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1282,
      "api_response_id": "chatcmpl-C8Vm4YGjOryDAxMI3WP4xo3SB5gNV"
    },
    "analysis_timestamp": "2025-08-25 14:00:12"
  },
  {
    "procedure_info": {
      "schema": "prerequisite",
      "name": "USP_RetrieveAvailableBudgetGroups",
      "definition": "-- ================================================================\r\n-- Author:\t\tMei\r\n-- Create date: 6/8/2017\r\n-- Description:\tGet all avaiable BudgetGroup\r\n-- ================================================================\r\nCREATE PROCEDURE [prerequisite].[USP_RetrieveAvailableBudgetGroups]\r\nAS\r\nBEGIN\r\n    SET NOCOUNT ON;\r\n \r\n    SELECT BudgetGroupID,\r\n        BudgetGroupName,\r\n        BudgetGroupDescription,\r\n        EnergyType,\r\n        CASE WHEN EnergyType = 'STM' THEN 'MLBS'\r\n            WHEN EnergyType = 'GAS' THEN 'THERMS'\r\n            WHEN EnergyType = 'CHW' THEN 'MLBS'\r\n            ELSE 'KWH' END [EnergyUnit],\r\n\t\tGETDATE() AS [CreatedDate],\r\n        'dbo' AS [CreatedBy],\r\n        GETDATE() AS [ModifiedDate],\r\n        'dbo' AS [ModifiedBy]\r\n    FROM EC3DB.BudgetApp_vwBudgetGroups\r\n    WHERE Active = 1;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.127000",
      "last_altered": "2025-08-25 15:54:06.127000",
      "type": "PROCEDURE"
    },
    "parameters": [],
    "chatgpt_explanation": {
      "procedure_name": "USP_RetrieveAvailableBudgetGroups",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RetrieveAvailableBudgetGroups` is designed to retrieve a list of active budget groups from a view named `BudgetApp_vwBudgetGroups` within the `EC3DB` database. It selects specific columns related to budget groups, including an energy unit that is determined based on the type of energy associated with each budget group. The procedure also adds metadata such as the current date and a default user for creation and modification details.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving a single `SELECT` statement with a `CASE` expression to determine the energy unit. It does not involve any complex logic, joins, or subqueries, making it relatively simple.\n\n#### 3. Input Parameters\nThis stored procedure does not take any input parameters. It operates on the assumption that it will always retrieve all active budget groups from the specified view.\n\n#### 4. Business Logic and Workflow\n- **Data Retrieval**: The procedure queries the `BudgetApp_vwBudgetGroups` view to fetch budget groups that are marked as active (`Active = 1`).\n- **Energy Unit Determination**: It uses a `CASE` expression to assign an energy unit based on the `EnergyType`:\n  - 'STM' results in 'MLBS'\n  - 'GAS' results in 'THERMS'\n  - 'CHW' results in 'MLBS'\n  - Any other `EnergyType` defaults to 'KWH'\n- **Metadata Addition**: The procedure appends metadata fields such as `CreatedDate`, `CreatedBy`, `ModifiedDate`, and `ModifiedBy`, with static values for the user ('dbo') and dynamic values for the date (using `GETDATE()`).\n\n#### 5. Performance Considerations\n- **View Performance**: The performance of this procedure largely depends on the underlying view `BudgetApp_vwBudgetGroups`. If the view is complex or involves large datasets, it could impact the procedure's execution time.\n- **Indexing**: Ensuring that the `Active` column is indexed could improve the performance of the `WHERE` clause.\n- **NOCOUNT**: The use of `SET NOCOUNT ON` is a good practice as it prevents the sending of DONE_IN_PROC messages to the client, which can reduce network traffic and improve performance.\n\n#### 6. Potential Issues or Risks\n- **Hardcoded Values**: The procedure uses hardcoded values for `CreatedBy` and `ModifiedBy`, which may not reflect the actual user making changes or retrieving data. This could be misleading in audit scenarios.\n- **Lack of Parameters**: Without input parameters, the procedure lacks flexibility. It cannot filter results based on additional criteria, which might be necessary for more specific queries.\n- **EnergyType Handling**: The `CASE` expression assumes a limited set of `EnergyType` values. If new energy types are introduced without updating the procedure, they will default to 'KWH', which might not be appropriate.\n- **View Dependency**: Any changes to the structure or logic of the `BudgetApp_vwBudgetGroups` view could affect the output of this procedure.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1060,
      "api_response_id": "chatcmpl-C8VmHxCFRJrPZjyYVP2KK81ucU6AL"
    },
    "analysis_timestamp": "2025-08-25 14:00:25"
  },
  {
    "procedure_info": {
      "schema": "prerequisite",
      "name": "USP_RetrieveAvailablePublishedMonthBetweenDecAndFeb",
      "definition": "CREATE PROCEDURE [prerequisite].[USP_RetrieveAvailablePublishedMonthBetweenDecAndFeb]\r\n(\r\n    @fy AS INT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n    DECLARE @publishedBillingPeriodDEC AS VARCHAR(6), @publishedBillingPeriodFEB AS VARCHAR(6);\r\n\r\n    SELECT @publishedBillingPeriodDEC = CAST(((@fy - 2) * 100 + 12) AS VARCHAR(6)), @publishedBillingPeriodFEB = CAST(((@fy - 1) * 100 + 2) AS VARCHAR(6));\r\n\r\n    SELECT DISTINCT PublishedBillingPeriod AS AvailablePublishedMonth\r\n    FROM EC3DB.Published_MonthlyPublishedSummaryData\r\n    WHERE PublishedBillingPeriod >= @publishedBillingPeriodDEC \r\n\t\tAND PublishedBillingPeriod <= @publishedBillingPeriodFEB \r\n    ORDER BY AvailablePublishedMonth DESC;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.130000",
      "last_altered": "2025-08-25 15:54:06.130000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_RetrieveAvailablePublishedMonthBetweenDecAndFeb",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_RetrieveAvailablePublishedMonthBetweenDecAndFeb` is designed to retrieve distinct published billing periods from a database table, specifically for the months of December and February, across two fiscal years. It calculates the billing periods for December of the fiscal year two years prior and February of the previous fiscal year, then filters and returns the available published months within this range.\n\n#### 2. Complexity Level: Low\nThe procedure is straightforward, involving basic SQL operations such as variable declaration, simple arithmetic calculations, and a single SELECT query with a WHERE clause. It does not involve complex logic, multiple joins, or subqueries, which keeps the complexity low.\n\n#### 3. Input Parameters\n- `@fy AS INT`: This parameter represents the fiscal year. It is used to calculate the billing periods for December and February across two fiscal years. The fiscal year is expected to be an integer value.\n\n#### 4. Business Logic and Workflow\n1. **Set Transaction Isolation Level**: The procedure sets the transaction isolation level to READ UNCOMMITTED, allowing the query to read uncommitted changes from other transactions. This can help reduce locking and blocking but may result in reading dirty data.\n   \n2. **Variable Declaration and Initialization**: Two variables, `@publishedBillingPeriodDEC` and `@publishedBillingPeriodFEB`, are declared to store the billing periods for December and February, respectively. These are calculated using the input fiscal year (`@fy`):\n   - `@publishedBillingPeriodDEC` is calculated as December of two fiscal years prior (`(@fy - 2) * 100 + 12`).\n   - `@publishedBillingPeriodFEB` is calculated as February of the previous fiscal year (`(@fy - 1) * 100 + 2`).\n\n3. **Data Retrieval**: The procedure queries the `Published_MonthlyPublishedSummaryData` table to select distinct `PublishedBillingPeriod` values that fall between the calculated December and February billing periods. The results are ordered in descending order.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED Isolation Level**: While this level can improve performance by reducing locking, it may lead to reading uncommitted or dirty data, which could affect data accuracy.\n- **Indexing**: The performance of the SELECT query can be improved if the `PublishedBillingPeriod` column is indexed, especially given the ORDER BY clause.\n- **Calculation Overhead**: The arithmetic operations for calculating billing periods are minimal and unlikely to impact performance significantly.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: Using the READ UNCOMMITTED isolation level can lead to dirty reads, where the data read might not be committed and could change, leading to potential inconsistencies.\n- **Data Type Mismatch**: The procedure assumes that `PublishedBillingPeriod` is compatible with the VARCHAR(6) type. If the actual data type or format differs, it could lead to errors or unexpected results.\n- **Fiscal Year Assumptions**: The logic assumes a specific format for fiscal years and billing periods. Any changes in business rules or data format could necessitate changes to the procedure.\n- **Lack of Error Handling**: The procedure does not include error handling mechanisms, which could be a risk if unexpected issues arise during execution.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1084,
      "api_response_id": "chatcmpl-C8VmUgxlHTQiAanxDtpbKNk5gcVnO"
    },
    "analysis_timestamp": "2025-08-25 14:00:38"
  },
  {
    "procedure_info": {
      "schema": "report",
      "name": "USP_ActualVsBudget_RetrieveActualData",
      "definition": "CREATE PROCEDURE [report].[USP_ActualVsBudget_RetrieveActualData]\r\n(\r\n\t@startBillingPeriod AS VARCHAR(6)\r\n\t,@endBillingPeriod AS VARCHAR(6)\r\n\t,@agencyCodeOECStr AS VARCHAR(MAX)\r\n\t,@IsProjection AS BIT = 0\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @fy AS INT, @tenantChargeId AS INT, @agencyCodeOECs AS input.UDT_CODEList, @dcasAgencyCODE AS input.UDT_CODEList\r\n\t\t,@dcas856090AgencyCODE AS input.UDT_CODEList, @otherAgencyCodeOECs AS input.UDT_CODEList, @notImplTNCReportIDs AS input.UDT_IDList\r\n\t\t,@notShowUsageReportIDs AS input.UDT_IDList, @ShowNonNYPAEnergyUsage_CutOffDate AS VARCHAR(6)='202107';\r\n\r\n\tDECLARE @TNCDetails TABLE (AgencyCodeOEC VARCHAR(6), ChargePercentage decimal(10, 5));\r\n\r\n\tDECLARE @DCASActual TABLE(AgencyCodeOEC VARCHAR(6)\r\n\t\t,ReportDataTypeId INT\r\n\t\t,ActualDollar MONEY\r\n\t\t,ActualUsage DECIMAL(20, 2)\r\n\t\t,ActualRate MONEY\r\n\t\t,ActualAdjustmentSurplus MONEY\r\n\t\t,LastMonthActualDollar MONEY);\r\n\t\r\n\tDECLARE @StateFundsActual TABLE(AgencyCodeOEC VARCHAR(6)\r\n\t\t,ReportDataTypeId INT\r\n\t\t,ActualDollar MONEY\r\n\t\t,ActualUsage DECIMAL(20, 2)\r\n\t\t,ActualRate MONEY\r\n\t\t,ActualAdjustmentSurplus MONEY\r\n\t\t,LastMonthActualDollar MONEY);\r\n\r\n\tDECLARE @OTHERActual TABLE(AgencyCodeOEC VARCHAR(6)\r\n\t\t,ReportDataTypeId INT\r\n\t\t,ActualDollar MONEY\r\n\t\t,ActualUsage DECIMAL(20, 2)\r\n\t\t,ActualRate MONEY\r\n\t\t,ActualAdjustmentSurplus MONEY\r\n\t\t,LastMonthActualDollar MONEY);\r\n\r\n\tIF (CAST(RIGHT(@endBillingPeriod, 2) AS INT) < 7)\r\n\tBEGIN\r\n\t\tSET @fy = CAST(LEFT(@endBillingPeriod, 4) AS INT);\r\n\tEND;\r\n\tELSE\t\r\n\tBEGIN\r\n\t\tSET @fy = CAST(LEFT(@endBillingPeriod, 4) AS INT) + 1;\r\n\tEND;\r\n\r\n\tIF (@IsProjection = 1 AND EXISTS (SELECT * FROM budget.Scenario WHERE FY = @fy AND IsCurrentProjection = 1))\r\n\tBEGIN\r\n\t\tSELECT @tenantChargeId = ISNULL(MAX(TenantChargeID), 3)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY = @fy AND IsCurrentProjection = 1;\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tSELECT @tenantChargeId = ISNULL(MAX(TenantChargeID), 3)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY = @fy AND IsCurrentBudget = 1;\r\n\tEND;\r\n\r\n\tIF (@agencyCodeOECStr IS NULL OR @agencyCodeOECStr = '')\r\n\tBEGIN\r\n\t\tINSERT INTO @agencyCodeOECs (CODE)\r\n\t\tSELECT AgencyCodeOEC\r\n\t\tFROM Preload.Agency\r\n\t\tWHERE AgencyID IN (SELECT AgencyID FROM preload.AgencyByFY WHERE FY = @fy);\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tINSERT INTO @agencyCodeOECs (CODE) SELECT ID AS CODE  FROM [dbo].[UDF_SplitToTable] (@agencyCodeOECStr,',');\r\n\tEND;\r\n\r\n\tINSERT INTO @dcasAgencyCODE (CODE) VALUES ('856001');\r\n\tINSERT INTO @dcas856090AgencyCODE (CODE) VALUES ('856090');\r\n\tINSERT INTO @otherAgencyCodeOECs (CODE) SELECT CODE FROM @agencyCodeOECs WHERE CODE NOT IN ('856001', '856090');\r\n\tINSERT INTO @notImplTNCReportIDs (ID) SELECT ReportDataTypeId FROM report.ReportDataType WHERE TypeLevel3 LIKE 'Reactive P%';\r\n\r\n\tIF (@startBillingPeriod < @ShowNonNYPAEnergyUsage_CutOffDate)\r\n\tBEGIN\r\n\t\tINSERT INTO @notShowUsageReportIDs (ID) SELECT ReportDataTypeId FROM report.ReportDataType WHERE TypeLevel2 LIKE 'Non-NYPA E%';\r\n\tEND;\r\n\r\n\tINSERT INTO @TNCDetails (AgencyCodeOEC, ChargePercentage)\r\n\tSELECT AgencyCode, ChargePercentage\r\n\tFROM input.TenantChargeDetail\r\n\tWHERE TenantChargeID = @tenantChargeId AND AgencyCode IN (SELECT CODE FROM @agencyCodeOECs);\r\n\r\n\tINSERT INTO @DCASActual (AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, ActualAdjustmentSurplus, LastMonthActualDollar)\r\n\tSELECT AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, AdjustmentSurplus, LastMonthActualDollar \r\n\tFROM [dbo].[UDF_ActualVsBudget_GetActual] (@startBillingPeriod, @endBillingPeriod, @dcasAgencyCODE);\r\n\r\n\tIF EXISTS(SELECT * FROM @agencyCodeOECs WHERE CODE = '856090') AND (NOT EXISTS(SELECT * FROM @agencyCodeOECs WHERE CODE = '856001'))\r\n\tBEGIN\r\n\t\tINSERT INTO @OTHERActual (AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, ActualAdjustmentSurplus, LastMonthActualDollar)\t\t\r\n        SELECT AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, AdjustmentSurplus, LastMonthActualDollar\r\n        FROM dbo.UDF_ActualVsBudget_GetActual(@startBillingPeriod, @endBillingPeriod, @otherAgencyCodeOECs)\r\n        UNION\r\n        SELECT a.AgencyCodeOEC\r\n\t\t\t,a.ReportDataTypeId\r\n\t\t\t,ROUND(a.BudgetDollar, 0) AS ActualDollar\r\n\t\t\t,a.BudgetUsage AS ActualUsage\r\n\t\t\t,CASE WHEN a.BudgetUsage <> 0 THEN a.BudgetDollar / a.BudgetUsage ELSE 0 END AS ActualRate\r\n\t\t\t,0 AS ActualAdjustmentSurplus\r\n\t\t\t,ROUND(ISNULL(b.BudgetDollar, 0), 0) AS LastMonthActualDollar\r\n        FROM dbo.UDF_ActualVsBudget_GetBudget(@startBillingPeriod, @endBillingPeriod, @dcas856090AgencyCODE, @IsProjection, DEFAULT, DEFAULT, 1) a\r\n            LEFT JOIN dbo.UDF_ActualVsBudget_GetBudget(@endBillingPeriod, @endBillingPeriod, @dcas856090AgencyCODE, @IsProjection, DEFAULT, DEFAULT, 1) b\r\n\t\t\t\tON a.ReportDataTypeId = b.ReportDataTypeId;\r\n\tEND;\r\n\tELSE IF EXISTS(SELECT * FROM @agencyCodeOECs WHERE CODE = '856090') AND EXISTS(SELECT * FROM @agencyCodeOECs WHERE CODE = '856001')\r\n\tBEGIN\r\n\t\tINSERT INTO @StateFundsActual (AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, ActualAdjustmentSurplus, LastMonthActualDollar)\t\r\n        SELECT a.AgencyCodeOEC\r\n\t\t\t,a.ReportDataTypeId\r\n\t\t\t,ROUND(a.BudgetDollar, 0) AS ActualDollar\r\n\t\t\t,a.BudgetUsage AS ActualUsage\r\n\t\t\t,CASE WHEN a.BudgetUsage <> 0 THEN a.BudgetDollar / a.BudgetUsage ELSE 0 END AS ActualRate\r\n\t\t\t,0 AS ActualAdjustmentSurplus\r\n\t\t\t,ROUND(ISNULL(b.BudgetDollar, 0), 0) AS LastMonthActualDollar\r\n        FROM dbo.UDF_ActualVsBudget_GetBudget(@startBillingPeriod, @endBillingPeriod, @dcas856090AgencyCODE, @IsProjection, DEFAULT, DEFAULT, 1) a\r\n            LEFT JOIN [dbo].[UDF_ActualVsBudget_GetBudget](@endBillingPeriod, @endBillingPeriod, @dcas856090AgencyCODE, @IsProjection, DEFAULT, DEFAULT, 1) b\r\n\t\t\t\tON a.ReportDataTypeId = b.ReportDataTypeId;\r\n\r\n\t\tINSERT INTO @OTHERActual (AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, ActualAdjustmentSurplus, LastMonthActualDollar)\t\t\r\n        SELECT AgencyCodeOEC\r\n\t\t\t,ReportDataTypeId\r\n\t\t\t,ActualDollar\r\n\t\t\t,ActualUsage\r\n\t\t\t,ActualRate\r\n\t\t\t,AdjustmentSurplus\r\n\t\t\t,LastMonthActualDollar\r\n        FROM dbo.UDF_ActualVsBudget_GetActual(@startBillingPeriod, @endBillingPeriod, @otherAgencyCodeOECs)\r\n\t\tUNION\r\n\t\tSELECT * FROM @StateFundsActual\r\n\t\tUNION\r\n        SELECT a.AgencyCodeOEC\r\n\t\t\t,a.ReportDataTypeId\r\n\t\t\t,a.ActualDollar - ISNULL(b.ActualDollar, 0) AS ActualDollar\r\n\t\t\t,a.ActualUsage - ISNULL(b.ActualUsage, 0)  AS ActualUsage\r\n\t\t\t,CASE WHEN a.ActualUsage - ISNULL(b.ActualUsage, 0) <> 0\r\n\t\t\t\tTHEN (a.ActualDollar - ISNULL(b.ActualDollar, 0)) / (a.ActualUsage - ISNULL(b.ActualUsage, 0)) ELSE 0 END AS ActualRate\r\n\t\t\t,a.ActualAdjustmentSurplus\r\n\t\t\t,a.LastMonthActualDollar - ISNULL(b.LastMonthActualDollar, 0) AS LastMonthActualDollar\r\n\t\tFROM @DCASActual a LEFT JOIN @StateFundsActual b ON a.ReportDataTypeId = b.ReportDataTypeId;\r\n\tEND;\r\n\tELSE IF (NOT EXISTS(SELECT * FROM @agencyCodeOECs WHERE CODE = '856090')) AND EXISTS(SELECT * FROM @agencyCodeOECs WHERE CODE = '856001')\r\n\tBEGIN\r\n\t\tINSERT INTO @StateFundsActual (AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, ActualAdjustmentSurplus, LastMonthActualDollar)\t\r\n        SELECT a.AgencyCodeOEC\r\n\t\t\t,a.ReportDataTypeId\r\n\t\t\t,ROUND(a.BudgetDollar, 0) AS ActualDollar\r\n\t\t\t,a.BudgetUsage AS ActualUsage\r\n\t\t\t,CASE WHEN a.BudgetUsage <> 0 THEN a.BudgetDollar / a.BudgetUsage ELSE 0 END AS ActualRate\r\n\t\t\t,0 AS ActualAdjustmentSurplus\r\n\t\t\t,ROUND(ISNULL(b.BudgetDollar, 0), 0) AS LastMonthActualDollar\r\n        FROM dbo.UDF_ActualVsBudget_GetBudget(@startBillingPeriod, @endBillingPeriod, @dcas856090AgencyCODE, @IsProjection, DEFAULT, DEFAULT, 1) a\r\n            LEFT JOIN [dbo].[UDF_ActualVsBudget_GetBudget](@endBillingPeriod, @endBillingPeriod, @dcas856090AgencyCODE, @IsProjection, DEFAULT, DEFAULT, 1) b\r\n\t\t\t\tON a.ReportDataTypeId = b.ReportDataTypeId;\r\n\r\n\t\tINSERT INTO @OTHERActual (AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, ActualAdjustmentSurplus, LastMonthActualDollar)\t\t\r\n        SELECT AgencyCodeOEC\r\n\t\t\t,ReportDataTypeId\r\n\t\t\t,ActualDollar\r\n\t\t\t,ActualUsage\r\n\t\t\t,ActualRate\r\n\t\t\t,AdjustmentSurplus\r\n\t\t\t,LastMonthActualDollar\r\n        FROM dbo.UDF_ActualVsBudget_GetActual(@startBillingPeriod, @endBillingPeriod, @otherAgencyCodeOECs)\r\n\t\tUNION\r\n        SELECT a.AgencyCodeOEC\r\n\t\t\t,a.ReportDataTypeId\r\n\t\t\t,a.ActualDollar - ISNULL(b.ActualDollar, 0) AS ActualDollar\r\n\t\t\t,a.ActualUsage - ISNULL(b.ActualUsage, 0)  AS ActualUsage\r\n\t\t\t,CASE WHEN a.ActualUsage - ISNULL(b.ActualUsage, 0) <> 0\r\n\t\t\t\tTHEN (a.ActualDollar - ISNULL(b.ActualDollar, 0)) / (a.ActualUsage - ISNULL(b.ActualUsage, 0)) ELSE 0 END AS ActualRate\r\n\t\t\t,a.ActualAdjustmentSurplus\r\n\t\t\t,a.LastMonthActualDollar - ISNULL(b.LastMonthActualDollar, 0) AS LastMonthActualDollar\r\n\t\tFROM @DCASActual a LEFT JOIN @StateFundsActual b ON a.ReportDataTypeId=b.ReportDataTypeId;\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tINSERT INTO @OTHERActual (AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, ActualAdjustmentSurplus, LastMonthActualDollar)\r\n\t\tSELECT AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, AdjustmentSurplus, LastMonthActualDollar\r\n\t\tFROM [dbo].[UDF_ActualVsBudget_GetActual] (@startBillingPeriod, @endBillingPeriod, @agencyCodeOECs);\r\n\tEND;\r\n\r\n\tSELECT ISNULL(a.AgencyCodeOEC, b.AgencyCodeOEC) AS AgencyCodeOEC\r\n\t\t,@startBillingPeriod AS StartBillingPeriod\r\n\t\t,@endBillingPeriod AS EndBillingPeriod\r\n\t\t,ISNULL(a.ReportDataTypeId, b.ReportDataTypeId) AS ReportDataTypeId\r\n\t\t,@IsProjection AS IsProjection\r\n\t\t,ISNULL(a.ActualDollar, 0) + ISNULL(b.tnc_Actualdollar, 0) AS ActualDollar\r\n\t\t,CASE WHEN ISNULL(a.ReportDataTypeId, b.ReportDataTypeId) IN (SELECT ID FROM @notImplTNCReportIDs) THEN ISNULL(a.ActualUsage, 0)\r\n\t\t\tWHEN ISNULL(a.ReportDataTypeId, b.ReportDataTypeId) IN (SELECT ID FROM @notShowUsageReportIDs) THEN 0\r\n\t\t\tELSE ISNULL(a.ActualUsage, 0)+ISNULL(b.tnc_Actualusage, 0) END AS ActualUsage\r\n\t\t,CASE WHEN ISNULL(a.ReportDataTypeId, b.ReportDataTypeId) IN (SELECT ID FROM @notImplTNCReportIDs) THEN \r\n\t\t\tCASE WHEN ISNULL(a.ActualUsage, 0) <> 0 THEN (ISNULL(a.ActualDollar, 0)+ISNULL(b.tnc_Actualdollar, 0)) / ISNULL(a.ActualUsage, 0)\r\n\t\t\t\tELSE 0 END \r\n\t\t\tWHEN ISNULL(a.ReportDataTypeId, b.ReportDataTypeId) IN (SELECT ID FROM @notShowUsageReportIDs) THEN 0\r\n\t\t\tELSE\r\n\t\t\tCASE WHEN ISNULL(a.ActualUsage, 0) + ISNULL(b.tnc_Actualusage, 0) <> 0 THEN (ISNULL(a.ActualDollar, 0)\r\n\t\t\t\t\t+ ISNULL(a.ActualAdjustmentSurplus, 0) + ISNULL(b.tnc_Actualdollar, 0)) / (ISNULL(a.ActualUsage, 0) + ISNULL(b.tnc_Actualusage, 0))\r\n\t\t\t\tELSE 0 END \r\n\t\t\tEND AS ActualRate\r\n\t\t,ISNULL(a.ActualAdjustmentSurplus, 0) + ISNULL(b.tnc_ActualAdjustmentSurplus, 0) AS ActualAdjustmentSurplus\r\n\t\t,ISNULL(b.tnc_Actualdollar, 0) AS ActualTenantDollar\r\n\t\t,ISNULL(b.tnc_Actualusage, 0) AS ActualTenantUsage\r\n\t\t,ISNULL(a.LastMonthActualDollar, 0) + ISNULL(b.tnc_Actualdollar_LastMonth, 0) AS LastMonthActualDollar\r\n\tFROM @OTHERActual a\r\n\t\tFULL JOIN (SELECT b1.AgencyCodeOEC\r\n\t\t\t,a1.ReportDataTypeId\r\n\t\t\t,a1.ActualDollar*b1.ChargePercentage AS tnc_Actualdollar\r\n\t\t\t,a1.ActualUsage*b1.ChargePercentage AS tnc_Actualusage\r\n\t\t\t,a1.ActualRate AS tnc_Actualrate\r\n\t\t\t,CASE WHEN a1.ReportDataTypeId IN (SELECT ReportDataTypeId FROM report.ReportDataType WHERE CHARINDEX('adjust', TypeLevel3) > 0) \r\n\t\t\t\tTHEN a1.ActualAdjustmentSurplus* b1.ChargePercentage ELSE 0 END AS tnc_ActualAdjustmentSurplus\r\n\t\t\t,a1.LastMonthActualDollar * b1.ChargePercentage AS tnc_Actualdollar_LastMonth\r\n\t\tFROM @DCASActual a1, @TNCDetails b1\r\n\t\tWHERE a1.ReportDataTypeId NOT IN (SELECT ReportDataTypeId FROM report.ReportDataType WHERE TypeLevel1 IN ('Refund', 'Retroactive Chargeback')) \r\n\t) AS b ON a.AgencyCodeOEC = b.AgencyCodeOEC AND a.ReportDataTypeId = b.ReportDataTypeId;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.143000",
      "last_altered": "2025-08-25 15:54:06.143000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@startBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@endBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyCodeOECStr",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@IsProjection",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ActualVsBudget_RetrieveActualData",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ActualVsBudget_RetrieveActualData` is designed to retrieve actual financial and usage data for a specified billing period, comparing it against budget projections. It processes data for different agencies, considering specific conditions such as whether the data is a projection or actual, and handles various agency codes differently. The procedure aggregates and calculates financial metrics like actual dollars, usage, rates, and adjustments, and outputs a comprehensive dataset for reporting purposes.\n\n#### 2. Complexity Level: High\nThe procedure is complex due to its extensive use of temporary tables, conditional logic, and multiple joins. It involves intricate data manipulation and aggregation, making it challenging to maintain and optimize. The use of user-defined table types and functions adds to the complexity.\n\n#### 3. Input Parameters\n- `@startBillingPeriod AS VARCHAR(6)`: The start of the billing period in 'YYYYMM' format.\n- `@endBillingPeriod AS VARCHAR(6)`: The end of the billing period in 'YYYYMM' format.\n- `@agencyCodeOECStr AS VARCHAR(MAX)`: A comma-separated string of agency codes.\n- `@IsProjection AS BIT = 0`: A flag indicating whether the data is a projection (1) or actual (0).\n\n#### 4. Business Logic and Workflow\n- **Fiscal Year Calculation**: Determines the fiscal year based on the end billing period.\n- **Tenant Charge ID Selection**: Chooses the appropriate tenant charge ID based on whether the data is a projection or actual.\n- **Agency Code Handling**: Populates agency code lists based on input or defaults to all agencies for the fiscal year.\n- **Data Retrieval and Aggregation**:\n  - Retrieves actual data for specific agency codes using user-defined functions.\n  - Handles special cases for specific agency codes ('856001', '856090') and adjusts data accordingly.\n  - Aggregates data into temporary tables for DCAS, State Funds, and other agencies.\n- **Final Data Selection**: Combines data from different sources, applying adjustments and calculating final metrics like actual dollars, usage, and rates.\n\n#### 5. Performance Considerations\n- **Transaction Isolation Level**: Uses `READ UNCOMMITTED` to avoid locking, which can improve performance but may lead to dirty reads.\n- **Temporary Tables**: Extensive use of temporary tables can impact memory usage and performance, especially with large datasets.\n- **User-Defined Functions**: The reliance on user-defined functions can introduce performance overhead, particularly if these functions are complex or not optimized.\n- **Conditional Logic**: Multiple conditional branches can lead to complex execution paths, potentially affecting performance.\n\n#### 6. Potential Issues or Risks\n- **Data Integrity**: Using `READ UNCOMMITTED` can result in reading uncommitted or dirty data, which may affect the accuracy of the results.\n- **Scalability**: The procedure's complexity and reliance on temporary tables may not scale well with large datasets or high concurrency.\n- **Maintenance**: The complexity and interdependencies with user-defined functions and table types can make maintenance and debugging challenging.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions or incorrect results in case of failures.\n- **Assumptions on Input**: The procedure assumes valid and correctly formatted input parameters, which, if violated, could lead to unexpected behavior or errors.",
      "complexity": "High",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 4496,
      "api_response_id": "chatcmpl-C8VmhxnjMC6OFtU1XNVunK8dkEGrZ"
    },
    "analysis_timestamp": "2025-08-25 14:00:52"
  },
  {
    "procedure_info": {
      "schema": "report",
      "name": "USP_ActualVsBudget_RetrieveActualData_ByBudgetGroup",
      "definition": "CREATE PROCEDURE [report].[USP_ActualVsBudget_RetrieveActualData_ByBudgetGroup]\r\n(\r\n\t@startBillingPeriod AS VARCHAR(6)\r\n\t,@endBillingPeriod AS VARCHAR(6)\r\n\t,@IsProjection AS BIT = 0\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @fy AS INT, @notImplTNCReportIDs AS input.UDT_IDList, @notShowUsageReportIDs AS input.UDT_IDList, @ShowNonNYPAEnergyUsage_CutOffDate AS VARCHAR(6) = '202107';\r\n\t\r\n\tDECLARE @ActualByBudgetGroup TABLE (BudgetGroupID INT\r\n\t\t,ReportDataTypeId INT\r\n\t\t,ActualDollar MONEY\r\n\t\t,ActualUsage DECIMAL(20, 2)\r\n\t\t,ActualRate MONEY\r\n\t\t,ActualAdjustmentSurplus MONEY\r\n\t\t,LastMonthActualDollar MONEY);\r\n\r\n\tIF CAST(RIGHT(@endBillingPeriod, 2) AS INT) < 7\r\n\t\tSET @fy = CAST(LEFT(@endBillingPeriod, 4) AS INT)\r\n\tELSE\t\r\n\t\tSET @fy = CAST(LEFT(@endBillingPeriod, 4) AS INT) + 1\r\n\r\n\tINSERT INTO @notImplTNCReportIDs (ID) SELECT ReportDataTypeId FROM report.ReportDataType WHERE TypeLevel3 LIKE 'Reactive P%';\r\n\t\r\n\tIF @startBillingPeriod < @ShowNonNYPAEnergyUsage_CutOffDate\r\n\t\tINSERT INTO @notShowUsageReportIDs (ID) SELECT ReportDataTypeId FROM report.ReportDataType WHERE TypeLevel2 LIKE 'Non-NYPA E%';\r\n\r\n\tINSERT INTO @ActualByBudgetGroup (BudgetGroupID, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, ActualAdjustmentSurplus, LastMonthActualDollar)\r\n\tSELECT BudgetGroupID, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, AdjustmentSurplus, LastMonthActualDollar\r\n\tFROM dbo.UDF_ActualVsBudget_GetActual_ByBudgetGroup (@startBillingPeriod, @endBillingPeriod);\r\n\r\n\tSELECT a.BudgetGroupID\r\n\t\t,b.BudgetGroupName\r\n\t\t,@startBillingPeriod AS StartBillingPeriod\r\n\t\t,@endBillingPeriod AS EndBillingPeriod\r\n\t\t,a.ReportDataTypeId\r\n\t\t,@IsProjection AS IsProjection\r\n\t\t,ISNULL(a.ActualDollar, 0) AS ActualDollar\r\n\t\t,CASE WHEN a.ReportDataTypeId IN (SELECT ID FROM @notImplTNCReportIDs) THEN ISNULL(a.ActualUsage, 0)\r\n\t\t\tWHEN a.ReportDataTypeId IN (SELECT ID FROM @notShowUsageReportIDs) THEN 0\r\n\t\t\tELSE ISNULL(a.ActualUsage, 0) END AS ActualUsage\r\n\t\t,CASE WHEN a.ReportDataTypeId IN (SELECT ID FROM @notImplTNCReportIDs) THEN\r\n\t\t\tCASE WHEN ISNULL(a.ActualUsage, 0) <> 0 THEN ISNULL(a.ActualDollar, 0)/ISNULL(a.ActualUsage, 0)\r\n\t\t\t\tELSE 0 END \r\n\t\t\tWHEN a.ReportDataTypeId IN (SELECT ID FROM @notShowUsageReportIDs) THEN 0\r\n\t\t\tELSE\r\n\t\t\t\tCASE WHEN ISNULL(a.ActualUsage, 0) <> 0 THEN (ISNULL(a.ActualDollar, 0) + ISNULL(a.ActualAdjustmentSurplus, 0)) / ISNULL(a.ActualUsage, 0)\r\n\t\t\t\tELSE 0 END \r\n\t\t\tEND AS ActualRate\r\n\t\t,ISNULL(a.ActualAdjustmentSurplus, 0) AS ActualAdjustmentSurplus\r\n\t\t,0 AS ActualTenantDollar\r\n\t\t,0 AS ActualTenantUsage\r\n\t\t,ISNULL(a.LastMonthActualDollar, 0) AS LastMonthActualDollar\r\n\tFROM @ActualByBudgetGroup a\r\n\t\tINNER JOIN preload.BudgetGroup b ON a.BudgetGroupID = b.BudgetGroupID\r\n\t\tINNER JOIN preload.BudgetGroupByFY c ON b.BudgetGroupID = c.BudgetGroupID\r\n\tWHERE c.FY = @fy;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.153000",
      "last_altered": "2025-08-25 15:54:06.153000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@startBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@endBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@IsProjection",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ActualVsBudget_RetrieveActualData_ByBudgetGroup",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ActualVsBudget_RetrieveActualData_ByBudgetGroup` is designed to retrieve actual financial and usage data for budget groups within a specified billing period range. It calculates fiscal year based on the end billing period and filters data based on specific criteria related to report data types. The procedure uses temporary tables to manage intermediate data and joins with preloaded budget group information to produce a final result set that includes actual dollar amounts, usage, rates, and adjustments.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including dynamic fiscal year calculation, conditional data filtering, and complex joins. It also uses user-defined table types and functions, which adds to its complexity. However, it does not involve highly complex logic or recursive operations, keeping it at a medium complexity level.\n\n#### 3. Input Parameters\n- `@startBillingPeriod AS VARCHAR(6)`: The start of the billing period in 'YYYYMM' format. It defines the lower bound of the period for which data is retrieved.\n- `@endBillingPeriod AS VARCHAR(6)`: The end of the billing period in 'YYYYMM' format. It defines the upper bound of the period for which data is retrieved.\n- `@IsProjection AS BIT = 0`: A flag indicating whether the data retrieval is for projection purposes. Defaults to 0 (false).\n\n#### 4. Business Logic and Workflow\n1. **Initial Setup**: \n   - The procedure sets the transaction isolation level to `READ UNCOMMITTED` to avoid locking issues and improve performance.\n   - It declares variables and temporary tables to store intermediate data.\n\n2. **Fiscal Year Calculation**:\n   - Determines the fiscal year (`@fy`) based on the `@endBillingPeriod`. If the month is before July, the fiscal year is the same as the year in `@endBillingPeriod`; otherwise, it is the next year.\n\n3. **Data Filtering**:\n   - Populates `@notImplTNCReportIDs` with report data types related to 'Reactive P%' from `report.ReportDataType`.\n   - Conditionally populates `@notShowUsageReportIDs` with report data types related to 'Non-NYPA E%' if the `@startBillingPeriod` is before a cutoff date.\n\n4. **Data Retrieval**:\n   - Calls a user-defined function `UDF_ActualVsBudget_GetActual_ByBudgetGroup` to retrieve actual data for the specified billing period range and inserts it into `@ActualByBudgetGroup`.\n\n5. **Final Data Selection**:\n   - Joins the data in `@ActualByBudgetGroup` with budget group information to produce the final result set.\n   - Applies conditional logic to calculate `ActualUsage` and `ActualRate` based on the presence of report data types in the filtered lists.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED**: This isolation level can improve performance by reducing locking but may lead to dirty reads.\n- **Temporary Tables**: The use of temporary tables can be efficient for managing intermediate data but may increase memory usage.\n- **Function Call**: The use of a user-defined function (`UDF_ActualVsBudget_GetActual_ByBudgetGroup`) can impact performance depending on its complexity and execution time.\n- **Conditional Logic**: The conditional logic for calculating `ActualUsage` and `ActualRate` is straightforward but could be optimized if performance issues arise.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to reading uncommitted data, which might not be suitable for all business scenarios.\n- **Data Type Mismatches**: The procedure assumes specific data types for input parameters and intermediate calculations, which could lead to errors if the underlying data types change.\n- **Hardcoded Cutoff Date**: The cutoff date for `@ShowNonNYPAEnergyUsage_CutOffDate` is hardcoded, which may require updates if business rules change.\n- **Scalability**: As the data volume grows, the performance of joins and function calls may degrade, requiring optimization or indexing strategies.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1952,
      "api_response_id": "chatcmpl-C8Vmvp3PwNS4C9NFbV1LevY0mWITS"
    },
    "analysis_timestamp": "2025-08-25 14:01:05"
  },
  {
    "procedure_info": {
      "schema": "report",
      "name": "USP_ActualVsBudget_RetrieveBudgetData",
      "definition": "CREATE PROCEDURE [report].[USP_ActualVsBudget_RetrieveBudgetData]\r\n(\r\n\t@startBillingPeriod AS VARCHAR(6)\r\n\t,@endBillingPeriod AS VARCHAR(6)\r\n\t,@agencyCodeOECStr AS VARCHAR(MAX)\r\n\t,@IsProjection AS BIT = 0\r\n\t,@IsBreakDownReport AS BIT = 1\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @fy AS INT, @tenantChargeId AS INT, @agencyCodeOECs AS input.UDT_CODEList, @currentBudgetScenarioId AS INT, @dcasAgencyCODE AS input.UDT_CODEList\r\n\t\t,@dcas856090AgencyCODE AS input.UDT_CODEList, @actualDataEndMonth AS VARCHAR(6), @endBillingPeriodForActualData AS VARCHAR(6)\r\n\t\t,@startBillingPeriodForActualData AS VARCHAR(6), @startBillingPeriodForBudgetData AS VARCHAR(6), @isActVsBgtReport5 AS BIT = 0;\r\n\r\n\tDECLARE @TNCDetails TABLE (AgencyCodeOEC VARCHAR(6),\r\n\t\tChargePercentage DECIMAL(10, 5));\r\n\r\n\tDECLARE @DCASBudget TABLE (AgencyCodeOEC VARCHAR(6),\r\n\t\tReportDataTypeId INT,\r\n\t\tBudgetDollar MONEY,\r\n\t\tBudgetUsage DECIMAL(20, 2),\r\n\t\tBudgetRate MONEY,\r\n\t\tBudgetDollar_YTD MONEY, \r\n\t\tBudgetDollar_EOY MONEY, \r\n\t\tBudgetDollar_FullYear MONEY);\r\n\r\n\tDECLARE @StateFundsBudget TABLE (AgencyCodeOEC VARCHAR(6),\r\n\t\tReportDataTypeId INT,\r\n\t\tBudgetDollar MONEY,\r\n\t\tBudgetUsage DECIMAL(20, 2),\r\n\t\tBudgetRate MONEY,\r\n\t\tBudgetDollar_YTD MONEY, \r\n\t\tBudgetDollar_EOY MONEY, \r\n\t\tBudgetDollar_FullYear MONEY);\r\n\r\n\tDECLARE @OTHERBudget TABLE (AgencyCodeOEC VARCHAR(6),\r\n\t\tReportDataTypeId INT,\r\n\t\tBudgetDollar MONEY,\r\n\t\tBudgetUsage DECIMAL(20, 2),\r\n\t\tBudgetRate MONEY,\r\n\t\tBudgetDollar_YTD MONEY, \r\n\t\tBudgetDollar_EOY MONEY, \r\n\t\tBudgetDollar_FullYear MONEY);\r\n\r\n\t--for mid year budget added on 05/17/2018--\r\n\tDECLARE @tempActualData TABLE (AgencyCodeOEC VARCHAR(6),\r\n\t\tStartBillingPeriod VARCHAR(6),\r\n\t\tEndBillingPeriod VARCHAR(6),\r\n\t\tReportDataTypeId INT,\r\n\t\tIsProjection BIT,\r\n\t\tActualDollar MONEY,\r\n\t\tActualUsage DECIMAL(20,2),\r\n\t\tActualRate DECIMAL(20,4),\r\n\t\tActualAdjustmentSurplus MONEY,\r\n\t\tActualTenantDollar MONEY,\r\n\t\tActualTenantUsage DECIMAL(20, 2),\r\n\t\tLastMonthActualDollar MONEY);\r\n\r\n\tDECLARE @tempBudgetData TABLE (AgencyCodeOEC VARCHAR(6),\r\n\t\tStartBillingPeriod VARCHAR(6),\r\n\t\tEndBillingPeriod VARCHAR(6),\r\n\t\tReportDataTypeId INT, \r\n\t\tIsProjection BIT,\r\n\t\tIsBreakDownReport BIT,\r\n\t\tBudgetDollar MONEY, \r\n\t\tBudgetUsage DECIMAL(20, 4), \r\n\t\tBudgetRate DECIMAL(20, 4),\r\n\t\tBudgetDollar_YTD MONEY,    \r\n\t\tBudgetDollar_EOY MONEY,    \r\n\t\tBudgetDollar_FullYear MONEY);\r\n\r\n\tIF CAST(RIGHT(@endBillingPeriod, 2) AS INT)<7\r\n\t\tSET @fy=CAST(LEFT(@endBillingPeriod, 4) AS INT)\r\n\tELSE\t\r\n\t\tSET @fy=CAST(LEFT(@endBillingPeriod, 4) AS INT)+1\r\n\r\n\r\n\tIF @IsProjection=1 AND EXISTS (SELECT * FROM budget.Scenario WHERE FY=@fy AND IsCurrentProjection=1)\r\n\t\tSELECT @currentBudgetScenarioId=ISNULL(MAX(ID), 0)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY=@fy AND IsCurrentProjection=1;\r\n\tELSE\r\n\t\tSELECT @currentBudgetScenarioId=ISNULL(MAX(ID), 0)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY=@fy AND IsCurrentBudget=1;\r\n\r\n\tSELECT @tenantChargeId=ISNULL(TenantChargeID, 3), @actualDataEndMonth = CAST(ISNULL(ActualDataEndMonth, 0) AS VARCHAR(6))\r\n\tFROM budget.Scenario\r\n\tWHERE ID=@currentBudgetScenarioId;\r\n\r\n\tIF @agencyCodeOECStr IS NULL OR @agencyCodeOECStr=''\r\n\t\tINSERT INTO @agencyCodeOECs (CODE)\r\n\t\tSELECT AgencyCodeOEC\r\n\t\tFROM Preload.Agency\r\n\t\tWHERE AgencyID IN (SELECT AgencyID FROM preload.AgencyByFY WHERE FY=@fy);\r\n\tELSE\r\n\t\tINSERT INTO @agencyCodeOECs (CODE) SELECT ID AS CODE  FROM dbo.[UDF_SplitToTable] (@agencyCodeOECStr,',');\r\n\r\n\tINSERT INTO @dcasAgencyCODE (CODE) VALUES ('856001');\r\n\tINSERT INTO @dcas856090AgencyCODE (CODE) VALUES ('856090');\r\n\r\n\tINSERT INTO @TNCDetails ( AgencyCodeOEC, ChargePercentage )\r\n\tSELECT AgencyCode, ChargePercentage\r\n\tFROM input.TenantChargeDetail\r\n\tWHERE TenantChargeID=@tenantChargeId AND AgencyCode IN (SELECT CODE FROM @agencyCodeOECs);\r\n\r\n\tIF @actualDataEndMonth='0' --Non Mid Year Budget\r\n\tBEGIN\r\n\t\tINSERT INTO @DCASBudget ( AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear )\r\n\t\tSELECT AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear \r\n\t\tFROM dbo.[UDF_ActualVsBudget_GetBudget] (@startBillingPeriod, @endBillingPeriod, @dcasAgencyCODE, @IsProjection, DEFAULT, DEFAULT, DEFAULT);\r\n\r\n\t\tINSERT INTO @OTHERBudget ( AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear )\r\n\t\tSELECT AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear \r\n\t\tFROM dbo.[UDF_ActualVsBudget_GetBudget] (@startBillingPeriod, @endBillingPeriod, @agencyCodeOECs, @IsProjection, DEFAULT, DEFAULT, DEFAULT);\r\n\r\n\t\tSELECT ISNULL(a.AgencyCodeOEC, b.AgencyCodeOEC) AS AgencyCodeOEC, \r\n\t\t\t@startBillingPeriod AS StartBillingPeriod,\r\n\t\t\t@endBillingPeriod AS EndBillingPeriod,\r\n\t\t\tISNULL(a.ReportDataTypeId, b.ReportDataTypeId) AS ReportDataTypeId, \r\n\t\t\t@IsProjection AS IsProjection,\r\n\t\t\t@IsBreakDownReport AS IsBreakDownReport,\r\n\t\t\tISNULL(a.BudgetDollar, 0)+ISNULL(b.tnc_budgetdollar, 0) AS BudgetDollar, \r\n\t\t\tISNULL(a.BudgetUsage, 0)+ISNULL(b.tnc_budgetusage, 0) AS BudgetUsage, \r\n\t\t\tCASE WHEN ISNULL(a.BudgetUsage, 0)+ISNULL(b.tnc_budgetusage, 0)<>0 THEN\r\n\t\t\t\t(ISNULL(a.BudgetDollar, 0)+ISNULL(b.tnc_budgetdollar, 0))/(ISNULL(a.BudgetUsage, 0)+ISNULL(b.tnc_budgetusage, 0))\r\n\t\t\tELSE 0.00 END AS BudgetRate,\r\n\t\t\tISNULL(a.BudgetDollar_YTD, 0) + ISNULL(b.tnc_budgetdollar_YTD, 0) AS BudgetDollar_YTD,    \r\n\t\t\tISNULL(a.BudgetDollar_EOY, 0) + ISNULL(b.tnc_budgetdollar_EOY, 0) AS BudgetDollar_EOY,    \r\n\t\t\tISNULL(a.BudgetDollar_FullYear, 0) + ISNULL(b.tnc_budgetdollar_FullYear, 0) AS BudgetDollar_FullYear,\r\n\t\t\t0.00 AS ActualAdjustmentSurplus\r\n\t\tFROM @OTHERBudget a FULL JOIN \r\n\t\t(\r\n\t\t\tSELECT b1.AgencyCodeOEC, a1.ReportDataTypeId, \r\n\t\t\tROUND(a1.BudgetDollar*b1.ChargePercentage, 0) AS tnc_budgetdollar,\r\n\t\t\ta1.BudgetUsage*b1.ChargePercentage AS tnc_budgetusage,        \r\n\t\t\ta1.BudgetRate AS tnc_budgetrate,\r\n\t\t\tROUND(a1.BudgetDollar_YTD*b1.ChargePercentage, 0) AS tnc_budgetdollar_YTD,    \r\n\t\t\tROUND(a1.BudgetDollar_EOY*b1.ChargePercentage, 0) AS tnc_budgetdollar_EOY,    \r\n\t\t\tROUND(a1.BudgetDollar_FullYear*b1.ChargePercentage, 0) AS tnc_budgetdollar_FullYear\r\n\t\t\tFROM @DCASBudget a1, @TNCDetails b1\r\n\t\t) b ON a.AgencyCodeOEC=b.AgencyCodeOEC AND a.ReportDataTypeId=b.ReportDataTypeId;\r\n\t\r\n\tEND;\r\n\tELSE --Mid Year Budget added on 05/17/2018\r\n\tBEGIN\t\r\n\t\tIF (@IsBreakDownReport=0 AND @startBillingPeriod=@endBillingPeriod)\r\n\t\tBEGIN\r\n\t\t\tSET @isActVsBgtReport5 = 1;\r\n\t\tEND;\r\n\r\n\t\t--always need actual data\r\n\t\tSELECT @endBillingPeriodForActualData = CASE WHEN @actualDataEndMonth > @endBillingPeriod THEN @endBillingPeriod\r\n\t\t\tELSE @actualDataEndMonth END;\r\n\r\n\t\t\tIF @isActVsBgtReport5=1 --For Actual vs Budget Report #5\r\n\t\t\tBEGIN\r\n\t\t\t\tSELECT @startBillingPeriodForActualData = CASE WHEN CAST(@startBillingPeriod AS INT)%100 >6 THEN LEFT(@startBillingPeriod, 4)+'07'\r\n\t\t\t\t\tELSE CAST(CAST(@startBillingPeriod AS INT)/100-1 AS VARCHAR(4))+'07' END;\r\n\r\n\t\t\t\tINSERT INTO @tempActualData\r\n\t\t\t\tEXEC [report].[USP_ActualVsBudget_RetrieveActualData] \r\n\t\t\t\t\t@startBillingPeriodForActualData,\r\n\t\t\t\t\t@endBillingPeriodForActualData,\r\n\t\t\t\t\t@agencyCodeOECStr,\r\n\t\t\t\t\t@IsProjection;\r\n\t\t\tEND;\r\n\t\t\tELSE\r\n\t\t\tBEGIN\r\n\t\t\t\tINSERT INTO @tempActualData\r\n\t\t\t\tEXEC [report].[USP_ActualVsBudget_RetrieveActualData] \r\n\t\t\t\t\t@startBillingPeriod,\r\n\t\t\t\t\t@endBillingPeriodForActualData,\r\n\t\t\t\t\t@agencyCodeOECStr,\r\n\t\t\t\t\t@IsProjection;\r\n\t\t\tEND;\r\n\r\n\t\t--actual data END;\r\n\r\n\t\tIF @endBillingPeriod > @actualDataEndMonth --need budget data\r\n\t\tBEGIN   \r\n\t\t\tSELECT @startBillingPeriodForBudgetData = CASE WHEN @startBillingPeriod = @endBillingPeriod THEN @endBillingPeriod\r\n\t\t\t\tELSE LEFT(CONVERT(VARCHAR, DATEADD(m, 1, CONVERT(DATE, @actualDataEndMonth + '01', 112)), 112), 6) END;\r\n\t\t\t\t\t\r\n\t\t\tINSERT INTO @DCASBudget (AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear)\r\n\t\t\tSELECT AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear \r\n\t\t\tFROM dbo.[UDF_ActualVsBudget_GetBudget] (@startBillingPeriodForBudgetData, @endBillingPeriod, @dcasAgencyCODE, @IsProjection, @actualDataEndMonth, @isActVsBgtReport5, DEFAULT);\r\n\r\n\t\t\tINSERT INTO @OTHERBudget (AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear)\r\n\t\t\tSELECT AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear \r\n\t\t\tFROM dbo.[UDF_ActualVsBudget_GetBudget] (@startBillingPeriodForBudgetData, @endBillingPeriod, @agencyCodeOECs, @IsProjection, @actualDataEndMonth, @isActVsBgtReport5, DEFAULT);\r\n\r\n\t\t\tINSERT INTO @tempBudgetData\r\n\t\t\tSELECT ISNULL(a.AgencyCodeOEC, b.AgencyCodeOEC) AS AgencyCodeOEC, \r\n\t\t\t\t@startBillingPeriodForBudgetData AS StartBillingPeriod,\r\n\t\t\t\t@endBillingPeriod AS EndBillingPeriod,\r\n\t\t\t\tISNULL(a.ReportDataTypeId, b.ReportDataTypeId) AS ReportDataTypeId, \r\n\t\t\t\t@IsProjection AS IsProjection,\r\n\t\t\t\t@IsBreakDownReport AS IsBreakDownReport,\r\n\t\t\t\tISNULL(a.BudgetDollar, 0)+ISNULL(b.tnc_budgetdollar, 0) AS BudgetDollar, \r\n\t\t\t\tISNULL(a.BudgetUsage, 0)+ISNULL(b.tnc_budgetusage, 0) AS BudgetUsage, \r\n\t\t\t\tCASE WHEN ISNULL(a.BudgetUsage, 0)+ISNULL(b.tnc_budgetusage, 0)<>0 THEN\r\n\t\t\t\t\t(ISNULL(a.BudgetDollar, 0)+ISNULL(b.tnc_budgetdollar, 0))/(ISNULL(a.BudgetUsage, 0)+ISNULL(b.tnc_budgetusage, 0))\r\n\t\t\t\tELSE 0 END AS BudgetRate,\r\n\t\t\t\tISNULL(a.BudgetDollar_YTD, 0) + ISNULL(b.tnc_budgetdollar_YTD, 0) AS BudgetDollar_YTD, \r\n\t\t\t\tISNULL(a.BudgetDollar_EOY, 0) + ISNULL(b.tnc_budgetdollar_EOY, 0) AS BudgetDollar_EOY,\r\n\t\t\t\tISNULL(a.BudgetDollar_FullYear, 0)+ISNULL(b.tnc_budgetdollar_FullYear, 0) AS BudgetDollar_FullYear\t\t\t\t\r\n\t\t\tFROM @OTHERBudget a\r\n\t\t\t\tFULL JOIN  (SELECT b1.AgencyCodeOEC, a1.ReportDataTypeId, \r\n\t\t\t\t\tIIF(@isActVsBgtReport5=1, 0, a1.BudgetDollar*b1.ChargePercentage) AS tnc_budgetdollar,\r\n\t\t\t\t\tIIF(@isActVsBgtReport5=1, 0, a1.BudgetUsage*b1.ChargePercentage) AS tnc_budgetusage,        \r\n\t\t\t\t\ta1.BudgetRate AS tnc_budgetrate,\r\n\t\t\t\t\tIIF(@isActVsBgtReport5=1, 0, a1.BudgetDollar_YTD*b1.ChargePercentage) AS tnc_budgetdollar_YTD,    \r\n\t\t\t\t\tIIF(@isActVsBgtReport5=1, 0, a1.BudgetDollar_EOY*b1.ChargePercentage) AS tnc_budgetdollar_EOY,    \r\n\t\t\t\t\tIIF(@isActVsBgtReport5=1, 0, (a1.BudgetDollar_YTD + a1.BudgetDollar_EOY)*b1.ChargePercentage) AS tnc_budgetdollar_FullYear\r\n\t\t\t\tFROM @DCASBudget a1, @TNCDetails b1) b ON a.AgencyCodeOEC = b.AgencyCodeOEC AND a.ReportDataTypeId = b.ReportDataTypeId;\r\n\t\tEND;\r\n\t\tELSE IF @endBillingPeriod <= @actualDataEndMonth AND @IsBreakDownReport=0 AND @startBillingPeriod=@endBillingPeriod\r\n\t\t--Only need full year budget (For Actual vs Budget Report #5) added on 05/21/2018\r\n\t\tBEGIN\r\n\t\t\tINSERT INTO @OTHERBudget (AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear)\r\n\t\t\tSELECT AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear \r\n\t\t\tFROM dbo.UDF_ActualVsBudget_GetBudget (@endBillingPeriod, @endBillingPeriod, @agencyCodeOECs, @IsProjection, DEFAULT, DEFAULT, DEFAULT);\r\n\r\n\t\t\tINSERT INTO @tempBudgetData\r\n\t\t\tSELECT ISNULL(a.AgencyCodeOEC, b.AgencyCodeOEC) AS AgencyCodeOEC, \r\n\t\t\t\t@endBillingPeriod AS StartBillingPeriod,\r\n\t\t\t\t@endBillingPeriod AS EndBillingPeriod,\r\n\t\t\t\ta.ReportDataTypeId AS ReportDataTypeId, \r\n\t\t\t\t@IsProjection AS IsProjection,\r\n\t\t\t\t@IsBreakDownReport AS IsBreakDownReport,\r\n\t\t\t\t0 AS BudgetDollar, \r\n\t\t\t\t0 AS BudgetUsage, \r\n\t\t\t\t0 AS BudgetRate,\r\n\t\t\t\t0 AS BudgetDollar_YTD,    \r\n\t\t\t\tCASE WHEN RIGHT(@endBillingPeriod, 2) = '06' THEN 0 ELSE ISNULL(b.BudgetDollar_EOY, 0) END AS BudgetDollar_EOY,    \r\n\t\t\t\tISNULL(b.BudgetDollar_FullYear, 0) AS BudgetDollar_FullYear\r\n\t\t\tFROM \r\n\t\t\t(SELECT MIN(ReportDataTypeId) AS ReportDataTypeId, AgencyCodeOEC FROM @OTHERBudget GROUP BY AgencyCodeOEC) a LEFT JOIN \r\n\t\t\t(\r\n\t\t\t\tSELECT AgencyCodeOEC, SUM(TotalDollars) AS BudgetDollar_FullYear,\r\n\t\t\t\tSUM(CASE WHEN BudgetBillingPeriod>@endBillingPeriod THEN TotalDollars ELSE 0 END) AS BudgetDollar_EOY\r\n\t\t\t\tFROM budget.vwTotalBudget\r\n\t\t\t\tWHERE ScenarioId=@currentBudgetScenarioId \r\n\t\t\t\tGROUP BY AgencyCodeOEC\r\n\t\t\t) b ON a.AgencyCodeOEC=b.AgencyCodeOEC;\r\n\r\n\t\tEND; --need budget data end\r\n\r\n\t\tSELECT AgencyCodeOEC,\r\n\t\t\tStartBillingPeriod,\r\n\t\t\tEndBillingPeriod,\r\n\t\t\tReportDataTypeId, \r\n\t\t\tIsProjection,\r\n\t\t\tIsBreakDownReport,\r\n\t\t\tBudgetDollar, \r\n\t\t\tBudgetUsage, \r\n\t\t\tBudgetRate,\r\n\t\t\tBudgetDollar_YTD,    \r\n\t\t\tBudgetDollar_EOY,    \r\n\t\t\tBudgetDollar_FullYear,\r\n\t\t\t0.00 AS ActualAdjustmentSurplus\r\n\t\tFROM @tempBudgetData\r\n\t\tUNION ALL\r\n\t\tSELECT AgencyCodeOEC,\r\n\t\t\tStartBillingPeriod,\r\n\t\t\tEndBillingPeriod,\r\n\t\t\tReportDataTypeId,\r\n\t\t\tIsProjection,\r\n\t\t\t@IsBreakDownReport AS IsBreakDownReport,\r\n\t\t\tCASE WHEN @endBillingPeriod <= @actualDataEndMonth AND @IsBreakDownReport=0 AND @startBillingPeriod=@endBillingPeriod THEN LastMonthActualDollar\r\n\t\t\t\t WHEN @endBillingPeriod > @actualDataEndMonth AND @IsBreakDownReport=0 AND @startBillingPeriod=@endBillingPeriod THEN 0\r\n\t\t\t     ELSE ActualDollar \r\n\t\t\tEND AS BudgetDollar,\r\n\t\t\tActualUsage AS BudgetUsage,\r\n\t\t\tActualRate AS BudgetRate,\r\n\t\t\tActualDollar AS BudgetDollar_YTD,\r\n\t\t\t0 AS BudgetDollar_EOY,\r\n\t\t\t0 AS BudgetDollar_FullYear,\r\n\t\t\tActualAdjustmentSurplus\r\n\t\tFROM @tempActualData;\r\n\tEND; --Mid Year Budget end\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.170000",
      "last_altered": "2025-08-25 15:54:06.170000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@startBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@endBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyCodeOECStr",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@IsProjection",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@IsBreakDownReport",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 5,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ActualVsBudget_RetrieveBudgetData",
      "explanation": "#### 1. Overview\n\nThe stored procedure `USP_ActualVsBudget_RetrieveBudgetData` is designed to retrieve budget data and compare it against actual financial data for specified billing periods. It handles both projections and breakdown reports, and it accommodates mid-year budget adjustments. The procedure uses various temporary tables to store intermediate results and combines data from multiple sources to produce a comprehensive report on budget versus actuals.\n\n#### 2. Complexity Level: High\n\nThe complexity of this stored procedure is high due to several factors:\n- It involves multiple conditional logic branches to handle different scenarios (e.g., mid-year budgets, projections).\n- It uses several temporary tables and user-defined table types to manage data.\n- It includes dynamic date calculations and conditional data retrieval.\n- It interacts with other stored procedures and user-defined functions, adding layers of complexity.\n\n#### 3. Input Parameters\n\n- `@startBillingPeriod AS VARCHAR(6)`: The start of the billing period in 'YYYYMM' format.\n- `@endBillingPeriod AS VARCHAR(6)`: The end of the billing period in 'YYYYMM' format.\n- `@agencyCodeOECStr AS VARCHAR(MAX)`: A comma-separated string of agency codes.\n- `@IsProjection AS BIT = 0`: A flag indicating whether to use projection data (1 for true, 0 for false).\n- `@IsBreakDownReport AS BIT = 1`: A flag indicating whether to generate a breakdown report (1 for true, 0 for false).\n\n#### 4. Business Logic and Workflow\n\n- **Initial Setup**: The procedure begins by setting the transaction isolation level to `READ UNCOMMITTED` to avoid locking issues and declares several variables and temporary tables for processing.\n  \n- **Fiscal Year Calculation**: It determines the fiscal year based on the `@endBillingPeriod`.\n\n- **Scenario Selection**: Depending on whether projections are used, it selects the appropriate budget scenario ID from the `budget.Scenario` table.\n\n- **Agency Code Handling**: If no agency codes are provided, it retrieves them from the `Preload.Agency` table for the specified fiscal year.\n\n- **Tenant Charge Details**: It populates the `@TNCDetails` table with tenant charge details based on the selected tenant charge ID.\n\n- **Budget Data Retrieval**: \n  - For non-mid-year budgets, it retrieves budget data using the `UDF_ActualVsBudget_GetBudget` function and populates the `@DCASBudget` and `@OTHERBudget` tables.\n  - For mid-year budgets, it retrieves actual data using the `USP_ActualVsBudget_RetrieveActualData` procedure and budget data if the end billing period exceeds the actual data end month.\n\n- **Data Combination**: It combines data from the `@DCASBudget`, `@OTHERBudget`, and `@TNCDetails` tables to calculate budget figures, including adjustments for tenant charges.\n\n- **Final Output**: The procedure outputs a union of budget and actual data, formatted to include various budget metrics and adjustments.\n\n#### 5. Performance Considerations\n\n- **Transaction Isolation Level**: Using `READ UNCOMMITTED` can improve performance by reducing locking but may lead to dirty reads.\n- **Temporary Tables**: Extensive use of temporary tables can impact performance, especially if the data volume is large.\n- **Complex Joins and Calculations**: The procedure performs multiple joins and calculations, which can be resource-intensive.\n- **Conditional Logic**: The branching logic for different scenarios can lead to complex execution paths, potentially affecting performance.\n\n#### 6. Potential Issues or Risks\n\n- **Dirty Reads**: The use of `READ UNCOMMITTED` may result in reading uncommitted data, which could lead to inconsistencies.\n- **Scalability**: The procedure's complexity and reliance on temporary tables may not scale well with large datasets.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions.\n- **Dependency on External Functions and Procedures**: The reliance on other stored procedures and functions means changes in those components could affect this procedure's behavior.\n- **Assumptions on Data Integrity**: The procedure assumes that data retrieved from external sources is accurate and complete, which may not always be the case.",
      "complexity": "High",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 5185,
      "api_response_id": "chatcmpl-C8Vn8XvBGPeBQhAOWYHJHXdx0dBt7"
    },
    "analysis_timestamp": "2025-08-25 14:01:34"
  },
  {
    "procedure_info": {
      "schema": "report",
      "name": "USP_ActualVsBudget_RetrieveBudgetData_ByBudgetGroup",
      "definition": "CREATE PROCEDURE [report].[USP_ActualVsBudget_RetrieveBudgetData_ByBudgetGroup]\r\n(\r\n\t@startBillingPeriod AS VARCHAR(6)\r\n\t,@endBillingPeriod AS VARCHAR(6)\r\n\t,@IsProjection AS BIT = 0\r\n\t,@IsBreakDownReport AS BIT = 1\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @fy AS INT, @currentBudgetScenarioId AS INT, @actualDataEndMonth AS VARCHAR(6), @endBillingPeriodForActualData AS VARCHAR(6)\r\n\t\t,@startBillingPeriodForActualData AS VARCHAR(6), @startBillingPeriodForBudgetData AS VARCHAR(6), @isActVsBgtReport6 AS BIT = 0;\r\n\r\n\tDECLARE @BudgetByBudgetGroup TABLE (BudgetGroupID INT,\r\n\t\tReportDataTypeId INT,\r\n\t\tBudgetDollar MONEY,\r\n\t\tBudgetUsage DECIMAL(20, 2),\r\n\t\tBudgetRate MONEY,\r\n\t\tBudgetDollar_YTD MONEY, \r\n\t\tBudgetDollar_EOY MONEY, \r\n\t\tBudgetDollar_FullYear MONEY);\r\n\r\n\t--for mid year budget added on 05/18/2018--\r\n\tDECLARE @tempActualData TABLE (BudgetGroupID INT,\r\n\t\tBudgetGroupName VARCHAR(75),\r\n\t\tStartBillingPeriod VARCHAR(6),\r\n\t\tEndBillingPeriod VARCHAR(6),\r\n\t\tReportDataTypeId INT,\r\n\t\tIsProjection BIT,\r\n\t\tActualDollar MONEY,\r\n\t\tActualUsage DECIMAL(20,2),\r\n\t\tActualRate DECIMAL(20,4),\r\n\t\tActualAdjustmentSurplus MONEY,\r\n\t\tActualTenantDollar MONEY,\r\n\t\tActualTenantUsage DECIMAL(20, 2),\r\n\t\tLastMonthActualDollar MONEY);\r\n\r\n\tDECLARE @tempBudgetData TABLE (BudgetGroupID INT,\r\n\t\tBudgetGroupName VARCHAR(75),\r\n\t\tStartBillingPeriod VARCHAR(6),\r\n\t\tEndBillingPeriod VARCHAR(6),\r\n\t\tReportDataTypeId INT, \r\n\t\tIsProjection BIT,\r\n\t\tIsBreakDownReport BIT,\r\n\t\tBudgetDollar MONEY, \r\n\t\tBudgetUsage DECIMAL(20, 4), \r\n\t\tBudgetRate DECIMAL(20, 4),\r\n\t\tBudgetDollar_YTD MONEY,    \r\n\t\tBudgetDollar_EOY MONEY,    \r\n\t\tBudgetDollar_FullYear MONEY);\r\n\r\n\tIF CAST(RIGHT(@endBillingPeriod, 2) AS INT)<7\r\n\t\tSET @fy=CAST(LEFT(@endBillingPeriod, 4) AS INT)\r\n\tELSE\t\r\n\t\tSET @fy=CAST(LEFT(@endBillingPeriod, 4) AS INT)+1\r\n\r\n\t--for mid year budget added on 05/17/2018--\r\n\tIF @IsProjection=1 AND EXISTS (SELECT * FROM budget.Scenario WHERE FY=@fy AND IsCurrentProjection=1)\r\n\t\tSELECT @currentBudgetScenarioId=ISNULL(MAX(ID), 0)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY=@fy AND IsCurrentProjection=1;\r\n\tELSE\r\n\t\tSELECT @currentBudgetScenarioId=ISNULL(MAX(ID), 0)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY=@fy AND IsCurrentBudget=1;\r\n\r\n\tSELECT @actualDataEndMonth = CAST(ISNULL(ActualDataEndMonth, 0) AS VARCHAR(6))\r\n\tFROM budget.Scenario\r\n\tWHERE ID=@currentBudgetScenarioId;\r\n\r\n\tIF (@actualDataEndMonth = '0') --Non Mid Year Budget\r\n\tBEGIN\r\n\t\tINSERT INTO @BudgetByBudgetGroup (BudgetGroupID, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear)\r\n\t\tSELECT BudgetGroupID, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear \r\n\t\tFROM dbo.UDF_ActualVsBudget_GetBudget_ByBudgetGroup(@startBillingPeriod, @endBillingPeriod, @IsProjection, DEFAULT);\r\n\t\t\r\n\t\tSELECT a.BudgetGroupID, b.BudgetGroupName,\r\n\t\t\t@startBillingPeriod AS StartBillingPeriod,\r\n\t\t\t@endBillingPeriod AS EndBillingPeriod,\r\n\t\t\ta.ReportDataTypeId, \r\n\t\t\t@IsProjection AS IsProjection,\r\n\t\t\t@IsBreakDownReport AS IsBreakDownReport,\r\n\t\t\tISNULL(a.BudgetDollar, 0) AS BudgetDollar, \r\n\t\t\tISNULL(a.BudgetUsage, 0) AS BudgetUsage, \r\n\t\t\tCASE WHEN ISNULL(a.BudgetUsage, 0)<>0 THEN\r\n\t\t\t\tISNULL(a.BudgetDollar, 0)/ISNULL(a.BudgetUsage, 0)\r\n\t\t\tELSE 0.00 END AS BudgetRate,\r\n\t\t\tISNULL(a.BudgetDollar_YTD, 0) AS BudgetDollar_YTD,    \r\n\t\t\tISNULL(a.BudgetDollar_EOY, 0) AS BudgetDollar_EOY,    \r\n\t\t\tISNULL(a.BudgetDollar_FullYear, 0) AS BudgetDollar_FullYear,\r\n\t\t\t0.00 AS ActualAdjustmentSurplus\r\n\t\tFROM @BudgetByBudgetGroup  a\r\n\t\t\tINNER JOIN preload.BudgetGroup b ON a.BudgetGroupID = b.BudgetGroupID\r\n\t\t\tINNER JOIN preload.BudgetGroupByFY c ON b.BudgetGroupID=c.BudgetGroupID\r\n\t\tWHERE c.FY=@fy;\r\n\tEND;\r\n\tELSE --Mid Year Budget added on 05/18/2018\r\n\tBEGIN\r\n\t\tIF (@IsBreakDownReport=0 AND @startBillingPeriod=@endBillingPeriod)\r\n\t\tBEGIN\r\n\t\t\tSET @isActVsBgtReport6 = 1;\r\n\t\tEND;\r\n\t\t\r\n\t\t--always need actual data\r\n\t\tSELECT @endBillingPeriodForActualData = CASE WHEN @actualDataEndMonth > @endBillingPeriod THEN @endBillingPeriod\r\n\t\t\tELSE @actualDataEndMonth END;\r\n\r\n\t\tIF @isActVsBgtReport6 = 1 --For Actual vs Budget Report #6\r\n\t\tBEGIN\t\t\t\t\r\n\t\t\tSELECT @startBillingPeriodForActualData = CASE WHEN CAST(@startBillingPeriod AS INT)%100 >6 THEN LEFT(@startBillingPeriod, 4)+'07' \r\n\t\t\t\tELSE CAST(CAST(@startBillingPeriod AS INT)/100-1 AS VARCHAR(4))+'07' END;\r\n\r\n\t\t\tINSERT INTO @tempActualData\r\n\t\t\tEXEC report.USP_ActualVsBudget_RetrieveActualData_ByBudgetGroup\r\n\t\t\t\t@startBillingPeriodForActualData,\r\n\t\t\t\t@endBillingPeriodForActualData,\r\n\t\t\t\t@IsProjection;\r\n\t\tEND;        \r\n\t\tELSE\r\n\t\tBEGIN\r\n\t\t\tINSERT INTO @tempActualData\r\n\t\t\tEXEC report.USP_ActualVsBudget_RetrieveActualData_ByBudgetGroup\r\n\t\t\t\t@startBillingPeriod,\r\n\t\t\t\t@endBillingPeriodForActualData,\r\n\t\t\t\t@IsProjection;\r\n\t\tEND;\r\n\r\n\t\tIF @endBillingPeriod > @actualDataEndMonth --need budget data\r\n\t\tBEGIN\r\n\t\t\tSELECT @startBillingPeriodForBudgetData = CASE WHEN @startBillingPeriod = @endBillingPeriod THEN @endBillingPeriod\r\n\t\t\t\tELSE LEFT(CONVERT(VARCHAR, DATEADD(m, 1, CONVERT(DATE, @actualDataEndMonth + '01', 112)), 112), 6) END;\r\n\r\n\t\t\tINSERT INTO @BudgetByBudgetGroup (BudgetGroupID, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear)\r\n\t\t\tSELECT BudgetGroupID, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear \r\n\t\t\tFROM dbo.UDF_ActualVsBudget_GetBudget_ByBudgetGroup(@startBillingPeriodForBudgetData, @endBillingPeriod, @IsProjection, @actualDataEndMonth);\r\n\t\t   \r\n\t\t    INSERT INTO @tempBudgetData\r\n\t\t\tSELECT a.BudgetGroupID, b.BudgetGroupName,\r\n\t\t\t\t@startBillingPeriodForBudgetData AS StartBillingPeriod,\r\n\t\t\t\t@endBillingPeriod AS EndBillingPeriod,\r\n\t\t\t\ta.ReportDataTypeId, \r\n\t\t\t\t@IsProjection AS IsProjection,\r\n\t\t\t\t@IsBreakDownReport AS IsBreakDownReport,\r\n\t\t\t\tISNULL(a.BudgetDollar, 0) AS BudgetDollar, \r\n\t\t\t\tISNULL(a.BudgetUsage, 0) AS BudgetUsage, \r\n\t\t\t\tCASE WHEN ISNULL(a.BudgetUsage, 0)<>0 THEN\r\n\t\t\t\t\tISNULL(a.BudgetDollar, 0)/ISNULL(a.BudgetUsage, 0)\r\n\t\t\t\tELSE 0 END AS BudgetRate,\r\n\t\t\t\tISNULL(a.BudgetDollar_YTD, 0) AS BudgetDollar_YTD,    \r\n\t\t\t\tISNULL(a.BudgetDollar_EOY, 0) AS BudgetDollar_EOY,    \r\n\t\t\t\tISNULL(a.BudgetDollar_FullYear, 0) AS BudgetDollar_FullYear\r\n\t\t\tFROM @BudgetByBudgetGroup  a JOIN preload.BudgetGroup b ON a.BudgetGroupID=b.BudgetGroupID\r\n\t\t\t\tJOIN preload.BudgetGroupByFY c ON b.BudgetGroupID=c.BudgetGroupID\r\n\t\t\tWHERE c.FY=@fy;\r\n\t\tEND;\r\n\t\tELSE IF @endBillingPeriod <= @actualDataEndMonth AND @IsBreakDownReport=0 AND @startBillingPeriod=@endBillingPeriod\r\n\t\t--Only need full year budget (For Actual vs Budget Report #6) added on 05/21/2018\r\n\t\tBEGIN\r\n\t\t\tINSERT INTO @BudgetByBudgetGroup (BudgetGroupID, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear)\r\n\t\t\tSELECT BudgetGroupID, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear \r\n\t\t\tFROM dbo.UDF_ActualVsBudget_GetBudget_ByBudgetGroup(@endBillingPeriod, @endBillingPeriod, @IsProjection, DEFAULT);\r\n\t\t   \r\n\t\t    INSERT INTO @tempBudgetData\r\n\t\t\tSELECT a.BudgetGroupID, b.BudgetGroupName,\r\n\t\t\t\t@endBillingPeriod AS StartBillingPeriod,\r\n\t\t\t\t@endBillingPeriod AS EndBillingPeriod,\r\n\t\t\t\ta.ReportDataTypeId, \r\n\t\t\t\t@IsProjection AS IsProjection,\r\n\t\t\t\t@IsBreakDownReport AS IsBreakDownReport,\r\n\t\t\t\t0 AS BudgetDollar, \r\n\t\t\t\t0 AS BudgetUsage, \r\n\t\t\t\t0 AS BudgetRate,\r\n\t\t\t\t0 AS BudgetDollar_YTD,    \r\n\t\t\t\tCASE WHEN RIGHT(@endBillingPeriod, 2) = '06' THEN 0 ELSE ISNULL(a.BudgetDollar_EOY, 0) END AS BudgetDollar_EOY,    \r\n\t\t\t\tISNULL(a.BudgetDollar_FullYear, 0) AS BudgetDollar_FullYear\r\n\t\t\tFROM @BudgetByBudgetGroup  a\r\n\t\t\t\tINNER JOIN preload.BudgetGroup b ON a.BudgetGroupID = b.BudgetGroupID\r\n\t\t\t\tINNER JOIN preload.BudgetGroupByFY c ON b.BudgetGroupID = c.BudgetGroupID\r\n\t\t\tWHERE c.FY=@fy;\r\n\t\tEND;\r\n\r\n\t\tSELECT BudgetGroupID,\r\n\t\t\tBudgetGroupName,\r\n\t\t\tStartBillingPeriod,\r\n\t\t\tEndBillingPeriod,\r\n\t\t\tReportDataTypeId, \r\n\t\t\tIsProjection,\r\n\t\t\tIsBreakDownReport,\r\n\t\t\tBudgetDollar, \r\n\t\t\tBudgetUsage, \r\n\t\t\tBudgetRate,\r\n\t\t\tBudgetDollar_YTD,    \r\n\t\t\tBudgetDollar_EOY,    \r\n\t\t\tBudgetDollar_FullYear,\r\n\t\t\t0.00 AS ActualAdjustmentSurplus\r\n\t\tFROM @tempBudgetData\r\n\t\tUNION ALL\r\n\t\tSELECT BudgetGroupID,\r\n\t\t\tBudgetGroupName,\r\n\t\t\tStartBillingPeriod,\r\n\t\t\tEndBillingPeriod,\r\n\t\t\tReportDataTypeId,\r\n\t\t\tIsProjection,\r\n\t\t\t@IsBreakDownReport AS IsBreakDownReport,\r\n\t\t\tCASE WHEN @endBillingPeriod <= @actualDataEndMonth AND @IsBreakDownReport=0 AND @startBillingPeriod=@endBillingPeriod THEN LastMonthActualDollar\r\n\t\t\t\t WHEN @endBillingPeriod > @actualDataEndMonth AND @IsBreakDownReport=0 AND @startBillingPeriod=@endBillingPeriod THEN 0\r\n\t\t\t     ELSE ActualDollar \r\n\t\t\tEND AS BudgetDollar,\r\n\t\t\tActualUsage AS BudgetUsage,\r\n\t\t\tActualRate AS BudgetRate,\r\n\t\t\tActualDollar AS BudgetDollar_YTD,\r\n\t\t\t0 AS BudgetDollar_EOY,\r\n\t\t\t0 AS BudgetDollar_FullYear,\r\n\t\t\tActualAdjustmentSurplus\r\n\t\tFROM @tempActualData;\r\n\tEND;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.187000",
      "last_altered": "2025-08-25 15:54:06.187000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@startBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@endBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@IsProjection",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 3,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@IsBreakDownReport",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0,
        "ordinal_position": 4,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ActualVsBudget_RetrieveBudgetData_ByBudgetGroup",
      "explanation": "#### 1. Overview\n\nThe stored procedure `USP_ActualVsBudget_RetrieveBudgetData_ByBudgetGroup` is designed to retrieve budget data by budget group for a specified billing period range. It compares actual financial data against budgeted data, potentially including projections, and can generate detailed breakdown reports. The procedure handles both mid-year and full-year budget scenarios, adjusting its logic based on whether the data is for a projection or a breakdown report.\n\n#### 2. Complexity Level: Medium\n\nThe complexity level is medium due to the following factors:\n- Conditional logic based on fiscal year, projection status, and report type.\n- Use of temporary tables to manage intermediate data.\n- Integration with user-defined functions and other stored procedures.\n- Handling of both mid-year and full-year budget scenarios.\n\n#### 3. Input Parameters\n\n- `@startBillingPeriod AS VARCHAR(6)`: The start of the billing period in 'YYYYMM' format.\n- `@endBillingPeriod AS VARCHAR(6)`: The end of the billing period in 'YYYYMM' format.\n- `@IsProjection AS BIT = 0`: A flag indicating whether the data should include projections (1 for true, 0 for false).\n- `@IsBreakDownReport AS BIT = 1`: A flag indicating whether the report should be a detailed breakdown (1 for true, 0 for false).\n\n#### 4. Business Logic and Workflow\n\n1. **Initial Setup**: \n   - Sets the transaction isolation level to `READ UNCOMMITTED` to avoid locking issues.\n   - Determines the fiscal year (`@fy`) based on the `@endBillingPeriod`.\n\n2. **Scenario Selection**:\n   - Selects the current budget scenario ID based on whether projections are included.\n\n3. **Actual Data End Month**:\n   - Retrieves the end month for actual data from the budget scenario.\n\n4. **Data Retrieval**:\n   - **Non Mid-Year Budget**: Directly retrieves budget data using a user-defined function and joins with budget group information.\n   - **Mid-Year Budget**: \n     - Determines the appropriate billing periods for actual and budget data.\n     - Retrieves actual data using another stored procedure.\n     - Retrieves budget data if the end billing period exceeds the actual data end month.\n\n5. **Data Consolidation**:\n   - Combines actual and budget data into a final result set using `UNION ALL`.\n\n#### 5. Performance Considerations\n\n- **Transaction Isolation Level**: Using `READ UNCOMMITTED` can improve performance by reducing locking but may lead to reading uncommitted data.\n- **Temporary Tables**: The use of temporary tables can impact performance, especially if the data volume is large.\n- **Conditional Logic**: The procedure contains multiple conditional branches, which can affect execution time depending on the complexity of the conditions.\n- **External Dependencies**: Calls to user-defined functions and other stored procedures can introduce latency.\n\n#### 6. Potential Issues or Risks\n\n- **Data Integrity**: The use of `READ UNCOMMITTED` may lead to dirty reads, which could affect the accuracy of the report.\n- **Scalability**: As data volume grows, the use of temporary tables and complex joins may lead to performance bottlenecks.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions or incomplete data processing.\n- **Maintenance**: The complexity of the logic, especially with multiple conditional branches, may make the procedure difficult to maintain or modify.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 3578,
      "api_response_id": "chatcmpl-C8Vnc05X2jTVnp5BmcdIulTONC2ku"
    },
    "analysis_timestamp": "2025-08-25 14:02:01"
  },
  {
    "procedure_info": {
      "schema": "report",
      "name": "USP_ReportBaseUsageForAgencies",
      "definition": "CREATE PROCEDURE [report].[USP_ReportBaseUsageForAgencies]\r\n(\r\n\t@fy AS INT\r\n    ,@agencyIds AS VARCHAR(MAX) = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET FMTONLY OFF;\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @agencyIdList AS input.UDT_IDList;\r\n\r\n\tINSERT INTO @agencyIdList(ID)\r\n\tSELECT ID FROM dbo.UDF_SplitToTable(@agencyIds,',');\r\n\r\n\tWITH dataTbl AS (SELECT a.AgencyCodeOEC, b.EnergyType, b.EnergyUnit,\r\n\t\t\ta.BillingPeriod, a.BillingPeriod % 100 AS mm,\r\n\t\t\ta.BaseEnergyUsage, a.BaseDemandUsage,\r\n\t\t\ta.NormalizedEnergyUsage, a.NormalizedDemandUsage\r\n\t\tFROM preload.EC3BaseData a JOIN Preload.BudgetGroup b ON a.BudgetGroupDEM=b.BudgetGroupID\r\n\t\tWHERE a.fy=@fy\r\n\t\t\tAND EXISTS (SELECT 1 FROM Preload.BudgetGroupByFY where a.fy=fy AND a.BudgetGroupDEM=BudgetGroupID)\r\n\t\t\tAND EXISTS (SELECT 1 FROM Preload.AgencyByFY a1 JOIN Preload.Agency b1 ON a1.AgencyId=b1.AgencyId WHERE a1.fy=@fy AND a.AgencyCodeOEC=b1.AgencyCodeOEC))\r\n\t,agencySortingTbl AS (SELECT a.agencyid, c.AgencyCodeOEC AS SortingAgencyCode1, b.AgencyCodeOEC AS SortingAgencyCode2\r\n\t\t\t,CASE WHEN b.AgencyCodeOEC=d.AgencyCodeOEC THEN '' ELSE d.AgencyCodeOEC END AS SortingAgencyCode3\r\n\t\tFROM Preload.AgencyByFY a\r\n\t\t\tINNER JOIN Preload.Agency b ON CASE WHEN a.AgencyDivisionHierarchy.GetLevel()=1 THEN  a.AgencyId\r\n\t\t\t\tWHEN a.AgencyDivisionHierarchy.GetLevel()=2 THEN  a.AgencyId\r\n\t\t\t\tELSE CAST(REPLACE(REPLACE(AgencyDivisionHierarchy.GetAncestor(1).ToString(), AgencyDivisionHierarchy.GetAncestor(2).ToString(), ''), '/', '') AS INT)\r\n\t\t\t\tEND=b.AgencyId\r\n\t\t\tINNER JOIN Preload.Agency c ON CASE WHEN a.AgencyDivisionHierarchy.GetLevel()=1 THEN a.AgencyId\r\n\t\t\t\tWHEN a.AgencyDivisionHierarchy.GetLevel()=2 THEN CAST(REPLACE(a.AgencyDivisionHierarchy.GetAncestor(1).ToString(), '/', '') AS INT)\r\n\t\t\t\tELSE CAST(REPLACE(a.AgencyDivisionHierarchy.GetAncestor(2).ToString(), '/', '') AS INT)\r\n\t\t\t\tEND=c.AgencyId\r\n\t\t\tINNER JOIN Preload.Agency d ON a.AgencyId=d.AgencyId\r\n\t\tWHERE a.fy=@fy)\r\n\t,pivotTbl AS (SELECT 1 AS BudgetStagetID, EnergyType + ' Energy Usage (' + EnergyUnit + ')' AS Subtype , AgencyCodeOEC\r\n\t\t\t,ISNULL([7],0)+ISNULL([8],0)+ISNULL([9],0)+ISNULL([10],0)+ISNULL([11],0)+ISNULL([12],0)+ISNULL([1],0)+ISNULL([2],0)+ISNULL([3],0)+ISNULL([4],0)+ISNULL([5],0)+ISNULL([6],0) AS Total\r\n\t\t\t,[7] AS JUL, [8] AS AUG, [9] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[1] AS JAN, [2] AS FEB, [3] AS MAR, [4] AS APR, [5] AS MAY, [6] AS JUN\r\n\t\tFROM dataTbl\r\n\t\tPIVOT (SUM(BaseEnergyUsage) FOR mm IN ([7],[8],[9],[10],[11],[12],[1],[2],[3],[4],[5],[6])) AS Total\r\n\t\tUNION all\r\n\t\tSELECT 1 AS BudgetStagetID, 'Demand Usage (KW)' AS Subtype, AgencyCodeOEC\r\n\t\t\t,ISNULL([7],0)+ISNULL([8],0)+ISNULL([9],0)+ISNULL([10],0)+ISNULL([11],0)+ISNULL([12],0)+ISNULL([1],0)+ISNULL([2],0)+ISNULL([3],0)+ISNULL([4],0)+ISNULL([5],0)+ISNULL([6],0) AS Total\r\n\t\t\t,[7] AS JUL, [8] AS AUG, [9] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[1] AS JAN, [2] AS FEB, [3] AS MAR, [4] AS APR, [5] AS MAY, [6] AS JUN\r\n\t\tFROM dataTbl\r\n\t\tPIVOT (SUM(BaseDemandUsage) FOR mm IN ([7],[8],[9],[10],[11],[12],[1],[2],[3],[4],[5],[6])) AS Total\r\n\t\tUNION all\r\n\t\tSELECT 2 AS BudgetStagetID, EnergyType + ' Energy Usage (' + EnergyUnit + ')' AS Subtype, AgencyCodeOEC\r\n\t\t\t,ISNULL([7],0)+ISNULL([8],0)+ISNULL([9],0)+ISNULL([10],0)+ISNULL([11],0)+ISNULL([12],0)+ISNULL([1],0)+ISNULL([2],0)+ISNULL([3],0)+ISNULL([4],0)+ISNULL([5],0)+ISNULL([6],0) AS Total\r\n\t\t\t,[7] AS JUL, [8] AS AUG, [9] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[1] AS JAN, [2] AS FEB, [3] AS MAR, [4] AS APR, [5] AS MAY, [6] AS JUN\r\n\t\tFROM dataTbl\r\n\t\tPIVOT (SUM(NormalizedEnergyUsage) FOR mm IN ([7],[8],[9],[10],[11],[12],[1],[2],[3],[4],[5],[6])) AS Total\r\n\t\tUNION all\r\n\t\tSELECT 2 AS BudgetStagetID, 'Demand Usage (KW)' AS Subtype, AgencyCodeOEC\r\n\t\t\t,ISNULL([7],0)+ISNULL([8],0)+ISNULL([9],0)+ISNULL([10],0)+ISNULL([11],0)+ISNULL([12],0)+ISNULL([1],0)+ISNULL([2],0)+ISNULL([3],0)+ISNULL([4],0)+ISNULL([5],0)+ISNULL([6],0) AS Total\r\n\t\t\t,[7] AS JUL, [8] AS AUG, [9] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[1] AS JAN, [2] AS FEB, [3] AS MAR, [4] AS APR, [5] AS MAY, [6] AS JUN\r\n\t\tFROM dataTbl\r\n\t\tPIVOT (SUM(NormalizedDemandUsage) FOR mm IN ([7],[8],[9],[10],[11],[12],[1],[2],[3],[4],[5],[6])) AS Total)\r\n\t,sumTbl AS (SELECT AgencyCodeOEC, BudgetStagetID, Subtype,\r\n\t\t\tSUM(total) AS Total,\r\n\t\t\tSUM(JUL) AS JUL, SUM(AUG) AS AUG, SUM(SEP) AS SEP, SUM(OCT) AS OCT, SUM(NOV) AS NOV, SUM(DEC) AS DEC,\r\n\t\t\tSUM(JAN) AS JAN, SUM(FEB) AS FEB, SUM(MAR) AS MAR, SUM(APR) AS APR, SUM(MAY) AS MAY, SUM(JUN) AS JUN\r\n\t\tFROM pivotTbl\r\n\t\tGROUP BY AgencyCodeOEC, BudgetStagetID, Subtype\r\n\t\tHAVING SUM(total) <> 0)\r\n\t,hasAgencyTbl AS (SELECT b.ParentAgencyId, b.ParentAgencyCodeOEC, c.AgencyDescription AS ParentAgencyName, f.AgencyDivisionHierarchy.ToString() AS AgencyParents, \r\n\t\t\tb.ChildAgencyId, b.ChildAgencyCodeOEC, d.AgencyDescription AS ChildAgencyName,\r\n\t\t\td.AgencyFundingSeqId AS ChildAgencyFundingSeqId, a.Subtype,\r\n\t\t\tDENSE_RANK() OVER (PARTITION BY b.ParentAgencyId ORDER BY IIF(d.AgencyFundingSeqId NOT IN (6,9), 0, d.AgencyFundingSeqId)) AS fundingRank,\r\n\t\t\tDENSE_RANK() OVER (PARTITION BY b.ParentAgencyId ORDER BY a.Subtype) AS subtypeRank,\r\n\t\t\tCASE WHEN d.AgencyFundingSeqId NOT IN (6,9) THEN 'Funded Category' ELSE d.FundingSourceDescription END AS ChildFundingSourceDescription,\r\n\t\t\tIIF(b.ParentAgencyId<>b.ChildAgencyId, 1, 0) AS IsRoot,\r\n\t\t\ta.BudgetStagetID, e.BudgetStageName,\r\n\t\t\ta.Total,\r\n\t\t\ta.JUL, a.AUG, a.SEP, a.OCT, a.NOV, a.DEC,\r\n\t\t\ta.JAN, a.FEB, a.MAR, a.APR, a.MAY, a.JUN\r\n\t\tFROM sumTbl a JOIN Preload.vwAgencyHierarchy b ON a.AgencyCodeOEC=b.childAgencyCodeOEC\r\n\t\t\tINNER JOIN preload.Agency c ON b.ParentAgencyId=c.AgencyId\r\n\t\t\tINNER JOIN Preload.Agency d ON b.ChildAgencyId=d.AgencyId\r\n\t\t\tINNER JOIN budget.BudgetStage e ON a.BudgetStagetID=e.BudgetStageID\r\n\t\t\tINNER JOIN Preload.AgencyByFY f ON f.fy=@fy AND b.ParentAgencyId=f.AgencyId\r\n\t\tWHERE b.fy = @fy AND (@agencyIds IS NULL OR (@agencyIds IS NOT NULL AND b.ParentAgencyId IN (SELECT ID FROM @agencyIdList))))\r\n\r\n\tSELECT @fy AS FY, a.ParentAgencyId AS AgencyId, a.ParentAgencyCodeOEC AS AgencyCodeOEC, a.ParentAgencyName AS AgencyDescription, a.AgencyParents,\r\n\t\ta.ChildFundingSourceDescription, a.IsRoot, a.BudgetStageName, a.Subtype, \r\n\t\tSUM(a.total) AS Total,\r\n\t\tSUM(JUL) AS JUL, SUM(AUG) AS AUG, SUM(SEP) AS SEP, SUM(OCT) AS OCT, SUM(NOV) AS NOV, SUM(DEC) AS [DEC],\r\n\t\tSUM(JAN) AS JAN, SUM(FEB) AS FEB, SUM(MAR) AS MAR, SUM(APR) AS APR, SUM(MAY) AS MAY, SUM(JUN) AS JUN,\r\n\t\tCASE WHEN MAX(a.fundingRank) OVER (PARTITION BY a.ParentAgencyId)=1 THEN 0 ELSE 1 END AS ShowAgencyTotal,\r\n\t\t(COUNT(1) OVER (PARTITION BY a.ParentAgencyId))/2 + (CASE WHEN MAX(a.fundingRank) OVER (PARTITION BY a.ParentAgencyId)=1 THEN 0 ELSE MAX(a.subtypeRank) OVER (PARTITION BY a.ParentAgencyId) END) AS Level1Rowspan, \r\n\t\t(COUNT(1) OVER (PARTITION BY a.ParentAgencyId, a.ChildFundingSourceDescription))/2 AS Level2Rowspan,\r\n\t\tMAX(a.subtypeRank) OVER (PARTITION BY a.ParentAgencyId) AS SubtotalRowspan,\r\n\t\tb.SortingAgencyCode1, b.SortingAgencyCode2, b.SortingAgencyCode3\r\n\tFROM hasAgencyTbl a\r\n\t\tINNER JOIN agencySortingTbl b ON a.ParentAgencyId=b.AgencyId\r\n\tGROUP BY a.ParentAgencyId, a.ParentAgencyCodeOEC, a.ParentAgencyName, a.AgencyParents, a.ChildFundingSourceDescription, a.IsRoot\r\n\t\t,a.BudgetStageName, a.Subtype, a.fundingRank, a.subtypeRank, b.SortingAgencyCode1, b.SortingAgencyCode2, b.SortingAgencyCode3\r\n\tORDER BY b.SortingAgencyCode1, b.SortingAgencyCode2, b.SortingAgencyCode3, a.ChildFundingSourceDescription, a.BudgetStageName\r\n\t\t,CASE WHEN LEFT(a.Subtype,1)='C' THEN 'yyy' WHEN LEFT(a.Subtype,1)='D' THEN 'zzz' ELSE a.Subtype END;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.200000",
      "last_altered": "2025-08-25 15:54:06.200000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@agencyIds",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ReportBaseUsageForAgencies",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ReportBaseUsageForAgencies` is designed to generate a report on energy usage for various agencies within a specified fiscal year. It processes energy consumption data, organizes it by agency, and outputs a structured summary that includes both base and normalized energy and demand usage. The procedure uses several Common Table Expressions (CTEs) to transform and aggregate data, ultimately producing a detailed report that can be used for analysis and decision-making.\n\n#### 2. Complexity Level: High\nThe complexity of this stored procedure is high due to the following reasons:\n- It involves multiple CTEs for data transformation and aggregation.\n- It uses dynamic SQL constructs like PIVOT to reshape data.\n- It incorporates hierarchical data processing and ranking.\n- It includes conditional logic for data filtering and sorting.\n\n#### 3. Input Parameters\n- `@fy AS INT`: Represents the fiscal year for which the report is generated. It is a mandatory parameter.\n- `@agencyIds AS VARCHAR(MAX) = NULL`: A comma-separated list of agency IDs to filter the report. It is optional; if not provided, the report includes all agencies.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting the transaction isolation level to READ UNCOMMITTED to avoid locking issues and improve performance.\n2. **Agency ID List Preparation**: It converts the comma-separated `@agencyIds` into a table format using a user-defined function `UDF_SplitToTable`.\n3. **Data Extraction and Transformation**:\n   - **dataTbl CTE**: Joins `EC3BaseData` and `BudgetGroup` tables to extract relevant energy usage data for the specified fiscal year. It filters data based on the existence of related records in `BudgetGroupByFY` and `AgencyByFY`.\n   - **agencySortingTbl CTE**: Determines sorting codes for agencies based on their hierarchical levels and relationships.\n4. **Data Pivoting**:\n   - **pivotTbl CTE**: Uses the PIVOT operator to transform monthly energy usage data into a tabular format with columns for each month and total usage.\n5. **Aggregation**:\n   - **sumTbl CTE**: Aggregates the pivoted data by agency and subtype, filtering out records with zero total usage.\n6. **Hierarchical Data Processing**:\n   - **hasAgencyTbl CTE**: Joins with `vwAgencyHierarchy` to incorporate hierarchical agency information, including funding sources and ranks.\n7. **Final Selection and Ordering**: The final SELECT statement aggregates and orders the data, applying additional calculations for row spans and sorting based on agency hierarchy and funding source.\n\n#### 5. Performance Considerations\n- **READ UNCOMMITTED Isolation Level**: Improves performance by reducing locking but may lead to dirty reads.\n- **Use of CTEs**: While CTEs improve readability, they can impact performance if not optimized, especially with large datasets.\n- **PIVOT Operations**: These can be resource-intensive, particularly with large datasets and multiple columns.\n- **Indexing**: Proper indexing on tables like `EC3BaseData`, `BudgetGroup`, and `AgencyByFY` can significantly enhance performance.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The use of READ UNCOMMITTED may result in reading uncommitted data, which could lead to inconsistencies.\n- **Scalability**: The procedure's complexity and use of multiple CTEs and PIVOT operations may affect scalability with large datasets.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions during execution.\n- **Dependency on External Functions**: The procedure relies on `UDF_SplitToTable` and other views, which must be correctly implemented and performant.\n- **Assumption of Data Integrity**: The procedure assumes that related data exists in all joined tables, which may not always be the case, potentially leading to incomplete results.",
      "complexity": "High",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 3705,
      "api_response_id": "chatcmpl-C8Vo2PlIZFMgaKWbFiKKWFJ4cT3Hx"
    },
    "analysis_timestamp": "2025-08-25 14:02:16"
  },
  {
    "procedure_info": {
      "schema": "report",
      "name": "USP_ReportBaseUsageForBudgetGroups",
      "definition": "CREATE PROCEDURE [report].[USP_ReportBaseUsageForBudgetGroups]\r\n(\r\n\t@fy AS INT\r\n\t,@budgetGroupIds AS VARCHAR(MAX) = NULL\r\n)\r\nAS\r\nBEGIN\r\n\tSET FMTONLY OFF;\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @budgetGroupIdList AS input.UDT_IDList;\r\n\tINSERT INTO @budgetGroupIdList (ID) SELECT ID FROM dbo.UDF_SplitToTable(@budgetGroupIds, ',');\r\n\r\n\tWITH dataTbl AS (\r\n\t\tSELECT a.BudgetGroupDEM, b.BudgetGroupName, b.EnergyType, b.EnergyUnit\r\n\t\t\t,a.BillingPeriod, a.BillingPeriod % 100 AS mm\r\n\t\t\t,SUM(a.BaseEnergyUsage) AS BaseEnergyUsage, SUM(a.BaseDemandUsage) AS BaseDemandUsage\r\n\t\t\t,SUM(a.NormalizedEnergyUsage) AS NormalizedEnergyUsage, SUM(a.NormalizedDemandUsage) AS NormalizedDemandUsage\r\n\t\tFROM preload.EC3BaseData a JOIN Preload.BudgetGroup b ON a.BudgetGroupDEM = b.BudgetGroupID\r\n\t\tWHERE a.fy = @fy AND (@budgetGroupIds IS NULL OR (@budgetGroupIds IS NOT NULL AND b.BudgetGroupID IN (SELECT ID FROM @budgetGroupIdList)))\r\n\t\t\tAND EXISTS (SELECT 1 \r\n\t\t\t\tFROM Preload.BudgetGroupByFY \r\n\t\t\t\tWHERE fy=@fy AND BudgetGroupID = b.BudgetGroupID)\r\n\t\t\tAND EXISTS (SELECT 1 \r\n\t\t\t\tFROM Preload.AgencyByFY a1 JOIN Preload.Agency b1 ON a1.AgencyID=b1.AgencyID \r\n\t\t\t\tWHERE a1.fy=@fy AND b1.AgencyCodeOEC =  a.AgencyCodeOEC)\r\n\t\tGROUP BY a.BudgetGroupDEM, b.BudgetGroupName, b.EnergyType, b.EnergyUnit, a.BillingPeriod\r\n\t)\r\n\t,pivotTbl AS ( \r\n\t\tSELECT 1 AS BudgetStagetID, EnergyType + ' Energy Usage (' + EnergyUnit + ')' AS Subtype, BudgetGroupDEM, BudgetGroupName--, EnergyType, EnergyUnit\r\n\t\t\t,ISNULL([7],0)+ISNULL([8],0)+ISNULL([9],0)+ISNULL([10],0)+ISNULL([11],0)+ISNULL([12],0)+ISNULL([1],0)+ISNULL([2],0)+ISNULL([3],0)+ISNULL([4],0)+ISNULL([5],0)+ISNULL([6],0) AS Total\r\n\t\t\t,[7] AS JUL, [8] AS AUG, [9] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[1] AS JAN, [2] AS FEB, [3] AS MAR, [4] AS APR, [5] AS MAY, [6] AS JUN\r\n\t\tFROM dataTbl\r\n\t\tPIVOT (SUM(BaseEnergyUsage) FOR mm IN ([7],[8],[9],[10],[11],[12],[1],[2],[3],[4],[5],[6])) AS Total\r\n\t\tUNION all\r\n\t\tSELECT 1 AS BudgetStagetID, 'Demand Usage (KW)' AS Subtype, BudgetGroupDEM, BudgetGroupName--, EnergyType, EnergyUnit\r\n\t\t\t,ISNULL([7],0)+ISNULL([8],0)+ISNULL([9],0)+ISNULL([10],0)+ISNULL([11],0)+ISNULL([12],0)+ISNULL([1],0)+ISNULL([2],0)+ISNULL([3],0)+ISNULL([4],0)+ISNULL([5],0)+ISNULL([6],0) AS Total\r\n\t\t\t,[7] AS JUL, [8] AS AUG, [9] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[1] AS JAN, [2] AS FEB, [3] AS MAR, [4] AS APR, [5] AS MAY, [6] AS JUN\r\n\t\tFROM dataTbl\r\n\t\tPIVOT (SUM(BaseDemandUsage) FOR mm IN ([7],[8],[9],[10],[11],[12],[1],[2],[3],[4],[5],[6])) AS Total\r\n\t\tUNION all\r\n\t\tSELECT 2 AS BudgetStagetID, EnergyType + ' Energy Usage (' + EnergyUnit + ')' AS Subtype, BudgetGroupDEM, BudgetGroupName--, EnergyType, EnergyUnit\r\n\t\t\t,ISNULL([7],0)+ISNULL([8],0)+ISNULL([9],0)+ISNULL([10],0)+ISNULL([11],0)+ISNULL([12],0)+ISNULL([1],0)+ISNULL([2],0)+ISNULL([3],0)+ISNULL([4],0)+ISNULL([5],0)+ISNULL([6],0) AS Total\r\n\t\t\t,[7] AS JUL, [8] AS AUG, [9] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[1] AS JAN, [2] AS FEB, [3] AS MAR, [4] AS APR, [5] AS MAY, [6] AS JUN\r\n\t\tFROM dataTbl\r\n\t\tPIVOT (SUM(NormalizedEnergyUsage) FOR mm IN ([7],[8],[9],[10],[11],[12],[1],[2],[3],[4],[5],[6])) AS Total\r\n\t\tUNION all\r\n\t\tSELECT 2 AS BudgetStagetID, 'Demand Usage (KW)' AS Subtype, BudgetGroupDEM, BudgetGroupName--, EnergyType, EnergyUnit\r\n\t\t\t,ISNULL([7],0)+ISNULL([8],0)+ISNULL([9],0)+ISNULL([10],0)+ISNULL([11],0)+ISNULL([12],0)+ISNULL([1],0)+ISNULL([2],0)+ISNULL([3],0)+ISNULL([4],0)+ISNULL([5],0)+ISNULL([6],0) AS Total\r\n\t\t\t,[7] AS JUL, [8] AS AUG, [9] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[1] AS JAN, [2] AS FEB, [3] AS MAR, [4] AS APR, [5] AS MAY, [6] AS JUN\r\n\t\tFROM dataTbl\r\n\t\tPIVOT (SUM(NormalizedDemandUsage) FOR mm IN ([7],[8],[9],[10],[11],[12],[1],[2],[3],[4],[5],[6])) AS Total\r\n\t)\r\n\t,sumTbl AS\r\n    (\r\n\t\tSELECT BudgetGroupDEM, BudgetGroupName, BudgetStagetID, Subtype --EnergyType, EnergyUnit, SubtypeDesc,\r\n\t\t\t,SUM(total) AS Total\r\n\t\t\t,SUM(JUL) AS JUL, SUM(AUG) AS AUG, SUM(SEP) AS SEP, SUM(OCT) AS OCT, SUM(NOV) AS NOV, SUM(DEC) AS DEC\r\n\t\t\t,SUM(JAN) AS JAN, SUM(FEB) AS FEB, SUM(MAR) AS MAR, SUM(APR) AS APR, SUM(MAY) AS MAY, SUM(JUN) AS JUN\r\n\t\tFROM pivotTbl\r\n\t\tGROUP BY BudgetGroupDEM, BudgetGroupName, BudgetStagetID, Subtype --EnergyType, EnergyUnit, SubtypeDesc\r\n\t\tHAVING SUM(total) <> 0\r\n\t)\r\n\tSELECT @fy AS FY, a.BudgetGroupDEM, a.BudgetGroupName\r\n\t\t,a.BudgetStagetID, b.BudgetStageDesc, a.Subtype\r\n\t\t,a.Total\r\n\t\t,a.JUL, a.AUG, a.SEP, a.OCT, a.NOV, a.DEC\r\n\t\t,a.JAN, a.FEB, a.MAR, a.APR, a.MAY, a.JUN\r\n\t\t,CAST(CEILING((COUNT(1) OVER (PARTITION BY a.BudgetGroupDEM)) / 2.0) AS INTEGER) AS Level1Rowspan\r\n\tFROM sumTbl a JOIN budget.BudgetStage b ON a.BudgetStagetID = b.BudgetStageID\r\n\tORDER BY a.BudgetGroupDEM, a.BudgetStagetID, a.Subtype;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.210000",
      "last_altered": "2025-08-25 15:54:06.210000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      },
      {
        "name": "@budgetGroupIds",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0,
        "ordinal_position": 2,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ReportBaseUsageForBudgetGroups",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ReportBaseUsageForBudgetGroups` is designed to generate a report on energy usage and demand for specified budget groups within a given fiscal year. It processes and aggregates energy usage data, both base and normalized, for each budget group and organizes this data into a pivot table format. The results are then grouped and ordered for reporting purposes, providing a comprehensive view of energy consumption across different months.\n\n#### 2. Complexity Level: Medium\nThe procedure involves multiple steps, including data transformation, aggregation, and pivoting, which adds to its complexity. It uses common table expressions (CTEs) and dynamic filtering based on input parameters, making it moderately complex.\n\n#### 3. Input Parameters\n- `@fy AS INT`: Represents the fiscal year for which the report is generated. It is a mandatory parameter.\n- `@budgetGroupIds AS VARCHAR(MAX) = NULL`: A comma-separated list of budget group IDs to filter the report. It is optional; if not provided, the report includes all budget groups for the specified fiscal year.\n\n#### 4. Business Logic and Workflow\n1. **Initial Setup**: \n   - Disables `FMTONLY` and sets `NOCOUNT` to ON to improve performance by reducing unnecessary metadata and message output.\n   - Sets the transaction isolation level to `READ UNCOMMITTED` to allow dirty reads, which can improve performance but may lead to reading uncommitted data.\n\n2. **Parameter Handling**:\n   - Converts the comma-separated `@budgetGroupIds` into a table format using a user-defined table type `UDT_IDList` and a function `UDF_SplitToTable`.\n\n3. **Data Extraction and Transformation**:\n   - A CTE `dataTbl` is used to extract and aggregate energy usage data from `preload.EC3BaseData` and `Preload.BudgetGroup` tables.\n   - Filters data based on fiscal year, budget group IDs, and existence in related fiscal year and agency tables.\n\n4. **Pivoting Data**:\n   - Another CTE `pivotTbl` pivots the aggregated data to organize it by month, creating separate entries for base and normalized energy and demand usage.\n\n5. **Summarization**:\n   - The `sumTbl` CTE further aggregates the pivoted data to calculate total usage and demand for each budget group and subtype, ensuring only non-zero totals are included.\n\n6. **Final Selection**:\n   - The final SELECT statement joins the summarized data with the `budget.BudgetStage` table to include budget stage descriptions and calculates a `Level1Rowspan` for formatting purposes in reports.\n\n#### 5. Performance Considerations\n- **Isolation Level**: Using `READ UNCOMMITTED` can improve performance by reducing locking overhead but risks reading uncommitted changes.\n- **Pivot Operations**: Pivoting large datasets can be resource-intensive. Ensuring indexes on join and filter columns can help mitigate performance issues.\n- **Dynamic Filtering**: The use of dynamic filtering based on `@budgetGroupIds` can lead to varying execution plans. Consider using `OPTION (RECOMPILE)` if parameter sniffing becomes an issue.\n\n#### 6. Potential Issues or Risks\n- **Dirty Reads**: The `READ UNCOMMITTED` isolation level may lead to inconsistencies if data is being modified concurrently.\n- **Parameter Handling**: If `@budgetGroupIds` is too large, it may exceed the maximum size for a `VARCHAR(MAX)` parameter, leading to truncation.\n- **Scalability**: As data volume grows, the pivot and aggregation operations may become a bottleneck. Regular performance monitoring and indexing strategies should be considered.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions and incomplete transactions in case of failures.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 2793,
      "api_response_id": "chatcmpl-C8VoH15EnPH9cYqI3cd9RSaZFd14a"
    },
    "analysis_timestamp": "2025-08-25 14:02:35"
  },
  {
    "procedure_info": {
      "schema": "report",
      "name": "USP_ReportTotalDetailsByMonthAndAgency",
      "definition": "CREATE PROCEDURE [report].[USP_ReportTotalDetailsByMonthAndAgency]\r\n(\r\n\t@scenarioId AS INT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @fy AS INT, @billingPeriodCols AS VARCHAR(120), @billingPeriodTotalCol AS VARCHAR(120)\r\n\t\t,@displayCondition AS VARCHAR(500), @sqlStr AS VARCHAR(MAX);\r\n\r\n\tDECLARE @result TABLE(AgencyCodeOEC VARCHAR(6),\r\n\t\tAgencyName VARCHAR(75),\r\n\t\tEnergyType VARCHAR(3),\r\n\t\tBudgetGroupName VARCHAR(75),\r\n\t\tType VARCHAR(50),\r\n\t\tTotal DECIMAL(20,2),\r\n\t\tJuly DECIMAL(20,2),\r\n\t\tAugust DECIMAL(20,2),\r\n\t\tSeptember DECIMAL(20,2),\r\n\t\tOctober DECIMAL(20,2),\r\n\t\tNovember DECIMAL(20,2),\r\n\t\tDecember DECIMAL(20,2),\r\n\t\tJanuary DECIMAL(20,2),\r\n\t\tFebruary DECIMAL(20,2),\r\n\t\tMarch DECIMAL(20,2),\r\n\t\tApril DECIMAL(20,2),\r\n\t\tMay DECIMAL(20,2),\r\n\t\tJune DECIMAL(20,2));\r\n\r\n\tSELECT @fy = FY FROM budget.Scenario WHERE ID=@scenarioId;\r\n\r\n\tSELECT @billingPeriodCols = COALESCE(@billingPeriodCols + ',', '') + '['+CAST(BudgetBillingperiod AS VARCHAR(6)) +']'\r\n\t\t,@billingPeriodTotalCol=COALESCE(@billingPeriodTotalCol + '+', '') + '['+CAST(BudgetBillingperiod AS VARCHAR(6)) +']'\r\n\t\t,@displayCondition=COALESCE(@displayCondition + '<>0 or ', '') + '['+CAST(BudgetBillingperiod AS VARCHAR(6)) +']'\r\n\tFROM Preload.BillingPeriod WHERE FY=@fy\r\n\tORDER BY BudgetBillingperiod;\r\n\r\n\tSET @sqlStr = 'SELECT AgencyCodeOEC, AgencyName, EnergyType, BudgetGroupName, ''Dollar'' AS Type, ' + @billingPeriodTotalCol + ' AS Total, ' +  @billingPeriodCols + '\r\n\t\tFROM (SELECT ParentAgencyCodeOEC AS AgencyCodeOEC, ParentAgencyName AS AgencyName, BudgetBillingPeriod, EnergyType, BudgetGroupName\r\n\t\t\t\t,SUM(ISNULL(TotalDollars,0)) AS TotalDollars\r\n\t\t\tFROM budget.vwTotalBudget a JOIN [Preload].[vwAgencyHierarchy] b ON a.AgencyCodeOEC=b.childAgencyCodeOEC\r\n\t\t\tWHERE ScenarioId=' +  CAST(@scenarioId AS VARCHAR(10)) + ' AND b.fy=' + CAST(@fy AS VARCHAR(4)) + '\r\n\t\t\tGROUP BY BudgetBillingPeriod, ParentAgencyCodeOEC, ParentAgencyName, EnergyType, BudgetGroupName\r\n\t\t) AS sourcetbl\r\n\t\tPIVOT\r\n\t\t(sum(TotalDollars) FOR budgetbillingperiod IN (' +  @billingPeriodCols + ')) AS pivottbl\r\n\t\tWhere ' + @displayCondition + '<>0 or ' + @billingPeriodTotalCol + '<>0 \r\n\t\tUNION ALL\r\n\t\tSELECT AgencyCodeOEC, AgencyName, EnergyType, BudgetGroupName, ''Consumption (''+ LOWER(EnergyUnit) + '')'' AS Type, ' + @billingPeriodTotalCol + ' AS Total, ' +  @billingPeriodCols + '\r\n\t\tFROM (SELECT ParentAgencyCodeOEC AS AgencyCodeOEC, ParentAgencyName AS AgencyName, BudgetBillingPeriod, EnergyType, EnergyUnit\r\n\t\t\t\t,BudgetGroupName, SUM(ISNULL([EnergyUsage],0)) AS [EnergyUsage]\r\n\t\t\tFROM budget.vwTotalBudget a JOIN [Preload].[vwAgencyHierarchy] b ON a.AgencyCodeOEC=b.childAgencyCodeOEC \r\n\t\t\tWHERE ScenarioId=' +  CAST(@scenarioId AS VARCHAR(10)) + ' AND b.fy=' + CAST(@fy AS VARCHAR(4)) + '\r\n\t\t\tGROUP BY BudgetBillingPeriod, ParentAgencyCodeOEC, ParentAgencyName, EnergyType, EnergyUnit, BudgetGroupName\r\n\t\t) AS sourcetbl\r\n\t\tPIVOT\r\n\t\t(sum([EnergyUsage]) FOR budgetbillingperiod IN (' +  @billingPeriodCols + ')) AS pivottbl\r\n\t\tWhere ' + @displayCondition + '<>0 or ' + @billingPeriodTotalCol + '<>0 \r\n\t\tUNION ALL\r\n\t\tSELECT AgencyCodeOEC, AgencyName, EnergyType, BudgetGroupName, ''Demand'' AS Type, ' + @billingPeriodTotalCol + ' AS Total, ' +  @billingPeriodCols + '\r\n\t\tFROM (SELECT ParentAgencyCodeOEC AS AgencyCodeOEC, ParentAgencyName AS AgencyName, BudgetBillingPeriod, EnergyType, BudgetGroupName\r\n\t\t\t\t,SUM(ISNULL([DemandUsage],0)) AS [DemandUsage]\r\n\t\t\tFROM budget.vwTotalBudget a JOIN [Preload].[vwAgencyHierarchy] b ON a.AgencyCodeOEC=b.childAgencyCodeOEC \r\n\t\t\tWHERE ScenarioId=' +  CAST(@scenarioId AS VARCHAR(10)) + ' AND b.fy=' + CAST(@fy AS VARCHAR(4)) + '\r\n\t\t\tGROUP BY BudgetBillingPeriod, ParentAgencyCodeOEC, ParentAgencyName, EnergyType, BudgetGroupName\r\n\t\t) AS sourcetbl\r\n\t\tPIVOT\r\n\t\t(sum([DemandUsage]) FOR budgetbillingperiod IN (' +  @billingPeriodCols + ')) AS pivottbl\r\n\t\tWhere ' + @displayCondition + '<>0 or ' + @billingPeriodTotalCol + '<>0 \r\n\t\tUnion ALL\r\n\t\tSELECT AgencyCodeOEC, AgencyName, '''' AS EnergyType, '''' AS BudgetGroupName, ''Total Cost'' AS Type, ' + @billingPeriodTotalCol + ' AS Total, ' +  @billingPeriodCols + '\r\n\t\tFROM (SELECT ParentAgencyCodeOEC AS AgencyCodeOEC, ParentAgencyName AS AgencyName, BudgetBillingPeriod, SUM(ISNULL(TotalDollars,0)) AS TotalDollars\r\n\t\t\tFROM budget.vwTotalBudget a JOIN [Preload].[vwAgencyHierarchy] b ON a.AgencyCodeOEC=b.childAgencyCodeOEC\r\n\t\t\tWHERE ScenarioId=' +  CAST(@scenarioId AS VARCHAR(10)) + ' AND b.fy=' + CAST(@fy AS VARCHAR(4)) + '\r\n\t\t\tGROUP BY BudgetBillingPeriod, ParentAgencyCodeOEC, ParentAgencyName\r\n\t\t) AS sourcetbl\r\n\t\tPIVOT\r\n\t\t(sum(TotalDollars) FOR budgetbillingperiod IN (' +  @billingPeriodCols + ')) AS pivottbl\r\n\t\tWhere ' + @displayCondition + '<>0 or ' + @billingPeriodTotalCol + '<>0\r\n\t\tORDER BY AgencyCodeOEC, EnergyType, BudgetGroupName, Type';\r\n\r\n\tINSERT INTO @result (AgencyCodeOEC, AgencyName, EnergyType, BudgetGroupName, [Type],\r\n\t\tTotal, July, August, September, October, November, December, January, February, March, April, May, June)\r\n\tEXEC(@sqlStr);\r\n\r\n\tSELECT AgencyCodeOEC, AgencyName, EnergyType, BudgetGroupName, [Type],\r\n\t\tTotal, July, August, September, October, November, December, January, February, March, April, May, June \r\n\tFROM @result;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.220000",
      "last_altered": "2025-08-25 15:54:06.220000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@scenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ReportTotalDetailsByMonthAndAgency",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ReportTotalDetailsByMonthAndAgency` is designed to generate a detailed report of financial and energy usage data by month and agency for a specified scenario. It dynamically constructs and executes a SQL query to pivot data from a budget view and agency hierarchy view, aggregating totals for dollars, energy usage, and demand usage across different billing periods within a fiscal year. The results are returned in a tabular format with columns for each month and a total column.\n\n#### 2. Complexity Level: Medium\nThe procedure involves dynamic SQL construction, multiple joins, aggregations, and pivot operations, which add to its complexity. The use of dynamic SQL requires careful handling to ensure security and performance, making the complexity level medium.\n\n#### 3. Input Parameters\n- `@scenarioId AS INT`: This parameter specifies the scenario for which the report is generated. It is used to filter data from the `budget.Scenario` and `budget.vwTotalBudget` tables.\n\n#### 4. Business Logic and Workflow\n1. **Initialization**: The procedure begins by setting the transaction isolation level to `READ UNCOMMITTED` to avoid locking issues and declares several variables for fiscal year, billing period columns, and SQL string construction.\n   \n2. **Fiscal Year Retrieval**: It retrieves the fiscal year (`@fy`) associated with the given `@scenarioId` from the `budget.Scenario` table.\n\n3. **Dynamic SQL Construction**:\n   - Constructs column lists (`@billingPeriodCols`) and total column expressions (`@billingPeriodTotalCol`) for each billing period within the fiscal year.\n   - Constructs a display condition (`@displayCondition`) to filter out rows where all billing period values are zero.\n\n4. **Dynamic Query Execution**:\n   - Constructs a dynamic SQL query string (`@sqlStr`) that:\n     - Joins `budget.vwTotalBudget` with `Preload.vwAgencyHierarchy` to aggregate data by agency and billing period.\n     - Uses the `PIVOT` operator to transform rows into columns for each billing period.\n     - Filters out rows with zero totals using the constructed display condition.\n     - Includes multiple `UNION ALL` clauses to handle different types of data: Dollar, Consumption, Demand, and Total Cost.\n   - Executes the dynamic SQL and inserts the results into a table variable `@result`.\n\n5. **Result Output**: The procedure selects and returns the data from the `@result` table variable.\n\n#### 5. Performance Considerations\n- **Dynamic SQL**: The use of dynamic SQL can lead to performance issues due to lack of query plan reuse. SQL Server cannot cache execution plans for dynamic SQL, which may result in increased compilation time.\n- **READ UNCOMMITTED**: This isolation level can improve performance by reducing locking but may lead to dirty reads.\n- **Aggregation and Pivoting**: The aggregation and pivot operations can be resource-intensive, especially with large datasets.\n- **Indexing**: Proper indexing on the `budget.vwTotalBudget` and `Preload.vwAgencyHierarchy` tables can improve join and aggregation performance.\n\n#### 6. Potential Issues or Risks\n- **SQL Injection**: The procedure constructs SQL queries dynamically using input parameters. If not properly handled, this can expose the system to SQL injection attacks. Although the parameter is cast to a string, further validation or parameterization should be considered.\n- **Data Integrity**: Using `READ UNCOMMITTED` can lead to reading uncommitted or dirty data, which might not be suitable for all reporting scenarios.\n- **Complexity in Maintenance**: The dynamic nature of the SQL and the use of multiple unions and pivots can make the procedure difficult to maintain and debug.\n- **Scalability**: As the dataset grows, the performance of the procedure may degrade due to the complexity of the dynamic SQL and the operations performed.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 2572,
      "api_response_id": "chatcmpl-C8VoazDcdxANFDVv8RphRHHxyDEvo"
    },
    "analysis_timestamp": "2025-08-25 14:02:50"
  },
  {
    "procedure_info": {
      "schema": "report",
      "name": "USP_ReportTotalDollarsAndUnits",
      "definition": "CREATE PROCEDURE [report].[USP_ReportTotalDollarsAndUnits]\r\n(\r\n\t@scenarioId AS INT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @fy AS INT, @selfFundingSeqId AS INT = 6, @newTechFundingSeqId AS INT = 9, @fundedCat AS VARCHAR(25) = 'Funded Category'\r\n\t\t,@allCat AS VARCHAR(20) = 'ALL', @actualDataEndMonth AS INT;\r\n\r\n\tSELECT @fy = FY, @actualDataEndMonth = ISNULL(ActualDataEndMonth, 0)\r\n\tFROM budget.Scenario\r\n\tWHERE ID = @scenarioId;\r\n\r\n\tWITH totalByFundingTypeEnergyType AS\r\n\t\t(SELECT a.mm\r\n\t\t\t,b.AgencyFundingSeqId\r\n\t\t\t,b.FundingSourceDescription AS FundingType\r\n\t\t\t,a.EnergyType\r\n\t\t\t,SUM(a.TotalDollar) AS Dollar\r\n\t\t\t,SUM(a.TotalEnergy) AS Energy\r\n\t\t\t,SUM(a.TotalDemand) AS Demand\r\n\t\tFROM (SELECT RIGHT(CAST(a.BudgetBillingPeriod AS VARCHAR(6)), 2) AS mm\r\n\t\t\t\t,b.AgencyFundingSeqId\r\n\t\t\t\t,a.EnergyType\r\n\t\t\t\t,SUM(a.TotalDollars) AS TotalDollar\r\n\t\t\t\t,SUM(CASE WHEN a.BudgetGroupID = 77 THEN 0 ELSE ISNULL(a.EnergyUsage, 0) END) AS TotalEnergy\r\n\t\t\t\t,SUM(ISNULL(a.DemandUsage, 0)) AS TotalDemand\r\n\t\t\tFROM budget.vwTotalBudget AS a\r\n\t\t\t\tINNER JOIN Preload.Agency AS b ON a.AgencyCodeOEc = b.AgencyCodeOEC\r\n\t\t\t\tINNER JOIN preload.AgencyByFY AS c ON b.AgencyId = c.AgencyId\r\n\t\t\tWHERE a.ScenarioId = @scenarioId AND c.FY = @fy AND a.EnergyType <> 'TNC'\r\n\t\t\tGROUP BY a.BudgetBillingPeriod, b.AgencyFundingSeqId, a.EnergyType\r\n\t\t\tUNION ALL\r\n\t\t\t--grid charges\r\n\t\t\tSELECT RIGHT(CAST(a.BudgetBillingPeriod AS VARCHAR(6)), 2) AS mm\r\n\t\t\t\t,b.AgencyFundingSeqId\r\n\t\t\t\t,'ELE Grid' AS EnergyType\r\n\t\t\t\t,SUM(a.TotalDollars) AS TotalDollar\r\n\t\t\t\t,0 AS TotalEnergy\r\n\t\t\t\t,0 AS TotalDemand\r\n\t\t\tFROM budget.vwTotalBudget AS a\r\n\t\t\t\tINNER JOIN Preload.Agency AS b ON a.AgencyCodeOEc = b.AgencyCodeOEC\r\n\t\t\t\tINNER JOIN preload.AgencyByFY AS c ON b.AgencyId = c.AgencyId\r\n\t\t\tWHERE a.ScenarioId = @scenarioId AND c.FY = @fy AND a.EnergyType = 'ELE' AND a.BudgetGroupID <> 77\r\n\t\t\tGROUP BY a.BudgetBillingPeriod, b.AgencyFundingSeqId, a.EnergyType\r\n\t\t\tUNION ALL\r\n\t\t\t--grid charges (including ELE tenant charges)\r\n\t\t\tSELECT RIGHT(CAST(dcas.BudgetBillingPeriod AS VARCHAR(6)), 2) AS mm\r\n\t\t\t\t,tenantChargeByGrp.AgencyFundingSeqId\r\n\t\t\t\t,'ELE Grid' AS EnergyType\r\n\t\t\t\t,TotalDollar * tenantChargeByGrp.TenantChg AS TotalDollar\r\n\t\t\t\t,0 AS TotalEnergy\r\n\t\t\t\t,0 AS TotalDemand\r\n\t\t\tFROM (SELECT BudgetBillingPeriod, EnergyType\r\n\t\t\t\t\t,SUM(TotalDollars) AS TotalDollar\r\n\t\t\t\t\t,SUM(ISNULL(EnergyUsage,0)) AS TotalEnergy\r\n\t\t\t\t\t,SUM(ISNULL(DemandUsage,0)) AS TotalDemand\r\n\t\t\t\tFROM budget.vwTotalBudget\r\n\t\t\t\tWHERE ScenarioId=@scenarioId AND AgencyCodeOEC = '856001' AND EnergyType = 'ELE' AND BudgetGroupID <> 77\r\n\t\t\t\t\tAND BudgetBillingPeriod > @actualDataEndMonth\r\n\t\t\t\tGROUP BY EnergyType, BudgetBillingPeriod) AS dcas,\r\n\t\t\t\t(SELECT DISTINCT a.AgencyFundingSeqId, SUM(b.ChargePercentage) AS TenantChg\r\n\t\t\t\tFROM Preload.Agency AS a\r\n\t\t\t\t\tINNER JOIN input.TenantChargeDetail b ON a.AgencyCodeOEC = b.AgencyCode \r\n\t\t\t\t\tINNER JOIN budget.Scenario AS c ON b.TenantChargeID = c.TenantChargeID\r\n\t\t\t\t\tINNER JOIN preload.AgencyByFY AS d ON a.AgencyId = d.AgencyId\r\n\t\t\t\tWHERE c.Id = @scenarioId AND d.FY = @fy\r\n\t\t\t\tGROUP BY a.AgencyFundingSeqId) AS tenantChargeByGrp\r\n\t\t\tUNION ALL\r\n\t\t\t--REC charges\r\n\t\t\tSELECT RIGHT(CAST(a.BudgetBillingPeriod AS VARCHAR(6)), 2) AS mm\r\n\t\t\t\t,b.AgencyFundingSeqId\r\n\t\t\t\t,'ELE REC' AS EnergyType\r\n\t\t\t\t,SUM(a.TotalDollars) AS TotalDollar\r\n\t\t\t\t,0 AS TotalEnergy\r\n\t\t\t\t,0 AS TotalDemand\r\n\t\t\tFROM budget.vwTotalBudget AS a\r\n\t\t\t\tINNER JOIN Preload.agency AS b ON a.AgencyCodeOEc = b.AgencyCodeOEC\r\n\t\t\t\tINNER JOIN preload.AgencyByFY AS c ON b.AgencyId = c.AgencyId\r\n\t\t\tWHERE a.ScenarioId = @scenarioId AND c.FY = @fy AND a.EnergyType = 'ELE' AND a.BudgetGroupID = 77\r\n\t\t\tGROUP BY a.BudgetBillingPeriod, b.AgencyFundingSeqId, a.EnergyType\r\n\t\t\tUNION ALL\r\n\t\t\t--tenant charges\r\n\t\t\tSELECT RIGHT(CAST(dcas.BudgetBillingPeriod AS VARCHAR(6)), 2) AS mm\r\n\t\t\t\t,tenantChargeByGrp.AgencyFundingSeqId\r\n\t\t\t\t,dcas.EnergyType\r\n\t\t\t\t,TotalDollar * tenantChargeByGrp.TenantChg AS TotalDollar\r\n\t\t\t\t,TotalEnergy * tenantChargeByGrp.TenantChg AS TotalEnergy\r\n\t\t\t\t,TotalDemand * tenantChargeByGrp.TenantChg AS TotalDemand\r\n\t\t\tFROM (SELECT BudgetBillingPeriod, EnergyType, \r\n\t\t\t\t\tSUM(TotalDollars) AS TotalDollar,\r\n\t\t\t\t\tSUM(ISNULL(EnergyUsage,0)) AS TotalEnergy,\r\n\t\t\t\t\tSUM(ISNULL(DemandUsage,0)) AS TotalDemand\r\n\t\t\t\tFROM budget.vwTotalBudget\r\n\t\t\t\tWHERE ScenarioId = @scenarioId AND AgencyCodeOEC = '856001' AND EnergyType <> 'TNC'\r\n\t\t\t\t\tAND BudgetBillingPeriod > @actualDataEndMonth AND BudgetGroupID <> 77\r\n\t\t\t\tGROUP BY EnergyType, BudgetBillingPeriod) AS dcas,\r\n\t\t\t\t(SELECT DISTINCT a.AgencyFundingSeqId, SUM(b.ChargePercentage) AS TenantChg\r\n\t\t\t\tFROM Preload.Agency AS a\r\n\t\t\t\t\tINNER JOIN input.TenantChargeDetail b ON a.AgencyCodeOEC = b.AgencyCode \r\n\t\t\t\t\tINNER JOIN budget.Scenario AS c ON b.TenantChargeID = c.TenantChargeID\r\n\t\t\t\t\tINNER JOIN preload.AgencyByFY AS d ON a.AgencyId = d.AgencyId\r\n\t\t\t\tWHERE c.Id = @scenarioId AND d.FY = @fy\r\n\t\t\t\tGROUP BY a.AgencyFundingSeqId) AS tenantChargeByGrp\r\n\t\t) AS a\r\n\t\tINNER JOIN (SELECT DISTINCT a.AgencyFundingSeqId, a.FundingSourceDescription\r\n\t\t\t\t\tFROM Preload.Agency AS a\r\n\t\t\t\t\t\tINNER JOIN Preload.AgencyByFY AS b ON a.AgencyId = b.AgencyId\r\n\t\t\t\t\tWHERE b.FY = @fy AND a.AgencyFundingSeqId IS NOT NULL\r\n\t\t) AS b\r\n\t\tON a.AgencyFundingSeqId = b.AgencyFundingSeqId\r\n\t\tGROUP BY mm, b.AgencyFundingSeqId, b.FundingSourceDescription, EnergyType)\r\n\t,pivotTotalTbl AS (-- Subtotal Dollars by funded, self-funding, new tech\r\n\t\tSELECT AgencyFundingSeqId, FundingType, 'Subtotal Dollars' AS Subtype\r\n\t\t\t,[07] + [08] + [09] + [10] + [11] + [12] + [01] + [02] + [03] + [04] + [05] + [06] AS Total\r\n\t\t\t,[07] AS JUL, [08] AS AUG, [09] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS [DEC]\r\n\t\t\t,[01] AS JAN, [02] AS FEB, [03] AS MAR, [04] AS APR, [05] AS MAY, [06] AS JUN\r\n\t\tFROM (SELECT mm, CASE WHEN AgencyFundingSeqId NOT IN (@selfFundingSeqId, @newTechFundingSeqId) THEN 0 ELSE AgencyFundingSeqId END AS AgencyFundingSeqId, \r\n\t\t\t\tCASE WHEN AgencyFundingSeqId NOT IN (@selfFundingSeqId, @newTechFundingSeqId) THEN @fundedCat ELSE FundingType END AS FundingType, \r\n\t\t\t\tSUM(Dollar) AS Dollar\r\n\t\t\tFROM totalByFundingTypeEnergyType\r\n\t\t\tWHERE EnergyType NOT IN ('ELE Grid', 'ELE REC')\r\n\t\t\tGROUP BY mm, CASE WHEN AgencyFundingSeqId NOT IN (@selfFundingSeqId, @newTechFundingSeqId) THEN 0 ELSE AgencyFundingSeqId END,\r\n\t\t\t\tCASE WHEN AgencyFundingSeqId NOT IN (@selfFundingSeqId, @newTechFundingSeqId) THEN @fundedCat ELSE FundingType END) a\r\n\t\tPIVOT (SUM(Dollar) FOR mm IN ([07], [08], [09], [10], [11], [12], [01], [02], [03], [04], [05], [06])) AS Total\r\n\t\tUNION\r\n\t\t-- Subtotal Dollars by detailed funding types and energy types\r\n\t\tSELECT  AgencyFundingSeqId, FundingType, 'Subtotal ' + EnergyType + ' ($)' AS Subtype\r\n\t\t\t,[07] + [08] + [09] + [10] + [11] + [12] + [01] + [02] + [03] + [04] + [05] + [06] AS Total\r\n\t\t\t,[07] AS JUL, [08] AS AUG, [09] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS [DEC]\r\n\t\t\t,[01] AS JAN, [02] AS FEB, [03] AS MAR, [04] AS APR, [05] AS MAY, [06] AS JUN\r\n\t\tFROM (SELECT mm, AgencyFundingSeqId, FundingType, EnergyType, Dollar\r\n\t\t\t\tFROM totalByFundingTypeEnergyType) AS a\r\n\t\tPIVOT (SUM(Dollar) FOR mm IN ([07], [08], [09], [10], [11], [12], [01], [02], [03], [04], [05], [06])) AS Total\r\n\t\tUNION\r\n\t\t-- Subtotal energy usage by detailed funding types and energy types\r\n\t\tSELECT AgencyFundingSeqId\r\n\t\t\t,FundingType\r\n\t\t\t,'Subtotal ' + EnergyType + ' (' + \r\n\t\t\t\tCASE WHEN EnergyType LIKE 'ELE' THEN 'kWh'\r\n\t\t\t\tWHEN EnergyType='GAS' THEN 'therms'\r\n\t\t\t\tWHEN EnergyType='STM' THEN 'Mlbs'\r\n\t\t\t\tWHEN EnergyType='CHW' THEN 'Mlbs' END + ')' AS Subtype\r\n\t\t\t,[07] + [08] + [09] + [10] + [11] + [12] + [01] + [02] + [03] + [04] + [05] + [06] AS Total\r\n\t\t\t,[07] AS JUL, [08] AS AUG, [09] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[01] AS JAN, [02] AS FEB, [03] AS MAR, [04] AS APR, [05] AS MAY, [06] AS JUN \r\n\t\tFROM (SELECT mm, AgencyFundingSeqId, FundingType, EnergyType, Energy\r\n\t\t\tFROM totalByFundingTypeEnergyType WHERE EnergyType NOT IN ('ELE Grid', 'ELE REC')) AS a\r\n\t\tPIVOT (SUM(Energy) FOR mm IN ([07], [08], [09], [10], [11], [12], [01], [02], [03], [04], [05], [06])) AS Total\r\n\t\tUNION\r\n\t\t-- Subtotal demand usage by detailed funding types\r\n\t\tSELECT AgencyFundingSeqId, FundingType, 'Subtotal Demand (KW)' AS Subtype\r\n\t\t\t,[07] + [08] + [09] + [10] + [11] + [12] + [01] + [02] + [03] + [04] + [05] + [06] AS Total\r\n\t\t\t,[07] AS JUL, [08] AS AUG, [09] AS SEP, [10] AS OCT, [11] AS NOV, [12] AS DEC\r\n\t\t\t,[01] AS JAN, [02] AS FEB, [03] AS MAR, [04] AS APR, [05] AS MAY, [06] AS JUN\r\n\t\tFROM (SELECT mm, AgencyFundingSeqId, FundingType, SUM(Demand) AS Demand\r\n\t\t\tFROM totalByFundingTypeEnergyType\r\n\t\t\tGROUP BY mm, AgencyFundingSeqId, FundingType) AS a\r\n\t\tPIVOT (SUM(Demand) FOR mm IN ([07], [08], [09], [10], [11], [12], [01], [02], [03], [04], [05], [06])) AS Total\r\n\t)\r\n\t\r\n\tSELECT @scenarioId AS ScenarioId, \r\n\t\tCASE WHEN AgencyFundingSeqId NOT IN (0, 999, @selfFundingSeqId, @newTechFundingSeqId) THEN @fundedCat ELSE b.FundingType END AS FundingType, \r\n\t\tCASE WHEN AgencyFundingSeqId NOT IN (0, 999, @selfFundingSeqId, @newTechFundingSeqId) THEN REPLACE(Subtype, 'Subtotal', FundingType + ' -') ELSE b.Subtype END AS Subtype, \r\n\t\tTotal, JUL, AUG, SEP, OCT, NOV, [DEC], JAN, FEB, MAR, APR, MAY, JUN\r\n\tFROM (SELECT P.AgencyFundingSeqId,\r\n            P.FundingType,\r\n            P.Subtype,\r\n            P.Total,\r\n            P.JUL,\r\n            P.AUG,\r\n            P.SEP,\r\n            P.OCT,\r\n            P.NOV,\r\n            P.[DEC],\r\n            P.JAN,\r\n            P.FEB,\r\n            P.MAR,\r\n            P.APR,\r\n            P.MAY,\r\n            P.JUN\r\n\t\tFROM pivotTotalTbl AS P\r\n\t\tWHERE P.Total <> 0\r\n\t\tUNION\r\n\t\t--funded categories total of energy usage and demand usage\r\n\t\tSELECT 0 AS AgencyFundingSeqId\r\n\t\t\t,@fundedCat AS FundingType\r\n\t\t\t,Subtype\r\n\t\t\t,SUM(total) AS Total\r\n\t\t\t,SUM(JUL) AS JUL\r\n\t\t\t,SUM(AUG) AS AUG\r\n\t\t\t,SUM(SEP) AS SEP\r\n\t\t\t,SUM(OCT) AS OCT\r\n\t\t\t,SUM(NOV) AS NOV\r\n\t\t\t,SUM([DEC]) AS [DEC]\r\n\t\t\t,SUM(JAN) AS JAN\r\n\t\t\t,SUM(FEB) AS FEB\r\n\t\t\t,SUM(MAR) AS MAR\r\n\t\t\t,SUM(APR) AS APR\r\n\t\t\t,SUM(MAY) AS MAY\r\n\t\t\t,SUM(JUN) AS JUN\r\n\t\tFROM pivotTotalTbl\r\n\t\tWHERE AgencyFundingSeqId NOT IN (@selfFundingSeqId, @newTechFundingSeqId) AND Subtype <> 'Subtotal Dollars'\r\n\t\tGROUP BY Subtype\r\n\t\tHAVING SUM(Total) <> 0\r\n\t\tUNION\r\n\t\tSELECT 999 AS AgencyFundingSeqId\r\n\t\t\t,@allCat AS FundingType\r\n\t\t\t,REPLACE(subtype, 'Subtotal', 'Total') AS Subtype\r\n\t\t\t,SUM(total) AS Total\r\n\t\t\t,SUM(JUL) AS JUL\r\n\t\t\t,SUM(AUG) AS AUG\r\n\t\t\t,SUM(SEP) AS SEP\r\n\t\t\t,SUM(OCT) AS OCT\r\n\t\t\t,SUM(NOV) AS NOV\r\n\t\t\t,SUM([DEC]) AS [DEC]\r\n\t\t\t,SUM(JAN) AS JAN\r\n\t\t\t,SUM(FEB) AS FEB\r\n\t\t\t,SUM(MAR) AS MAR\r\n\t\t\t,SUM(APR) AS APR\r\n\t\t\t,SUM(MAY) AS MAY\r\n\t\t\t,SUM(JUN) AS JUN\r\n\t\tFROM pivotTotalTbl\r\n\t\tGROUP BY Subtype\r\n\t\tHAVING SUM(Total) <> 0) AS b\r\n\tORDER BY AgencyFundingSeqId\r\n\t\t,CASE WHEN CHARINDEX('Subtotal ELE Grid ($)', Subtype) > 0 THEN 'Subtotal ELE ($Grid)'\r\n\t\t\tWHEN CHARINDEX('Subtotal ELE REC ($)', Subtype) > 0 THEN 'Subtotal ELE ($REC)'\r\n\t\t\tWHEN CHARINDEX('Total ELE Grid ($)', Subtype) > 0 THEN 'Total ELE ($Grid)'\r\n\t\t\tWHEN CHARINDEX('Total ELE REC ($)', Subtype) > 0 THEN 'Total ELE ($REC)'\r\n\t\t\tWHEN CHARINDEX('CHW', Subtype) > 0 THEN 'z' \r\n\t\t\tWHEN CHARINDEX('Demand', Subtype) > 0 THEN 'zz' ELSE Subtype END;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.310000",
      "last_altered": "2025-08-25 15:54:06.310000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@scenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ReportTotalDollarsAndUnits",
      "explanation": "#### 1. Overview\n\nThe stored procedure `USP_ReportTotalDollarsAndUnits` is designed to generate a report summarizing total dollars and energy units by funding type and energy type for a given scenario. It aggregates data from various tables and views, performs calculations, and organizes the results into a pivot table format. The procedure is intended to provide insights into energy consumption and financial allocations across different funding sources and energy types over a fiscal year.\n\n#### 2. Complexity Level: High\n\nThis stored procedure is complex due to several factors:\n- It involves multiple nested queries, including Common Table Expressions (CTEs) and subqueries.\n- It performs data aggregation and transformation using SQL PIVOT operations.\n- It handles multiple business rules and conditions for categorizing and summarizing data.\n- It involves complex joins across several tables and views.\n\n#### 3. Input Parameters\n\n- `@scenarioId AS INT`: This parameter specifies the scenario for which the report is generated. It is used to filter data from the `budget.Scenario` table and other related tables.\n\n#### 4. Business Logic and Workflow\n\n1. **Initialization**: The procedure begins by setting the transaction isolation level to `READ UNCOMMITTED` to avoid locking issues and initializes several variables for fiscal year, funding sequence IDs, and category labels.\n\n2. **Scenario Data Retrieval**: It retrieves the fiscal year (`FY`) and the actual data end month for the given scenario ID from the `budget.Scenario` table.\n\n3. **Data Aggregation**:\n   - A CTE named `totalByFundingTypeEnergyType` aggregates data from the `budget.vwTotalBudget` view and related tables. It calculates total dollars, energy, and demand for each combination of funding type and energy type, considering various conditions such as grid charges and tenant charges.\n   - The CTE uses multiple UNION ALL operations to combine results from different conditions and scenarios.\n\n4. **Pivot Table Creation**:\n   - Another CTE, `pivotTotalTbl`, transforms the aggregated data into a pivot table format. It calculates subtotals for dollars, energy usage, and demand usage by funding type and energy type.\n   - The pivot operation organizes data by month, allowing for a comprehensive view of financial and energy metrics over the fiscal year.\n\n5. **Final Data Selection**:\n   - The procedure selects and formats the final report data, applying additional business rules to categorize and label the results.\n   - It includes UNION operations to calculate totals for funded categories and overall totals.\n\n6. **Ordering**: The final result set is ordered by `AgencyFundingSeqId` and a custom logic for `Subtype` to ensure a meaningful presentation of the data.\n\n#### 5. Performance Considerations\n\n- **Transaction Isolation Level**: The use of `READ UNCOMMITTED` can improve performance by reducing locking but may result in reading uncommitted or dirty data.\n- **Complex Joins and Aggregations**: The procedure involves complex joins and aggregations, which can be resource-intensive, especially on large datasets.\n- **Pivot Operations**: The use of PIVOT can be computationally expensive, particularly when dealing with a large number of columns or rows.\n- **Indexes**: Ensuring that appropriate indexes exist on the tables involved can significantly improve query performance.\n\n#### 6. Potential Issues or Risks\n\n- **Data Consistency**: The use of `READ UNCOMMITTED` may lead to data consistency issues, as it allows reading data that might not be committed.\n- **Scalability**: The complexity of the procedure may affect its scalability, particularly if the underlying data grows significantly.\n- **Maintenance**: The procedure's complexity and the use of hardcoded values (e.g., funding sequence IDs) can make maintenance challenging.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions or errors during execution.\n- **Performance Bottlenecks**: The extensive use of UNION ALL and PIVOT operations could become performance bottlenecks if not optimized properly.",
      "complexity": "High",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 4775,
      "api_response_id": "chatcmpl-C8VopzMgQSbJncJxpoNqNSlHpneim"
    },
    "analysis_timestamp": "2025-08-25 14:03:16"
  },
  {
    "procedure_info": {
      "schema": "report",
      "name": "USP_ReportTotalsByMonthAndAgency",
      "definition": "CREATE PROCEDURE [report].[USP_ReportTotalsByMonthAndAgency]\r\n(\r\n\t@scenarioId AS INT\r\n)\r\nAS\r\nBEGIN\r\n\tSET NOCOUNT ON;\r\n\tSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\r\n\r\n\tDECLARE @fy AS INT, @billingPeriodCols AS VARCHAR(120), @sqlStr AS VARCHAR(MAX);\r\n\r\n\tSELECT @fy = FY FROM budget.Scenario WHERE ID = @scenarioId;\r\n\r\n\r\n\tSELECT @billingPeriodCols = COALESCE(@billingPeriodCols + ',', '') + '['+CAST(BudgetBillingperiod AS VARCHAR(6)) +']'\r\n\tFROM Preload.BillingPeriod\r\n\tWHERE FY = @fy\r\n\tORDER BY BudgetBillingperiod;\r\n\r\n\tSET @sqlStr = 'SELECT AgencyCodeOEC, AgencyName, ''Total Dollars'' AS Type, ' +  @billingPeriodCols + '\r\n\t\tFROM\r\n\t\t(\r\n\t\t\tSELECT AgencyCodeOEC, AgencyName, BudgetBillingPeriod, SUM(ISNULL(TotalDollars,0)) AS TotalDollars\r\n\t\t\tFROM budget.vwTotalBudget WHERE ScenarioId=' +  CAST(@scenarioId AS VARCHAR(10)) + '\r\n\t\t\tGROUP BY BudgetBillingPeriod, AgencyCodeOEC, AgencyName\r\n\t\t) AS sourcetbl\r\n\t\tPIVOT\r\n\t\t(sum(TotalDollars) FOR budgetbillingperiod IN (' +  @billingPeriodCols + ')) AS pivottbl\r\n\t\tORDER BY AgencyCodeOEC, TYPE desc';\r\n\tEXEC(@sqlStr);\r\nEND;\r\n",
      "created": "2025-08-25 15:54:06.317000",
      "last_altered": "2025-08-25 15:54:06.317000",
      "type": "PROCEDURE"
    },
    "parameters": [
      {
        "name": "@scenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0,
        "ordinal_position": 1,
        "has_default_value": false,
        "default_value": ""
      }
    ],
    "chatgpt_explanation": {
      "procedure_name": "USP_ReportTotalsByMonthAndAgency",
      "explanation": "#### 1. Overview\nThe stored procedure `USP_ReportTotalsByMonthAndAgency` is designed to generate a report of total dollar amounts by month and agency for a given scenario. It dynamically constructs and executes a SQL query to pivot data from a view (`budget.vwTotalBudget`) based on the fiscal year associated with the provided scenario ID. The result is a dataset where each row represents an agency, and each column represents a billing period within the fiscal year, showing the total dollars for that period.\n\n#### 2. Complexity Level: Medium\nThe procedure involves dynamic SQL construction, pivoting data, and handling input parameters, which adds a moderate level of complexity. The use of dynamic SQL requires careful handling to ensure security and performance, and the pivot operation requires a good understanding of SQL transformations.\n\n#### 3. Input Parameters\n- `@scenarioId AS INT`: This parameter is used to identify the specific scenario for which the report is generated. It is used to filter data from the `budget.vwTotalBudget` view and to determine the fiscal year from the `budget.Scenario` table.\n\n#### 4. Business Logic and Workflow\n1. **Set NOCOUNT and Isolation Level**: The procedure begins by setting `NOCOUNT ON` to prevent the sending of DONE_IN_PROC messages, which can improve performance. The transaction isolation level is set to `READ UNCOMMITTED` to allow reading uncommitted data, which can reduce locking contention but may result in reading dirty data.\n\n2. **Determine Fiscal Year**: The fiscal year (`@fy`) is retrieved from the `budget.Scenario` table using the provided `@scenarioId`.\n\n3. **Construct Billing Period Columns**: A comma-separated list of billing period columns (`@billingPeriodCols`) is constructed by querying the `Preload.BillingPeriod` table for the fiscal year. This list is used in the pivot operation.\n\n4. **Dynamic SQL Construction**: A dynamic SQL string (`@sqlStr`) is constructed to select and pivot data from the `budget.vwTotalBudget` view. The query aggregates total dollars by agency and billing period, then pivots the data to display each billing period as a separate column.\n\n5. **Execute Dynamic SQL**: The constructed SQL string is executed using the `EXEC` command, which runs the query and returns the result set.\n\n#### 5. Performance Considerations\n- **Dynamic SQL**: While flexible, dynamic SQL can introduce performance overhead due to the need for SQL Server to compile and optimize the query each time it is executed.\n- **READ UNCOMMITTED Isolation Level**: This level can improve performance by reducing locking but may lead to reading uncommitted (dirty) data, which could affect report accuracy.\n- **Pivot Operation**: Pivoting can be resource-intensive, especially with large datasets. Indexing on the `budget.vwTotalBudget` view can help improve performance.\n- **String Concatenation**: The use of `VARCHAR(MAX)` for `@sqlStr` and `VARCHAR(120)` for `@billingPeriodCols` is appropriate, but care should be taken to ensure these variables do not exceed their limits.\n\n#### 6. Potential Issues or Risks\n- **SQL Injection**: The procedure uses dynamic SQL, which can be vulnerable to SQL injection if not properly handled. Although the input parameter is an integer, any future changes that involve string inputs should be carefully validated.\n- **Dirty Reads**: The use of `READ UNCOMMITTED` can lead to dirty reads, which may not be acceptable in all reporting scenarios.\n- **Scalability**: As the number of billing periods increases, the dynamic SQL string and the pivot operation may become more complex and resource-intensive.\n- **Error Handling**: The procedure lacks explicit error handling, which could lead to unhandled exceptions and unclear error messages if something goes wrong during execution.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1308,
      "api_response_id": "chatcmpl-C8VpFpX6YO4Dvx7REbYf94S6fkYqI"
    },
    "analysis_timestamp": "2025-08-25 14:03:31"
  }
]