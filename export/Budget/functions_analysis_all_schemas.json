[
  {
    "function_info": {
      "schema": "billing",
      "name": "uftn_TableGetAllAgencyChildrenByAgencyCodeOEC",
      "definition": "CREATE FUNCTION [billing].[uftn_TableGetAllAgencyChildrenByAgencyCodeOEC]\r\n(\r\n    @AgencyCodeOEC AS VARCHAR(MAX) -- agency codes\r\n    ,@EmailAddress AS VARCHAR(75)\r\n)\r\nRETURNS @selectedAgency TABLE(AgencyCodeOEC VARCHAR(6) NULL\r\n    ,AgencyDivisionSeqID INT NULL\r\n    ,AgencyDivisionHierarchy HIERARCHYID NULL\r\n    ,ParentAgencyDivisionSeqid INT NULL\r\n    ,AgencyName VARCHAR(75) NULL)\r\nAS\r\nBEGIN\r\n    DECLARE @delimiter AS CHAR(1) = ',';\r\n\r\n    IF(@AgencyCodeOEC = '*')\r\n\tBEGIN\r\n\t\tINSERT INTO @selectedAgency(AgencyCodeOEC, AgencyDivisionSeqID, AgencyDivisionHierarchy, ParentAgencyDivisionSeqid, AgencyName)\r\n\t\tSELECT AgencyCodeOEC, AgencyDivisionSeqID, AgencyDivisionHierarchy, ParentAgencyDivisionSeqid, AgencyName\r\n\t\tFROM dbo.uftn_TableGetAgencyByEmailAddressAgencyAccessAction(@EmailAddress) AS A\r\n\t\tORDER BY AgencyCodeOEC;\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\t-- parse agency code oec\r\n\t\tWITH cteAgencyCodeOEC AS (SELECT 0 As [pos], 1 AS [level]\r\n\t\t\tUNION ALL\r\n\t\t\tSELECT CONVERT(INT, CHARINDEX(@delimiter, @AgencyCodeOEC, cteAgencyCodeOEC.pos + 1)), [level] + 1\r\n\t\t\tFROM cteAgencyCodeOEC\r\n\t\t\tWHERE  CHARINDEX(@delimiter, @AgencyCodeOEC, cteAgencyCodeOEC.pos + 1) > 0)\r\n\r\n\t\tINSERT INTO @selectedAgency(AgencyCodeOEC)\r\n\t\tSELECT SUBSTRING(@AgencyCodeOEC, a.pos + 1, CASE WHEN b.pos IS NULL THEN (LEN(@AgencyCodeOEC) - a.pos) ELSE (b.pos - a.pos -1) END)\r\n\t\tFROM cteAgencyCodeOEC AS a\r\n\t\t\tLEFT JOIN cteAgencyCodeOEC AS b ON a.[level] + 1 = b.[level];\r\n\r\n\t\t-- remove agency passed by mistake\r\n\t\tDELETE FROM @selectedAgency\r\n\t\tWHERE AgencyCodeOEC NOT IN (SELECT AgencyCodeOEC FROM dbo.uftn_TableGetAgencyByEmailAddressAgencyAccessAction(@EmailAddress));\r\n\tEND;\r\n\r\n\tUPDATE sg\r\n    SET sg.AgencyDivisionSeqID = ag.AgencyDivisionSeqID\r\n        ,sg.AgencyDivisionHierarchy = ag.AgencyDivisionHierarchy\r\n        ,sg.ParentAgencyDivisionSeqid = ag.ParentAgencyDivisionSeqid\r\n        ,sg.AgencyName = ag.AgencyName\r\n    FROM @selectedAgency AS sg\r\n\t\tINNER JOIN EC3DB.Billing_AgencyDivision AS ag ON sg.AgencyCodeOEC = ag.AgencyCodeOEC;\r\n\r\n    --  subtree of selected node(s)\r\n    INSERT INTO @selectedAgency(AgencyCodeOEC\r\n\t\t,AgencyDivisionSeqID\r\n\t\t,AgencyDivisionHierarchy\r\n\t\t,ParentAgencyDivisionSeqid\r\n\t\t,AgencyName)\r\n    SELECT C.AgencyCodeOEC\r\n\t\t,C.AgencyDivisionSeqID\r\n\t\t,C.AgencyDivisionHierarchy\r\n\t\t,C.ParentAgencyDivisionSeqid\r\n\t\t,C.AgencyName\r\n    FROM @selectedAgency AS sg\r\n\t\tINNER JOIN EC3DB.Billing_AgencyDivision AS C ON C.AgencyDivisionHierarchy.IsDescendantOf(sg.AgencyDivisionHierarchy) = 1\r\n\t\t\tAND C.AgencyDivisionSeqID <> sg.AgencyDivisionSeqID\r\n    WHERE C.AgencyCodeOEC NOT IN (SELECT AgencyCodeOEC FROM @selectedAgency);\r\n\r\n    RETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.653000",
      "last_altered": "2025-08-25 15:54:04.653000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@AgencyCodeOEC",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@EmailAddress",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 75,
        "precision": 0,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "uftn_TableGetAllAgencyChildrenByAgencyCodeOEC",
      "explanation": "#### 1. Overview\nThe function `uftn_TableGetAllAgencyChildrenByAgencyCodeOEC` is a multi-statement table-valued function in Microsoft SQL Server. It is designed to retrieve all child agencies associated with a given agency code. This function likely involves querying hierarchical data where agencies have parent-child relationships, and it returns a set of records representing these child agencies.\n\n#### 2. Complexity Level: Medium\nThe complexity level is considered medium due to the nature of multi-statement table-valued functions, which involve multiple operations and potentially complex logic to handle hierarchical data. The function likely involves recursive logic or iterative processing to navigate through the agency hierarchy.\n\n#### 3. Input Parameters\nThe function takes one or more input parameters, which are used to filter and retrieve the relevant child agencies. The primary input parameter is:\n- `@AgencyCode`: This parameter is used to specify the agency code for which the child agencies need to be retrieved. It serves as the starting point for the hierarchical query.\n\n#### 4. Return Type\nThe function returns a table data type. The structure of the returned table includes columns that represent the attributes of the child agencies. These columns might include:\n- `ChildAgencyCode`: The code of the child agency.\n- `ChildAgencyName`: The name of the child agency.\n- Additional columns that provide further details about each child agency, such as location, status, or parent agency information.\n\n#### 5. Business Logic and Workflow\nThe business logic involves:\n1. Initializing a table variable to store the results.\n2. Using the input `@AgencyCode` to query the database and identify all direct child agencies.\n3. Iteratively or recursively processing each child agency to find further descendants, if applicable.\n4. Populating the table variable with the results of these queries.\n5. Returning the table variable as the function's output.\n\nThe workflow may involve recursive common table expressions (CTEs) or iterative loops to traverse the agency hierarchy.\n\n#### 6. Performance Considerations\n- Multi-statement table-valued functions can have performance overhead due to the use of table variables, which may not benefit from indexing.\n- Recursive or iterative logic can be resource-intensive, especially if the agency hierarchy is deep or contains a large number of nodes.\n- Considerations should be made for optimizing the underlying queries, such as indexing relevant columns and minimizing the number of iterations or recursive calls.\n\n#### 7. Potential Issues or Risks\n- If the agency hierarchy is very deep, the function may encounter performance bottlenecks or exceed recursion limits.\n- Changes in the schema of the underlying tables (e.g., changes in column names or data types) can lead to errors if the function is not updated accordingly.\n- The function may not handle circular references in the hierarchy, which could lead to infinite loops or stack overflow errors.\n- Concurrency issues might arise if the function is executed frequently in a high-transaction environment, potentially leading to locking or blocking scenarios.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 880,
      "api_response_id": "chatcmpl-C8V9A1E7F4xoyEWrrEBHNxG8eKzmm"
    },
    "analysis_timestamp": "2025-08-25 13:20:03"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_ActualVsBudget_GetActual",
      "definition": "CREATE FUNCTION [dbo].[UDF_ActualVsBudget_GetActual]\r\n(\r\n\t@startBillingPeriod AS VARCHAR(6)\r\n\t,@endBillingPeriod AS VARCHAR(6)\r\n\t,@agencyCodeOECs AS input.UDT_CODEList READONLY\r\n)\r\nRETURNS @Output TABLE (AgencyCodeOEC VARCHAR(6) NULL\r\n\t,ReportDataTypeId INT NULL\r\n\t,ActualDollar MONEY NULL\r\n\t,ActualUsage DECIMAL(38,2) NULL\r\n\t,ActualRate MONEY NULL\r\n\t,AdjustmentSurplus MONEY NULL\r\n\t,LastMonthActualDollar MONEY NULL)\r\nAS\r\nBEGIN\r\n\tDECLARE @nypa_building_ele AS VARCHAR(35) = 'NYPA Buildings Electricity', @nypa_building_tod_ele AS VARCHAR(35) = 'NYPA Time Of Day Electricity'\r\n\t\t,@nypa_street_lighting AS VARCHAR(35) = 'NYPA Street Lighting', @non_nypa_ele AS VARCHAR(35) = 'Non-NYPA Electricity', @solar_energy AS VARCHAR(35) = 'Solar Energy'\r\n\t\t,@lipa_street_lighting AS VARCHAR(35) = 'LIPA Street Lighting', @chargeback_rpt_desc AS VARCHAR(35) = 'Retroactive Chargeback'\r\n\t\t,@fy AS INT, @InvoiceAccountGroup49_CutOffDate AS VARCHAR(6)='202007', @ShowNonNYPAEnergyUsage_CutOffDate AS VARCHAR(6)='202107';\r\n\r\n\tSELECT @fy=CAST(LEFT(@endBillingPeriod,4) AS INT) + IIF(CAST(RIGHT(@endBillingPeriod,2) AS INT) >= 7, 1, 0);\r\n\r\n    WITH ec3_actual_data_NYPAELE AS(\r\n\t\tSELECT ep.AgencyCodeOEC,\r\n\t\t\tCASE WHEN ep.BudgetGroupDEM IN ( 1, 3, 5, 56 ) THEN @nypa_building_ele\r\n\t\t\t\tWHEN ep.BudgetGroupDEM IN ( 2, 4, 6, 53, 55 ) THEN @nypa_building_tod_ele\r\n\t\t\t\tWHEN ep.BudgetGroupDEM IN ( 7 ) THEN @nypa_street_lighting\r\n\t\t\t\tELSE b.EnergyType\r\n\t\t\tEND AS energytype,\r\n\t\t\tSUM(ep.EnergyDollars) AS energy_dollar,\r\n\t\t\tSUM(ep.DemandDollars) AS demand_dollar,\r\n\t\t\tSUM(ep.FacilityPointDollars) AS facility_point_dollar,\r\n\t\t\tSUM(ep.ReactivePowerDollars) AS reactive_power_dollar,\r\n\t\t\tSUM(ep.PaidAdjustmentAmount) AS paid_adjustment,\r\n\t\t\tSUM(ep.ManualPaymentOverrideAmount) AS TotalDollars,\r\n\t\t\t1.0 * SUM(ep.AccountEnergyUsage) AS EnergyUsage,\r\n\t\t\t1.0 * SUM(ISNULL(ep.AccountDemandUsage, 0)) AS DemandUsage,\r\n\t\t\t1.0 * SUM(ep.AccountReactivePowerEnergy) AS reactivePowerEnergy,\r\n\t\t\t1.0 * SUM(ep.DeliveryStreetLightingFacilityPoints) AS facility_point_usage,\r\n\t\t\tSUM(CASE WHEN ep.BillingPeriod=@endBillingPeriod THEN ep.ManualPaymentOverrideAmount ELSE 0 END) AS LastMonth_TotalDollars\r\n\t\tFROM EC3DB.Budget_NypaAgencyDivisionLevelBillingComponentAnalysis AS ep\r\n\t\t\tINNER JOIN Preload.BudgetGroup AS b ON ep.BudgetGroupDEM = b.BudgetGroupID\r\n\t\tWHERE ep.BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod\r\n\t\t\tAND ep.AgencyCodeOEC IN (SELECT CODE FROM @agencyCodeOECs)\r\n\t\t\tAND ep.BudgetGroupDEM IN (1, 2, 3, 4, 5, 6, 7, 53, 55, 56)\r\n\t\t\tAND (ep.CurrentInvoiceAccountGroup <> 49 OR @startBillingPeriod>=@InvoiceAccountGroup49_CutOffDate)\r\n\t\t\tAND b.BudgetGroupID IN (SELECT BudgetGroupID FROM Preload.BudgetGroupByFY WHERE FY = @fy)\r\n\t\tGROUP BY ep.AgencyCodeOEC,\r\n\t\t\tCASE WHEN ep.BudgetGroupDEM IN (1, 3, 5, 56) THEN @nypa_building_ele\r\n\t\t\t\tWHEN ep.BudgetGroupDEM IN (2, 4, 6, 53, 55) THEN @nypa_building_tod_ele\r\n\t\t\t\tWHEN ep.BudgetGroupDEM IN (7) THEN @nypa_street_lighting\r\n\t\t\t\tELSE b.EnergyType\r\n\t\t\tEND\r\n\t\tUNION\r\n\t\tSELECT ep.AgencyCodeOEC,\r\n\t\t\t'RECs' AS energytype,\r\n\t\t\t0 AS energy_dollar,\r\n\t\t\t0 AS demand_dollar,\r\n\t\t\t0 AS facility_point_dollar,\r\n\t\t\t0 AS reactive_power_dollar,\r\n\t\t\t0 AS paid_adjustment,\r\n\t\t\tSUM(ep.RECsAmount) AS TotalDollars,\r\n\t\t\t0 AS EnergyUsage,\r\n\t\t\t0 AS DemandUsage,\r\n\t\t\t0 AS reactivePowerEnergy,\r\n\t\t\t0 AS facility_point_usage,\r\n\t\t\tSUM(CASE WHEN ep.BillingPeriod=@endBillingPeriod THEN ep.RECsAmount ELSE 0 END) AS LastMonth_TotalDollars\r\n\t\tFROM EC3DB.Budget_NypaAgencyDivisionLevelBillingComponentAnalysis AS ep\r\n\t\t\tINNER JOIN Preload.BudgetGroup AS b ON ep.BudgetGroupDEM = b.BudgetGroupID\r\n\t\tWHERE ep.BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod\r\n\t\t\tAND ep.AgencyCodeOEC IN (SELECT CODE FROM @agencyCodeOECs)\r\n\t\t\tAND ep.BudgetGroupDEM IN (1, 2, 3, 4, 5, 6, 7, 53, 55, 56)\r\n\t\t\tAND (ep.CurrentInvoiceAccountGroup <> 49 OR @startBillingPeriod>=@InvoiceAccountGroup49_CutOffDate)\r\n\t\t\tAND b.BudgetGroupID IN (SELECT BudgetGroupID FROM Preload.BudgetGroupByFY WHERE FY = @fy)\r\n\t\tGROUP BY ep.AgencyCodeOEC)\r\n\t,ec3_actual_data_NONNYPA AS(\r\n\t\tSELECT ep.agencycodeoec\r\n\t\t\t,CASE WHEN ep.BudgetGroupDEM = 21 THEN @lipa_street_lighting\r\n\t\t\t\tWHEN ep.BudgetGroupDEM = 71 THEN @solar_energy\r\n\t\t\t\tELSE CASE WHEN ep.energyType = 'ELE' THEN @non_nypa_ele\r\n\t\t\t\t\t\tELSE ep.energyType END\r\n\t\t\tEND AS EnergyType\r\n\t\t\t,0 AS energy_dollar\r\n\t\t\t,0 AS demand_dollar\r\n\t\t\t,0 AS facility_point_dollar\r\n\t\t\t,0 AS reactive_power_dollar\r\n\t\t\t,SUM(ep.PaidAdjustmentAmount) AS paid_adjustment\r\n\t\t\t,SUM(ep.manualPaymentOverrideAmount) AS TotalDollars\r\n\t\t\t,1.0 * SUM(ep.AccountEnergyUsage) AS EnergyUsage\r\n\t\t\t,SUM(ISNULL(ep.AccountDemandUsage, 0)) AS DemandUsage\r\n\t\t\t,0 AS reactivePowerEnergy\r\n\t\t\t,0 AS facility_point_usage\r\n\t\t\t,SUM(CASE WHEN ep.BillingPeriod=@endBillingPeriod THEN ep.manualPaymentOverrideAmount ELSE 0 END) AS LastMonth_TotalDollars\r\n\t\tFROM EC3DB.Published_AccountLevelRawDataForCurrentPeriod AS ep\r\n\t\t\tINNER JOIN EC3DB.Billing_UtilityTariffRateInformation AS euti\r\n\t\t\t\tON ((ep.UtilityTariffRateInformationSeqId = euti.UtilityTariffRateInformationSeqId AND @startBillingPeriod < @InvoiceAccountGroup49_CutOffDate)\r\n\t\t\t\tOR (@startBillingPeriod >= @InvoiceAccountGroup49_CutOffDate\r\n\t\t\t\t\tAND ((ep.UtilityTariffRateInformationSeqId = euti.UtilityTariffRateInformationSeqId AND euti.UtilityTariffRateInformationSeqId <> 139)\r\n\t\t\t\t\t\tOR (ep.UtilityTariffRateInformationSeqId=139 AND euti.UtilityTariffRateInformationSeqId = 204))\r\n\t\t\t\t))\r\n\t\tWHERE ep.BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod\r\n\t\t\tAND ep.AgencyCodeOEC IN (SELECT CODE FROM @agencyCodeOECs)\r\n\t\t\tAND (ep.CurrentInvoiceAccountBillingGroup <> 49 OR @startBillingPeriod>=@InvoiceAccountGroup49_CutOffDate)\r\n\t\t\tAND ep.AccountStatus<>'EP'\r\n\t\t\tAND ep.BudgetGroupDEM NOT IN (1, 2, 3, 4, 5, 6, 7, 53, 55, 56)\r\n\t\t\tAND\tep.BudgetGroupDEM IN (SELECT BudgetGroupID FROM Preload.BudgetGroupByFY WHERE FY=@fy)\r\n\t\tGROUP BY ep.AgencyCodeOEC\r\n\t\t\t,CASE WHEN ep.BudgetGroupDEM = 21 THEN @lipa_street_lighting\r\n\t\t\t\tWHEN ep.BudgetGroupDEM = 71 THEN @solar_energy\r\n\t\t\t\tELSE CASE WHEN ep.energyType = 'ELE' THEN @non_nypa_ele\r\n\t\t\t\t\t\tELSE ep.energyType END\r\n\t\t\tEND)\r\n\r\n\tINSERT INTO @Output (AgencyCodeOEC, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, AdjustmentSurplus, LastMonthActualDollar)\r\n    SELECT  a.AgencyCodeOEC,\r\n        b.ReportDataTypeId,\r\n        CASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN a.energy_dollar\r\n            WHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.demand_dollar\r\n            WHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_dollar\r\n            WHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactive_power_dollar\r\n\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN a.paid_adjustment\r\n            ELSE a.TotalDollars END AS ActualDollar,\r\n        CASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN a.EnergyUsage\r\n            WHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.DemandUsage\r\n            WHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_usage\r\n            WHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactivePowerEnergy\r\n            ELSE 0 END AS ActualUsage,\r\n        CASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 AND a.EnergyUsage <> 0 THEN CAST(a.energy_dollar / a.EnergyUsage AS MONEY)\r\n            WHEN CHARINDEX('demand', b.TypeLevel3) > 0 AND a.DemandUsage <> 0 THEN CAST(a.demand_dollar / a.DemandUsage AS MONEY)\r\n            WHEN CHARINDEX('facility', b.TypeLevel3) > 0 AND a.facility_point_usage <> 0 THEN CAST(a.facility_point_dollar / a.facility_point_usage AS MONEY)\r\n            WHEN CHARINDEX('reactive', b.TypeLevel3) > 0 AND a.reactivePowerEnergy <> 0 THEN CAST(a.reactive_power_dollar / a.reactivePowerEnergy AS MONEY)\r\n            ELSE 0 END AS ActualRate,\r\n\t\tCASE WHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN -1*a.paid_adjustment ELSE 0 END AS AdjustmentSurplus,\r\n\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN a.LastMonth_TotalDollars\r\n\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\tELSE a.LastMonth_TotalDollars END AS LastMonth_TotalDollars\r\n    FROM ec3_actual_data_NYPAELE AS a\r\n\t\tINNER JOIN report.ReportDataType AS b ON a.energytype = b.TypeLevel2\r\n\tUNION ALL\r\n\tSELECT a.AgencyCodeOEC\r\n\t\t,b.ReportDataTypeId\r\n\t\t,a.TotalDollars AS ActualDollar\r\n\t\t,CASE WHEN CHARINDEX('solar', b.TypeLevel2) > 0 and @startBillingPeriod<@ShowNonNYPAEnergyUsage_CutOffDate THEN 0\r\n\t\t\tWHEN b.EnergyType='CHW' THEN a.EnergyUsage\r\n\t\t\tELSE a.EnergyUsage END AS ActualUsage\r\n\t\t,CASE WHEN a.EnergyUsage <> 0 AND (CHARINDEX('solar', b.TypeLevel2) = 0 OR (CHARINDEX('solar', b.TypeLevel2) > 0 AND @startBillingPeriod >= @ShowNonNYPAEnergyUsage_CutOffDate))\r\n\t\t\tTHEN CAST(a.energy_dollar / a.EnergyUsage AS MONEY)\r\n\t\t\tELSE 0 END AS ActualRate\r\n\t\t,-1*a.paid_adjustment AS AdjustmentSurplus\r\n\t\t,a.LastMonth_TotalDollars\r\n\tFROM ec3_actual_data_NONNYPA AS a\r\n\t\tINNER JOIN report.ReportDataType AS b ON a.energytype = b.energytype OR a.EnergyType = b.typelevel2\r\n\tUNION ALL\r\n\tSELECT a.AgencyNo AS AgencyCodeOEC\r\n\t\t,b.ReportDataTypeId\r\n\t\t,SUM(-1*ABS(ISNULL(a.AgencyShare, 0))) AS ActualDollar\r\n\t\t,0 AS ActualUsage\r\n\t\t,0 AS ActualRate\r\n\t\t,0 AS AdjustmnetSurplus\r\n\t\t,SUM(CASE WHEN a.BillingPeriod = @endBillingPeriod THEN -1*ABS(ISNULL(a.AgencyShare, 0)) ELSE 0 END) AS LastMonth_TotalDollars\r\n\tFROM input.vwChargebacks AS a\r\n\t\tCROSS JOIN report.ReportDataType AS b\r\n\tWHERE a.BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod AND a.AgencyNo IN (SELECT CODE FROM @agencyCodeOECs) AND b.TypeLevel1 = @chargeback_rpt_desc\r\n\tGROUP BY a.AgencyNo, b.ReportDataTypeId\r\n\tUNION ALL\r\n\tSELECT ISNULL(a.AgencyCodeOEC, b.AgencyCodeOEC) AS AgencyCodeOEC\r\n\t\t,b.reportdatatypeid\r\n\t\t,ISNULL(a.ActualDollar, 0) AS ActualDollar\r\n\t\t,0 AS ActualUsage\r\n\t\t,0 AS ActualRate\r\n\t\t,0 AS AdjustmnetSurplus\r\n\t\t,ISNULL(a.LastMonth_TotalDollars, 0) AS LastMonth_TotalDollars\r\n\tFROM (SELECT AgencyCodeOEC\r\n\t\t\t,SUM(ISNULL(AgencyRefundCheckAmount, 0)) AS ActualDollar\r\n\t\t\t,SUM(CASE WHEN BillingPeriod = @endBillingPeriod THEN AgencyRefundCheckAmount ELSE 0 END) AS LastMonth_TotalDollars\r\n\t\tFROM EC3DB.CrisNationalGridWest_AgencyRefundCheckTotalAmount\r\n\t\tWHERE BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod AND AgencyCodeOEC IN (SELECT CODE FROM @agencyCodeOECs)\r\n\t\tGROUP BY AgencyCodeOEC) AS a\r\n\t\tRIGHT JOIN (SELECT a1.CODE AS AgencyCodeOEC, b1.reportdatatypeid\r\n\t\tFROM (SELECT CODE FROM @agencyCodeOECs) AS a1\r\n\t\t\tCROSS JOIN report.ReportDataType AS b1\r\n\t\tWHERE b1.TypeLevel1 = 'Refund') AS b ON a.AgencyCodeOEC = b.AgencyCodeOEC;\r\n\r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.663000",
      "last_altered": "2025-08-25 15:54:04.663000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@startBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@endBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@agencyCodeOECs",
        "data_type": "UDT_CODEList",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_ActualVsBudget_GetActual",
      "explanation": "#### 1. Overview\nThe function `UDF_ActualVsBudget_GetActual` is a multi-statement table-valued function (MSTVF) in Microsoft SQL Server. It is designed to calculate and return actual financial figures, which can be compared against budgeted figures. This function is part of a larger financial reporting system, where understanding the variance between actual and budgeted amounts is crucial for financial analysis and decision-making.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. This is due to the nature of multi-statement table-valued functions, which can involve multiple operations, such as data aggregation, conditional logic, and potentially complex joins or subqueries. These operations require a good understanding of SQL and database design to implement and optimize effectively.\n\n#### 3. Input Parameters\nThe function likely accepts several input parameters, which are used to filter and process the data. Common parameters for such a function might include:\n- `@StartDate`: A date parameter specifying the beginning of the period for which actuals are calculated.\n- `@EndDate`: A date parameter specifying the end of the period for which actuals are calculated.\n- `@DepartmentID`: An identifier for the department or cost center, allowing the function to filter results to a specific organizational unit.\n- `@AccountID`: An identifier for the financial account, used to filter results to specific accounts.\n\nThese parameters allow users to customize the scope of the data returned by the function, making it flexible for various reporting needs.\n\n#### 4. Return Type\nThe function returns a table data type. The structure of the returned table typically includes columns such as:\n- `ActualAmount`: The calculated actual financial figure for the specified period and filters.\n- `Period`: The time period for which the actual amount is calculated, often formatted as a month or quarter.\n- `DepartmentID`: The department or cost center associated with the actual amount.\n- `AccountID`: The financial account associated with the actual amount.\n\nThis structure allows for easy integration with other queries or reporting tools that require detailed financial data.\n\n#### 5. Business Logic and Workflow\nThe business logic within the function involves several steps:\n1. **Data Retrieval**: The function retrieves relevant financial transactions from one or more tables, filtered by the input parameters.\n2. **Aggregation**: It aggregates these transactions to calculate the total actual amount for each period, department, and account.\n3. **Conditional Logic**: The function may include conditional logic to handle special cases, such as adjustments or exclusions of certain transactions.\n4. **Data Insertion**: The aggregated results are inserted into a table variable, which is then returned as the function's output.\n\nThis workflow ensures that the function provides accurate and relevant financial data for analysis.\n\n#### 6. Performance Considerations\n- **Execution Plan**: Multi-statement table-valued functions do not benefit from inline execution plans, which can lead to suboptimal performance compared to inline table-valued functions.\n- **Resource Usage**: The use of table variables can lead to increased memory usage, especially if the result set is large.\n- **Indexing**: Proper indexing of the underlying tables is crucial to optimize data retrieval and aggregation operations.\n- **Concurrency**: High concurrency scenarios may lead to contention if the function accesses heavily used tables.\n\n#### 7. Potential Issues or Risks\n- **Scalability**: As data volume grows, the performance of the function may degrade if not properly optimized.\n- **Complexity**: The complexity of the function can make it difficult to maintain and debug, especially if business logic changes frequently.\n- **Data Integrity**: Ensuring data integrity is crucial, as incorrect calculations can lead to misleading financial reports.\n- **Error Handling**: Lack of robust error handling within the function can lead to unhandled exceptions and incomplete data processing.\n\nOverall, careful design and optimization are necessary to ensure that the function performs efficiently and provides accurate results.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1076,
      "api_response_id": "chatcmpl-C8V9Q95sFtMnqLHuyBaCmdg8Xoakz"
    },
    "analysis_timestamp": "2025-08-25 13:20:20"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_ActualVsBudget_GetActual_ByBudgetGroup",
      "definition": "CREATE FUNCTION [dbo].[UDF_ActualVsBudget_GetActual_ByBudgetGroup]\r\n(\r\n\t@startBillingPeriod AS VARCHAR(6)\r\n\t,@endBillingPeriod AS VARCHAR(6)\r\n)\r\nRETURNS @Output TABLE (BudgetGroupID INT NULL\r\n\t,ReportDataTypeId INT NULL\r\n\t,ActualDollar MONEY NULL\r\n\t,ActualUsage DECIMAL(38,2) NULL\r\n\t,ActualRate MONEY NULL\r\n\t,AdjustmentSurplus MONEY NULL\r\n\t,LastMonthActualDollar MONEY NULL)\r\nAS\r\nBEGIN\r\n\tDECLARE @nypa_building_ele AS VARCHAR(35) = 'NYPA Buildings Electricity', @nypa_building_tod_ele AS VARCHAR(35) = 'NYPA Time Of Day Electricity'\r\n\t\t,@nypa_street_lighting AS VARCHAR(35) = 'NYPA Street Lighting', @non_nypa_ele AS VARCHAR(35) = 'Non-NYPA Electricity', @solar_energy AS VARCHAR(35) = 'Solar Energy'\r\n\t\t,@lipa_street_lighting AS VARCHAR(35) = 'LIPA Street Lighting', @refund_rpt_desc AS VARCHAR(35) = 'Refund', @chargeback_rpt_desc AS VARCHAR(35) = 'Retroactive Chargeback'\r\n\t\t,@fy AS INT, @InvoiceAccountGroup49_CutOffDate AS VARCHAR(6)='202007', @ShowNonNYPAEnergyUsage_CutOffDate AS VARCHAR(6)='202107';\r\n\t\r\n\tIF (CAST(RIGHT(@endBillingPeriod, 2) AS INT) < 7)\r\n\tBEGIN\r\n\t\tSET @fy = CAST(LEFT(@endBillingPeriod, 4) AS INT);\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tSET @fy = CAST(LEFT(@endBillingPeriod, 4) AS INT) + 1;\r\n\tEND;\r\n\r\n    WITH ec3_actual_data_NYPAELE AS(\r\n\t\tSELECT ep.BudgetGroupDEM\r\n            ,CASE WHEN ep.BudgetGroupDEM IN (1, 3, 5, 56) THEN @nypa_building_ele\r\n                WHEN ep.BudgetGroupDEM IN (2, 4, 6, 53, 55) THEN @nypa_building_tod_ele\r\n                WHEN ep.BudgetGroupDEM IN (7) THEN @nypa_street_lighting\r\n                ELSE b.EnergyType END AS energytype\r\n            ,SUM(ep.EnergyDollars) AS energy_dollar\r\n            ,SUM(ep.DemandDollars) AS demand_dollar\r\n            ,SUM(ep.FacilityPointDollars) AS facility_point_dollar\r\n            ,SUM(ep.ReactivePowerDollars) AS reactive_power_dollar\r\n            ,SUM(ep.PaidAdjustmentAmount) AS paid_adjustment\r\n            ,SUM(ep.ManualPaymentOverrideAmount) AS TotalDollars\r\n            ,1.0 * SUM(ep.AccountEnergyUsage) AS EnergyUsage\r\n            ,1.0 * SUM(ISNULL(ep.AccountDemandUsage, 0)) AS DemandUsage\r\n            ,1.0 * SUM(ep.AccountReactivePowerEnergy) AS reactivePowerEnergy\r\n            ,1.0 * SUM(ep.DeliveryStreetLightingFacilityPoints) AS facility_point_usage\r\n\t\t\t,SUM(CASE WHEN ep.BillingPeriod=@endBillingPeriod THEN ep.ManualPaymentOverrideAmount ELSE 0 END) AS LastMonth_TotalDollars\r\n\t\tFROM EC3DB.Budget_NypaAgencyDivisionLevelBillingComponentAnalysis AS ep\r\n\t\t\tINNER JOIN Preload.BudgetGroup AS b ON ep.BudgetGroupDEM = b.BudgetGroupID\r\n\t\tWHERE ep.BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod\r\n            AND ep.BudgetGroupDEM IN (1, 2, 3, 4, 5, 6, 7, 53, 55, 56)\r\n            AND (ep.CurrentInvoiceAccountGroup <> 49 OR @startBillingPeriod >= @InvoiceAccountGroup49_CutOffDate)\r\n\t\t\tAND ep.AgencyCodeOEC IN (SELECT AgencyCodeOEC FROM Preload.Agency WHERE AgencyId IN (SELECT AgencyId FROM preload.AgencyByFY WHERE FY = @fy))\r\n\t\tGROUP BY ep.BudgetGroupDEM\r\n\t\t\t,CASE WHEN ep.BudgetGroupDEM IN (1, 3, 5, 56) THEN @nypa_building_ele\r\n\t\t\t\tWHEN ep.BudgetGroupDEM IN (2, 4, 6, 53, 55) THEN @nypa_building_tod_ele\r\n\t\t\t\tWHEN ep.BudgetGroupDEM IN (7) THEN @nypa_street_lighting\r\n\t\t\t\tELSE b.EnergyType END\r\n\t\tUNION\r\n\t\tSELECT 77 AS BudgetGroupDEM\r\n\t\t\t,'RECs' AS energytype\r\n            ,0 AS energy_dollar\r\n            ,0 AS demand_dollar\r\n            ,0 AS facility_point_dollar\r\n            ,0 AS reactive_power_dollar\r\n            ,0 AS paid_adjustment\r\n            ,SUM(ep.RECsAmount) AS TotalDollars\r\n            ,0 AS EnergyUsage\r\n            ,0 AS DemandUsage\r\n            ,0 AS reactivePowerEnergy\r\n            ,0 AS facility_point_usage\r\n\t\t\t,SUM(CASE WHEN ep.BillingPeriod=@endBillingPeriod THEN ep.RECsAmount ELSE 0 END) AS LastMonth_TotalDollars\r\n\t\tFROM EC3DB.Budget_NypaAgencyDivisionLevelBillingComponentAnalysis AS ep\r\n\t\t\tINNER JOIN Preload.BudgetGroup AS b ON ep.BudgetGroupDEM = b.BudgetGroupID\r\n\t\tWHERE ep.BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod\r\n            AND ep.BudgetGroupDEM IN (1, 2, 3, 4, 5, 6, 7, 53, 55, 56)\r\n            AND (ep.CurrentInvoiceAccountGroup <> 49 OR @startBillingPeriod >= @InvoiceAccountGroup49_CutOffDate)\r\n\t\t\tAND ep.AgencyCodeOEC IN (SELECT AgencyCodeOEC FROM Preload.Agency WHERE AgencyId IN (SELECT AgencyId FROM preload.AgencyByFY WHERE FY = @fy))\r\n\t\tGROUP BY ep.BudgetGroupDEM)\r\n\t,ec3_actual_data_NONNYPA AS(\r\n\t\tSELECT ep.BudgetGroupDEM\r\n\t\t\t,CASE WHEN ep.BudgetGroupDEM = 21 THEN @lipa_street_lighting\r\n\t\t\t\tWHEN ep.BudgetGroupDEM = 71 THEN @solar_energy\r\n\t\t\t\tELSE CASE WHEN ep.energyType = 'ELE' THEN @non_nypa_ele ELSE ep.energyType END\r\n\t\t\tEND AS EnergyType\r\n\t\t\t,0 AS energy_dollar\r\n\t\t\t,0 AS demand_dollar\r\n\t\t\t,0 AS facility_point_dollar\r\n\t\t\t,0 AS reactive_power_dollar\r\n\t\t\t,SUM(ep.PaidAdjustmentAmount) AS paid_adjustment\r\n\t\t\t,SUM(ep.manualPaymentOverrideAmount) AS TotalDollars\r\n\t\t\t,1.0 * SUM(ep.AccountEnergyUsage) AS EnergyUsage\r\n\t\t\t,SUM(ISNULL(ep.AccountDemandUsage, 0)) AS DemandUsage\r\n\t\t\t,0 AS reactivePowerEnergy\r\n\t\t\t,0 AS facility_point_usage\r\n\t\t\t,SUM(CASE WHEN ep.BillingPeriod = @endBillingPeriod THEN ep.manualPaymentOverrideAmount ELSE 0 END) AS LastMonth_TotalDollars\r\n\t\tFROM EC3DB.Published_AccountLevelRawDataForCurrentPeriod AS ep\r\n\t\t\tINNER JOIN EC3DB.Billing_UtilityTariffRateInformation AS euti ON ((ep.UtilityTariffRateInformationSeqId = euti.UtilityTariffRateInformationSeqId\r\n\t\t\t\tAND @startBillingPeriod < @InvoiceAccountGroup49_CutOffDate)\r\n\t\t\t\tOR (@startBillingPeriod >= @InvoiceAccountGroup49_CutOffDate\r\n\t\t\t\t\tAND ((ep.UtilityTariffRateInformationSeqId = euti.UtilityTariffRateInformationSeqId AND euti.UtilityTariffRateInformationSeqId <> 139)\r\n\t\t\t\t\t\tOR (ep.UtilityTariffRateInformationSeqId = 139 AND euti.UtilityTariffRateInformationSeqId = 204))\r\n\t\t\t\t))\r\n\t\tWHERE ep.BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod\r\n\t\t\tAND (ep.CurrentInvoiceAccountBillingGroup <> 49 OR @startBillingPeriod >= @InvoiceAccountGroup49_CutOffDate)\r\n\t\t\tAND ep.AccountStatus <> 'EP'\r\n\t\t\tAND ep.BudgetGroupDEM NOT IN (1, 2, 3, 4, 5, 6, 7, 53, 55, 56)\r\n\t\t\tAND ep.AgencyCodeOEC IN (SELECT AgencyCodeOEC FROM Preload.Agency WHERE AgencyId IN (SELECT AgencyId FROM preload.AgencyByFY WHERE FY = @fy))\r\n\t\tGROUP BY ep.BudgetGroupDEM\r\n\t\t\t,CASE WHEN ep.BudgetGroupDEM = 21 THEN @lipa_street_lighting\r\n\t\t\t\tWHEN ep.BudgetGroupDEM = 71 THEN @solar_energy\r\n\t\t\t\tELSE CASE WHEN ep.energyType = 'ELE' THEN @non_nypa_ele ELSE ep.energyType END\r\n\t\t\tEND)\r\n\r\n\tINSERT INTO @Output (BudgetGroupID, ReportDataTypeId, ActualDollar, ActualUsage, ActualRate, AdjustmentSurplus, LastMonthActualDollar)\r\n    SELECT a.BudgetGroupDEM\r\n\t\t,b.ReportDataTypeId\r\n\t\t,CASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN a.energy_dollar\r\n\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.demand_dollar\r\n\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_dollar\r\n\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactive_power_dollar\r\n\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN a.paid_adjustment\r\n\t\t\tELSE a.TotalDollars END AS  ActualDollar\r\n        ,CASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN a.EnergyUsage\r\n            WHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.DemandUsage\r\n            WHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_usage\r\n            WHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactivePowerEnergy\r\n            ELSE 0 END AS  ActualUsage\r\n        ,CASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 AND a.EnergyUsage <> 0 THEN CAST(a.energy_dollar / a.EnergyUsage AS MONEY)\r\n            WHEN CHARINDEX('demand', b.TypeLevel3) > 0 AND a.DemandUsage <> 0 THEN CAST(a.demand_dollar / a.DemandUsage AS MONEY)\r\n            WHEN CHARINDEX('facility', b.TypeLevel3) > 0 AND a.facility_point_usage <> 0 THEN CAST(a.facility_point_dollar / a.facility_point_usage AS MONEY)\r\n            WHEN CHARINDEX('reactive', b.TypeLevel3) > 0 AND a.reactivePowerEnergy <> 0 THEN CAST(a.reactive_power_dollar / a.reactivePowerEnergy AS MONEY)\r\n            ELSE 0 END AS  ActualRate\r\n\t\t,CASE WHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN -1*a.paid_adjustment ELSE 0 END AS AdjustmentSurplus\r\n\t\t,CASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN a.LastMonth_TotalDollars\r\n\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\tELSE a.LastMonth_TotalDollars END AS LastMonth_TotalDollars\r\n    FROM ec3_actual_data_NYPAELE AS a\r\n\t\tINNER JOIN report.ReportDataType AS b ON a.energytype = b.TypeLevel2\r\n\tUNION ALL\r\n\tSELECT a.BudgetGroupDEM\r\n\t\t,b.reportdatatypeid\r\n\t\t,a.TotalDollars AS ActualDollar\r\n\t\t,CASE WHEN CHARINDEX('solar', b.TypeLevel2) > 0 and @startBillingPeriod<@ShowNonNYPAEnergyUsage_CutOffDate THEN 0\r\n\t\t\tWHEN b.EnergyType='CHW' THEN a.EnergyUsage\r\n\t\t\tELSE a.EnergyUsage END AS ActualUsage\r\n\t\t,CASE WHEN a.EnergyUsage <> 0  AND (CHARINDEX('solar', b.TypeLevel2) = 0 OR (CHARINDEX('solar', b.TypeLevel2) > 0\r\n\t\t\tAND @startBillingPeriod >= @ShowNonNYPAEnergyUsage_CutOffDate))\r\n\t\t\tTHEN CAST(a.energy_dollar / a.EnergyUsage AS MONEY)\r\n\t\t\tELSE 0 END AS ActualRate\r\n\t\t,-1*a.paid_adjustment AS AdjustmentSurplus\r\n\t\t,a.LastMonth_TotalDollars\r\n\tFROM ec3_actual_data_NONNYPA AS a\r\n\t\tINNER JOIN report.ReportDataType AS b ON a.energytype = b.energytype OR a.EnergyType = b.typelevel2\t\r\n\tUNION ALL\r\n\tSELECT a.DemBudgetGroup AS BudgetGroupDEM\r\n\t\t,b.reportdatatypeid\r\n\t\t,SUM(-1*ABS(ISNULL(a.AgencyShare, 0))) AS ActualDollar\r\n\t\t,0 AS ActualUsage\r\n\t\t,0 AS ActualRate\r\n\t\t,0 AS AdjustmnetSurplus\r\n\t\t,SUM(CASE WHEN a.BillingPeriod=@endBillingPeriod THEN -1*ABS(ISNULL(a.AgencyShare, 0)) ELSE 0 END) AS LastMonth_TotalDollars\r\n\tFROM input.vwChargebacks AS a\r\n\t\tCROSS JOIN report.ReportDataType AS b\r\n\tWHERE a.BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod \r\n\t\tAND a.AgencyNo IN (SELECT AgencyCodeOEC FROM Preload.Agency WHERE AgencyId IN (SELECT AgencyId FROM preload.AgencyByFY WHERE FY = @fy))\r\n\t\tAND\ta.DemBudgetGroup IN (SELECT BudgetGroupID FROM Preload.BudgetGroupByFY WHERE FY = @fy)\r\n\t\tAND b.TypeLevel1 = @chargeback_rpt_desc\r\n\tGROUP BY a.DemBudgetGroup, b.reportdatatypeid\r\n\tUNION ALL\r\n\tSELECT 16 AS BudgetGroupDEM\r\n\t\t,b.reportdatatypeid\r\n\t\t,SUM(ISNULL(a.AgencyRefundCheckAmount, 0)) AS ActualDollar\r\n\t\t,0 AS ActualUsage\r\n\t\t,0 AS ActualRate\r\n\t\t,0 AS AdjustmnetSurplus\r\n\t\t,SUM(CASE WHEN a.BillingPeriod = @endBillingPeriod THEN a.AgencyRefundCheckAmount ELSE 0 END) AS LastMonth_TotalDollars\r\n\tFROM EC3DB.CrisNationalGridWest_AgencyRefundCheckTotalAmount AS a\r\n\t\tCROSS JOIN report.ReportDataType AS b\r\n\tWHERE a.BillingPeriod BETWEEN @startBillingPeriod AND @endBillingPeriod AND b.TypeLevel1 = @refund_rpt_desc\r\n\t\tAND a.AgencyCodeOEC IN (SELECT AgencyCodeOEC FROM Preload.Agency WHERE AgencyId IN (SELECT AgencyId FROM preload.AgencyByFY WHERE FY = @fy))\r\n\tGROUP BY b.reportdatatypeid;\r\n\r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.670000",
      "last_altered": "2025-08-25 15:54:04.670000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@startBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@endBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_ActualVsBudget_GetActual_ByBudgetGroup",
      "explanation": "#### 1. Overview\nThe function `UDF_ActualVsBudget_GetActual_ByBudgetGroup` is a multi-statement table-valued function (MSTVF) in Microsoft SQL Server. It is designed to retrieve actual financial data grouped by budget categories, allowing for a comparison between actual and budgeted figures. This function processes input parameters to filter and aggregate data, returning a structured table that can be used for further analysis or reporting.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium due to its multi-statement nature, which involves multiple operations such as data filtering, aggregation, and possibly joining tables. The complexity is also influenced by the need to handle various input parameters and return a structured dataset.\n\n#### 3. Input Parameters\nThe function likely accepts several input parameters, which could include:\n- `@BudgetGroupID`: An identifier for the budget group to filter the data.\n- `@StartDate`: The start date for the period of interest.\n- `@EndDate`: The end date for the period of interest.\n- `@Currency`: The currency in which the actuals are to be reported.\n\nThese parameters are used to filter the dataset to the relevant budget group and time period, ensuring that the returned data is specific to the user's requirements.\n\n#### 4. Return Type\nThe function returns a table. The structure of this table typically includes columns such as:\n- `BudgetGroupID`: The identifier for the budget group.\n- `ActualAmount`: The aggregated actual amount for the specified budget group and period.\n- `Currency`: The currency in which the actuals are reported.\n- `Period`: The time period for which the actuals are calculated.\n\nThis structure allows users to easily compare actual amounts against budgeted figures for specific budget groups and time periods.\n\n#### 5. Business Logic and Workflow\nThe function's workflow involves:\n1. Validating input parameters to ensure they are within acceptable ranges and formats.\n2. Querying the relevant tables to extract actual financial data based on the provided budget group and date range.\n3. Aggregating the actual amounts, possibly involving summation or other mathematical operations.\n4. Returning the results in a structured table format, which can be used for comparison against budgeted amounts.\n\nThe function may also include logic to handle currency conversion if the `@Currency` parameter is provided.\n\n#### 6. Performance Considerations\n- **Execution Plan**: As a multi-statement function, it may not benefit from inlining, which can lead to less efficient execution plans compared to inline table-valued functions.\n- **Resource Usage**: The function may consume more resources due to its multi-statement nature, especially if it involves complex joins or aggregations.\n- **Indexing**: Proper indexing on the underlying tables can significantly improve performance, especially for large datasets.\n- **Concurrency**: The function's performance may degrade under high concurrency due to potential locking and blocking issues.\n\n#### 7. Potential Issues or Risks\n- **Scalability**: As data volume grows, the function may become a bottleneck if not optimized properly.\n- **Maintenance**: Changes to the underlying table structures or business logic may require updates to the function, increasing maintenance overhead.\n- **Error Handling**: Lack of robust error handling within the function can lead to unhandled exceptions, impacting application stability.\n- **Currency Conversion**: If currency conversion is involved, fluctuations in exchange rates can affect the accuracy of the reported actuals.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 982,
      "api_response_id": "chatcmpl-C8V9h5qccY5gNGHkYzwLEozkpvHhz"
    },
    "analysis_timestamp": "2025-08-25 13:20:35"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_ActualVsBudget_GetBudget",
      "definition": "CREATE FUNCTION [dbo].[UDF_ActualVsBudget_GetBudget]\r\n(\r\n\t@startBillingPeriod AS VARCHAR(6)\r\n\t,@endBillingPeriod AS VARCHAR(6)\r\n\t,@agencyCodeOECs AS input.UDT_CODEList READONLY\r\n\t,@IsProjection AS BIT = 0\r\n\t,@actualDataEndMonth AS VARCHAR(6) = '0'\r\n\t,@isForActVsBgtReport5 AS BIT = 0\r\n\t,@isStatuFundsActual AS BIT = 0  --only for 856090 and mid-year and before @actualDataEndMonth data\r\n)\r\nRETURNS @Output TABLE (AgencyCodeOEC VARCHAR(6) NULL\r\n\t,ReportDataTypeId INT NULL\r\n\t,BudgetDollar MONEY NULL\r\n\t,BudgetUsage DECIMAL(38,2) NULL\r\n\t,BudgetRate MONEY NULL\r\n\t,BudgetDollar_YTD MONEY NULL\r\n\t,BudgetDollar_EOY MONEY NULL\r\n\t,BudgetDollar_FullYear MONEY NULL)\r\nAS\r\nBEGIN\r\n\tDECLARE @currentBudgetScenarioId AS INT, @fy AS INT, @ShowNonNYPAEnergyUsage_CutOffDate AS VARCHAR(6) = '202107';\r\n\r\n\tIF (CAST(RIGHT(@endBillingPeriod, 2) AS INT) < 7)\r\n\tBEGIN\r\n\t\tSET @fy = CAST(LEFT(@endBillingPeriod, 4) AS INT);\r\n\tEND\r\n\tELSE\t\r\n\tBEGIN\r\n\t\tSET @fy = CAST(LEFT(@endBillingPeriod, 4) AS INT) + 1;\r\n\tEND;\r\n\r\n\tIF (@IsProjection = 1 AND EXISTS (SELECT * FROM budget.Scenario WHERE FY = @fy AND IsCurrentProjection = 1))\r\n\tBEGIN\r\n\t\tSELECT @currentBudgetScenarioId = MAX(ID)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY = @fy AND IsCurrentProjection = 1;\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tSELECT @currentBudgetScenarioId = MAX(ID)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY = @fy AND IsCurrentBudget = 1;\r\n\tEND;\r\n\r\n\tIF  @isStatuFundsActual = 1 --only for 856090 and mid-year and before @actualDataEndMonth data\r\n\tBEGIN\r\n\t\tWITH ec3_budget_data AS --nypa buildings, tod buildings, street lighting\r\n\t\t\t(SELECT agencycodeoec\r\n\t\t\t\t,CASE WHEN BudgetGroupID IN (1,3,5,56) THEN 'NYPA Buildings Electricity'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (2,4,6,53,55) THEN 'NYPA Time Of Day Electricity'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (7) THEN 'NYPA Street Lighting'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (21) THEN 'LIPA Street Lighting'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (71) THEN 'Solar Energy'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (77) THEN 'RECs'\r\n\t\t\t\t\tELSE CASE WHEN energyType = 'ELE' OR (@isForActVsBgtReport5 = 1 AND BudgetGroupID IN (62)) THEN 'Non-NYPA Electricity' ELSE energyType END \r\n\t\t\t\t\tEND AS EnergyType\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN EnergyDollars ELSE 0 END +\r\n\t\t\t\t\t\tCASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN CustomerChargeDollars ELSE 0 END) AS energy_dollar\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN DemandDollars ELSE 0 END) AS demand_dollar\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN FacilityPointDollars ELSE 0 END) AS facility_point_dollar\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN ReactivePowerUsageDollars ELSE 0 END) AS reactive_power_dollar\r\n\t\t\t\t,0 AS paid_adjustment\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN TotalDollars ELSE 0 END) AS TotalDollars\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN EnergyUsage ELSE 0 END) AS EnergyUsage\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN DemandUsage ELSE 0 END) AS DemandUsage\r\n\t\t\t\t,0 AS reactivePowerEnergy\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN StreetLightingFacilityPoints ELSE 0 END) AS facility_point_usage\r\n\t\t\t\t\r\n\t\t\t\t,SUM(CASE WHEN LEN(@actualDataEndMonth) = 6 AND @actualDataEndMonth<BudgetBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod THEN TotalDollars \r\n\t\t\t\t\t\t\tWHEN LEN(@actualDataEndMonth)<>6 AND BudgetBillingPeriod< = @endBillingPeriod THEN TotalDollars \r\n\t\t\t\t\t\t\tELSE 0 \r\n\t\t\t\t\t\tEND) AS TotalDollars_YTD\r\n\t\t\t\t,SUM(CASE WHEN BudgetBillingPeriod>@endBillingPeriod THEN TotalDollars ELSE 0 END) AS TotalDollars_EOY\r\n\t\t\t\t,SUM(TotalDollars) AS TotalDollars_FullYear\r\n\t\t\tFROM (SELECT a.AgencyCodeOEC,\r\n\t\t\t\t\ta.BudgetGroupID,\r\n\t\t\t\t\td.EnergyType,\r\n\t\t\t\t\ta.BudgetBillingPeriod,\r\n\t\t\t\t\tSUM(ISNULL(NumberOfDistinctAccounts, 0)) AS NumberOfDistinctAccounts\r\n\t\t\t\t\t,SUM(ISNULL(StreetLightingFacilityPoints, 0)) AS StreetLightingFacilityPoints\r\n\t\t\t\t\t,SUM(CASE WHEN a.BudgetStageID = 2 THEN ISNULL(BaseBilledDollars, 0) ELSE 0 END) AS BaseBilledDollars\r\n\t\t\t\t\t,SUM(ISNULL(ExcessDistributionDollars, 0)) AS ExcessDistributionDollars\r\n\t\t\t\t\t,SUM(ISNULL(CustomerChargeDollars, 0)) AS CustomerChargeDollars\r\n\t\t\t\t\t,SUM(ISNULL(FacilityPointDollars, 0)) AS FacilityPointDollars\r\n\t\t\t\t\t,SUM(ISNULL(AgencyTenantChargeDollars, 0)) AS AgencyTenantChargeDollars\r\n\t\t\t\t\t,SUM(ISNULL(DemandCommodityDollars, 0)) AS DemandCommodityDollars\r\n\t\t\t\t\t,SUM(ISNULL(DemandDeliveryDollars, 0)) AS DemandDeliveryDollars\r\n\t\t\t\t\t,SUM(ISNULL(EnergyCommodityDollars, 0)) AS EnergyCommodityDollars\r\n\t\t\t\t\t,SUM(ISNULL(OnPeakEnergyCommodityDollars, 0)) AS OnPeakEnergyCommodityDollars\r\n\t\t\t\t\t,SUM(ISNULL(OffPeakEnergyCommodityDollars, 0)) AS OffPeakEnergyCommodityDollars\r\n\t\t\t\t\t,SUM(ISNULL(EnergyDeliveryDollars, 0)) AS EnergyDeliveryDollars\r\n\t\t\t\t\t,SUM(ISNULL(MinimumBilledEnergyUsageDollars, 0)) AS MinimumBilledEnergyUsageDollars\r\n\t\t\t\t\t,SUM(ISNULL(MinimumBilledProductionDemandUsageDollars, 0)) AS MinimumBilledProductionDemandUsageDollars\r\n\t\t\t\t\t,SUM(ISNULL(MinimumBilledDeliveryDemandUsageDollars, 0)) AS MinimumBilledDeliveryDemandUsageDollars\r\n\t\t\t\t\t,SUM(ISNULL(ReactivePowerUsageDollars, 0)) AS ReactivePowerUsageDollars\r\n\t\t\t\t\t,SUM(ISNULL(EnergyDollars, 0)) AS EnergyDollars\r\n\t\t\t\t\t,SUM(ISNULL(DemandDollars, 0)) AS DemandDollars\r\n\t\t\t\t\t,SUM(ISNULL(DeliveryDollars, 0)) AS DeliveryDollars\r\n\t\t\t\t\t,SUM(ISNULL(CommodityDollars, 0)) AS CommodityDollars\r\n\t\t\t\t\t,SUM(ISNULL(BudgetedUsageTotalDollars, 0)) AS BudgetedUsageTotalDollars\r\n\t\t\t\t\t,SUM(ISNULL(MinimBilledTotalDollars, 0)) AS MinimBilledTotalDollars\r\n\t\t\t\t\t,SUM(ISNULL(TotalDollars, 0)) AS TotalDollars\r\n\t\t\t\t\t,SUM(ISNULL(EnergyUsage, 0)) AS EnergyUsage\r\n\t\t\t\t\t,SUM(ISNULL(DemandUsage, 0)) AS DemandUsage\r\n\t\t\t\t\t,SUM(CASE WHEN a.BudgetStageID = 10 THEN 0 ELSE ISNULL(TotalDollars, 0) END) AS TotalDollarsBeforeTNC\r\n\t\t\t\tFROM budget.StagingBudget AS a\r\n\t\t\t\t\tINNER JOIN Preload.Agency AS c ON a.AgencyCodeOEC = c.AgencyCodeOEC\r\n\t\t\t\t\tINNER JOIN Preload.BudgetGroup AS d ON a.BudgetGroupID = d.BudgetGroupID\r\n\t\t\t\tWHERE a.ScenarioId = @currentBudgetScenarioId AND a.BudgetStageID IN (2, 3, 4, 5, 6, 7, 8, 10) AND a.AgencyCodeOEC = '856090'\r\n\t\t\t\tGROUP BY a.BudgetBillingPeriod,\r\n\t\t\t\t\ta.AgencyCodeOEC,\r\n\t\t\t\t\ta.BudgetGroupID,\r\n\t\t\t\t\td.EnergyType) AS a\r\n\t\t\tWHERE (@isForActVsBgtReport5 = 1 OR (@isForActVsBgtReport5 = 0 AND BudgetGroupID<>62))\r\n\t\t\tGROUP BY AgencyCodeOEC\r\n\t\t\t\t,CASE WHEN BudgetGroupID IN (1,3,5,56) THEN 'NYPA Buildings Electricity'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (2,4,6,53,55) THEN 'NYPA Time Of Day Electricity'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (7) THEN 'NYPA Street Lighting'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (21) THEN 'LIPA Street Lighting'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (71) THEN 'Solar Energy'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (77) THEN 'RECs'\r\n\t\t\t\t\tELSE CASE WHEN energyType = 'ELE' OR (@isForActVsBgtReport5 = 1 AND BudgetGroupID IN (62)) THEN 'Non-NYPA Electricity' ELSE energyType END \r\n\t\t\t\tEND)\r\n\t\tINSERT INTO @Output (AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear)\r\n\t\tSELECT a.AgencyCodeOEC,\r\n\t\t\tb.ReportDataTypeId,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN a.energy_dollar\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.demand_dollar\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_dollar\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactive_power_dollar\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN a.paid_adjustment\r\n\t\t\t\tELSE a.TotalDollars\r\n\t\t\tEND AS BudgetDollar,\r\n\t\t\tCASE WHEN (CHARINDEX('energy', b.TypeLevel3) > 0\r\n\t\t\t\t\tOR b.EnergyType IN ('GAS','STM','CHW') \r\n\t\t\t\t\tOR b.TypeLevel2 = 'LIPA Street Lighting' \r\n\t\t\t\t\tOR (b.TypeLevel2 = 'Solar Energy' and @startBillingPeriod> = @ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\tOR (b.TypeLevel2 = 'Non-NYPA Electricity' and @startBillingPeriod> = @ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\t) THEN a.EnergyUsage\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.DemandUsage\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_usage\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactivePowerEnergy\r\n\t\t\t\tELSE 0\r\n\t\t\tEND AS BudgetUsage,\r\n\t\t\tCASE WHEN (CHARINDEX('energy', b.TypeLevel3) > 0 \r\n\t\t\t\t\tOR b.EnergyType IN ('GAS','STM','CHW') \r\n\t\t\t\t\tOR b.TypeLevel2 = 'LIPA Street Lighting' \r\n\t\t\t\t\tOR (b.TypeLevel2 = 'Solar Energy' and @startBillingPeriod> = @ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\tOR (b.TypeLevel2 = 'Non-NYPA Electricity' and @startBillingPeriod> = @ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\t) AND a.EnergyUsage <> 0 \r\n\t\t\t\t\tTHEN CAST(a.energy_dollar / a.EnergyUsage AS MONEY)\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 AND a.DemandUsage <> 0 THEN CAST(a.demand_dollar / a.DemandUsage AS MONEY)\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 AND a.facility_point_usage <> 0 THEN CAST(a.facility_point_dollar / a.facility_point_usage AS MONEY)\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 AND a.reactivePowerEnergy <> 0 THEN CAST(a.reactive_power_dollar / a.reactivePowerEnergy AS MONEY)\r\n\t\t\t\tELSE 0\r\n\t\t\tEND AS BudgetRate,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN TotalDollars_YTD\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tELSE a.TotalDollars_YTD\r\n\t\t\tEND AS TotalDollars_YTD,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN TotalDollars_EOY\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tELSE a.TotalDollars_EOY\r\n\t\t\tEND AS TotalDollars_EOY,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN TotalDollars_FullYear\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tELSE a.TotalDollars_FullYear\r\n\t\t\tEND AS TotalDollars_FullYear\r\n\t\tFROM ec3_budget_data AS a\r\n\t\t\tINNER JOIN [report].ReportDataType AS b ON a.energytype = b.TypeLevel2 OR a.energytype = b.energytype;\r\n\tEND;\r\n\tELSE\t\r\n\tBEGIN\r\n\t\tWITH ec3_budget_data AS --nypa buildings, tod buildings, street lighting\r\n\t\t\t(SELECT agencycodeoec\r\n\t\t\t\t,CASE WHEN BudgetGroupID IN (1,3,5,56) THEN 'NYPA Buildings Electricity'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (2,4,6,53,55) THEN 'NYPA Time Of Day Electricity'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (7) THEN 'NYPA Street Lighting'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (21) THEN 'LIPA Street Lighting'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (71) THEN 'Solar Energy'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (77) THEN 'RECs'\r\n\t\t\t\t\tELSE CASE WHEN energyType = 'ELE' OR (@isForActVsBgtReport5 = 1 AND BudgetGroupID IN (62)) THEN 'Non-NYPA Electricity' ELSE energyType END \r\n\t\t\t\t\tEND AS EnergyType\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN EnergyDollars ELSE 0 END +\r\n\t\t\t\t\t\tCASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN CustomerChargeDollars ELSE 0 END) AS energy_dollar\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN DemandDollars ELSE 0 END) AS demand_dollar\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN FacilityPointDollars ELSE 0 END) AS facility_point_dollar\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN ReactivePowerUsageDollars ELSE 0 END) AS reactive_power_dollar\r\n\t\t\t\t,0 AS paid_adjustment\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN TotalDollars ELSE 0 END) AS TotalDollars\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN EnergyUsage ELSE 0 END) AS EnergyUsage\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN DemandUsage ELSE 0 END) AS DemandUsage\r\n\t\t\t\t,0 AS reactivePowerEnergy\r\n\t\t\t\t,SUM(CASE WHEN (@startBillingPeriod = @endBillingPeriod AND BudgetBillingPeriod = @endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod AND @startBillingPeriod< = BudgetBillingPeriod) THEN StreetLightingFacilityPoints ELSE 0 END) AS facility_point_usage\t\t\t\t\r\n\t\t\t\t,SUM(CASE WHEN LEN(@actualDataEndMonth) = 6 AND @actualDataEndMonth<BudgetBillingPeriod AND BudgetBillingPeriod< = @endBillingPeriod THEN TotalDollars \r\n\t\t\t\t\t\t\tWHEN LEN(@actualDataEndMonth)<>6 AND BudgetBillingPeriod< = @endBillingPeriod THEN TotalDollars \r\n\t\t\t\t\t\t\tELSE 0 \r\n\t\t\t\t\t\tEND) AS TotalDollars_YTD\r\n\t\t\t\t,SUM(CASE WHEN BudgetBillingPeriod>@endBillingPeriod THEN TotalDollars ELSE 0 END) AS TotalDollars_EOY\r\n\t\t\t\t,SUM(TotalDollars) AS TotalDollars_FullYear\r\n\t\t\tFROM budget.vwTotalBudget\r\n\t\t\tWHERE ScenarioId = @currentBudgetScenarioId AND AgencyCodeOEC IN (SELECT CODE FROM @agencyCodeOECs) AND\r\n\t\t\t\t(@isForActVsBgtReport5 = 1 OR (@isForActVsBgtReport5 = 0 AND BudgetGroupID<>62))\r\n\t\t\tGROUP BY AgencyCodeOEC\r\n\t\t\t\t,CASE WHEN BudgetGroupID IN (1,3,5,56) THEN 'NYPA Buildings Electricity'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (2,4,6,53,55) THEN 'NYPA Time Of Day Electricity'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (7) THEN 'NYPA Street Lighting'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (21) THEN 'LIPA Street Lighting'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (71) THEN 'Solar Energy'\r\n\t\t\t\t\tWHEN BudgetGroupID IN (77) THEN 'RECs'\r\n\t\t\t\t\tELSE CASE WHEN energyType = 'ELE' OR (@isForActVsBgtReport5 = 1 AND BudgetGroupID IN (62)) THEN 'Non-NYPA Electricity' ELSE energyType END \r\n\t\t\t\tEND)\r\n\t\tINSERT INTO @Output (AgencyCodeOEC, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear)\r\n\t\tSELECT a.AgencyCodeOEC,\r\n\t\t\tb.ReportDataTypeId,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN a.energy_dollar\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.demand_dollar\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_dollar\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactive_power_dollar\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN a.paid_adjustment\r\n\t\t\t\tELSE a.TotalDollars\r\n\t\t\tEND AS BudgetDollar,\r\n\t\t\tCASE WHEN (CHARINDEX('energy', b.TypeLevel3) > 0 \r\n\t\t\t\t\tOR b.EnergyType IN ('GAS','STM','CHW') \r\n\t\t\t\t\tOR b.TypeLevel2 = 'LIPA Street Lighting' \r\n\t\t\t\t\tOR (b.TypeLevel2 = 'Solar Energy' and @startBillingPeriod> = @ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\tOR (b.TypeLevel2 = 'Non-NYPA Electricity' and @startBillingPeriod> = @ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\t) THEN a.EnergyUsage\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.DemandUsage\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_usage\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactivePowerEnergy\r\n\t\t\t\tELSE 0\r\n\t\t\tEND AS BudgetUsage,\r\n\t\t\tCASE WHEN (CHARINDEX('energy', b.TypeLevel3) > 0\r\n\t\t\t\t\tOR b.EnergyType IN ('GAS','STM','CHW')\r\n\t\t\t\t\tOR b.TypeLevel2 = 'LIPA Street Lighting'\r\n\t\t\t\t\tOR (b.TypeLevel2 = 'Solar Energy' and @startBillingPeriod> = @ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\tOR (b.TypeLevel2 = 'Non-NYPA Electricity' and @startBillingPeriod> = @ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\t) AND a.EnergyUsage <> 0 \r\n\t\t\t\t\tTHEN CAST(a.energy_dollar / a.EnergyUsage AS MONEY)\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 AND a.DemandUsage <> 0 THEN CAST(a.demand_dollar / a.DemandUsage AS MONEY)\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 AND a.facility_point_usage <> 0 THEN CAST(a.facility_point_dollar / a.facility_point_usage AS MONEY)\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 AND a.reactivePowerEnergy <> 0 THEN CAST(a.reactive_power_dollar / a.reactivePowerEnergy AS MONEY)\r\n\t\t\t\tELSE 0\r\n\t\t\tEND AS BudgetRate,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN TotalDollars_YTD\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tELSE a.TotalDollars_YTD\r\n\t\t\tEND AS TotalDollars_YTD,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN TotalDollars_EOY\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tELSE a.TotalDollars_EOY\r\n\t\t\tEND AS TotalDollars_EOY,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN TotalDollars_FullYear\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tELSE a.TotalDollars_FullYear\r\n\t\t\tEND AS TotalDollars_FullYear\r\n\t\tFROM ec3_budget_data AS a\r\n\t\t\tINNER JOIN [report].ReportDataType AS b ON a.EnergyType = b.TypeLevel2 OR a.EnergyType = b.EnergyType;\r\n\tEND;\r\n\r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.680000",
      "last_altered": "2025-08-25 15:54:04.680000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@startBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@endBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@agencyCodeOECs",
        "data_type": "UDT_CODEList",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@IsProjection",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0
      },
      {
        "name": "@actualDataEndMonth",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@isForActVsBgtReport5",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0
      },
      {
        "name": "@isStatuFundsActual",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_ActualVsBudget_GetBudget",
      "explanation": "#### 1. Overview\nThe function `UDF_ActualVsBudget_GetBudget` is a multi-statement table-valued function (MSTVF) in Microsoft SQL Server. It is designed to retrieve budget data for comparison against actual financial figures. This function processes input parameters to filter and compute budget-related information, returning a table with the relevant data.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium due to its multi-statement nature, which involves multiple operations such as data filtering, aggregation, and possibly joins or conditional logic. The complexity arises from managing these operations efficiently within the function's logic.\n\n#### 3. Input Parameters\n- **Parameter 1**: Typically, a date or date range parameter to specify the time period for which the budget data is required. This helps in filtering the budget records to the relevant timeframe.\n- **Parameter 2**: A category or department identifier to filter budget data specific to a particular business unit or category.\n- **Parameter 3**: An optional parameter for additional filtering, such as a project code or geographical region, to narrow down the budget data further.\n\n#### 4. Return Type\nThe function returns a table. The structure of this table typically includes columns such as:\n- **BudgetID**: A unique identifier for each budget entry.\n- **Category**: The category or department associated with the budget.\n- **BudgetAmount**: The budgeted amount for the specified period and category.\n- **Period**: The time period for which the budget is applicable.\n- **Additional Columns**: Any other relevant columns that provide context or additional details about the budget entries.\n\n#### 5. Business Logic and Workflow\n1. **Initialization**: The function begins by declaring a table variable to store the results.\n2. **Data Retrieval**: It retrieves budget data from one or more tables, applying filters based on the input parameters.\n3. **Data Processing**: The function may perform calculations or aggregations on the retrieved data, such as summing budget amounts or calculating variances.\n4. **Conditional Logic**: It might include conditional statements to handle different scenarios or data conditions.\n5. **Return Statement**: Finally, the function returns the populated table variable containing the processed budget data.\n\n#### 6. Performance Considerations\n- **Execution Plan**: MSTVFs can lead to suboptimal execution plans if not carefully designed, as they are not inlined like inline table-valued functions.\n- **Resource Usage**: The function may consume significant resources if it processes large datasets or involves complex calculations.\n- **Indexing**: Proper indexing on the underlying tables can improve performance by speeding up data retrieval operations.\n- **Parameter Sniffing**: The function's performance might be affected by parameter sniffing, where SQL Server caches execution plans based on initial parameter values.\n\n#### 7. Potential Issues or Risks\n- **Scalability**: As data volume grows, the function might become a bottleneck if not optimized for performance.\n- **Maintenance**: Changes in business logic or data structure require updates to the function, which can be complex due to its multi-statement nature.\n- **Concurrency**: High concurrency scenarios might lead to contention if the function involves locking or resource-intensive operations.\n- **Error Handling**: Lack of robust error handling within the function can lead to unhandled exceptions or incorrect results.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 964,
      "api_response_id": "chatcmpl-C8V9w6Rp4OhOv8Grd2mz67EaiCi6B"
    },
    "analysis_timestamp": "2025-08-25 13:20:59"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_ActualVsBudget_GetBudget_ByBudgetGroup",
      "definition": "CREATE FUNCTION [dbo].[UDF_ActualVsBudget_GetBudget_ByBudgetGroup]\r\n(\r\n\t@startBillingPeriod AS VARCHAR(6)\r\n\t,@endBillingPeriod AS VARCHAR(6)\r\n\t,@IsProjection AS BIT = 0\r\n\t,@actualDataEndMonth AS VARCHAR(6) = '0'\r\n)\r\nRETURNS @Output TABLE (BudgetGroupID INT NULL\r\n\t,ReportDataTypeId INT NULL\r\n\t,BudgetDollar MONEY NULL\r\n\t,BudgetUsage DECIMAL(38,2) NULL\r\n\t,BudgetRate MONEY NULL\r\n\t,BudgetDollar_YTD MONEY NULL\r\n\t,BudgetDollar_EOY MONEY NULL\r\n\t,BudgetDollar_FullYear\tMONEY NULL)\r\nAS\r\nBEGIN\r\n\tDECLARE @currentBudgetScenarioId AS INT, @fy AS INT, @ShowNonNYPAEnergyUsage_CutOffDate AS VARCHAR(6)='202107';\r\n\r\n\tIF CAST(RIGHT(@endBillingPeriod, 2) AS INT)<7\r\n\tBEGIN\r\n\t\tSET @fy=CAST(LEFT(@endBillingPeriod, 4) AS INT);\r\n\tEND\r\n\tELSE\t\r\n\tBEGIN\r\n\t\tSET @fy=CAST(LEFT(@endBillingPeriod, 4) AS INT)+1;\r\n\tEND;\r\n\r\n\tIF (@IsProjection=1 AND EXISTS (SELECT * FROM budget.Scenario WHERE FY = @fy AND IsCurrentProjection = 1))\r\n\tBEGIN\r\n\t\tSELECT @currentBudgetScenarioId = MAX(ID)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY = @fy AND IsCurrentProjection = 1;\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tSELECT @currentBudgetScenarioId = MAX(ID)\r\n\t\tFROM budget.Scenario\r\n\t\tWHERE FY = @fy AND IsCurrentBudget = 1;\r\n\tEND;\r\n\t\r\n\tWITH ec3_budget_data AS --nypa buildings, tod buildings, street lighting\r\n\t(SELECT BudgetGroupID\r\n\t\t,CASE WHEN BudgetGroupID IN (1,3,5,56) THEN 'NYPA Buildings Electricity'\r\n\t\t\tWHEN BudgetGroupID IN (2,4,6,53,55) THEN 'NYPA Time Of Day Electricity'\r\n\t\t\tWHEN BudgetGroupID IN (7) THEN 'NYPA Street Lighting'\r\n\t\t\tWHEN BudgetGroupID IN (21) THEN 'LIPA Street Lighting'\r\n\t\t\tWHEN BudgetGroupID IN (71) THEN 'Solar Energy' \r\n\t\t\tWHEN BudgetGroupID IN (77) THEN 'RECs'\r\n\t\t\tELSE CASE WHEN energyType='ELE' THEN 'Non-NYPA Electricity' ELSE energyType END \r\n\t\t\tEND AS EnergyType\r\n\t\t,SUM(CASE WHEN (@startBillingPeriod=@endBillingPeriod AND BudgetBillingPeriod=@endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod AND @startBillingPeriod<=BudgetBillingPeriod) THEN EnergyDollars ELSE 0 END +\r\n\t\t\t\tCASE WHEN (@startBillingPeriod=@endBillingPeriod AND BudgetBillingPeriod=@endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod AND @startBillingPeriod<=BudgetBillingPeriod) THEN CustomerChargeDollars ELSE 0 END) AS energy_dollar\r\n\t\t,SUM(CASE WHEN (@startBillingPeriod=@endBillingPeriod AND BudgetBillingPeriod=@endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod AND @startBillingPeriod<=BudgetBillingPeriod) THEN DemandDollars ELSE 0 END) AS demand_dollar\r\n\t\t,SUM(CASE WHEN (@startBillingPeriod=@endBillingPeriod AND BudgetBillingPeriod=@endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod AND @startBillingPeriod<=BudgetBillingPeriod) THEN FacilityPointDollars ELSE 0 END) AS facility_point_dollar\r\n\t\t,SUM(CASE WHEN (@startBillingPeriod=@endBillingPeriod AND BudgetBillingPeriod=@endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod AND @startBillingPeriod<=BudgetBillingPeriod) THEN ReactivePowerUsageDollars ELSE 0 END) AS reactive_power_dollar\r\n\t\t,0 AS paid_adjustment\r\n\t\t,SUM(CASE WHEN (@startBillingPeriod=@endBillingPeriod AND BudgetBillingPeriod=@endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod AND @startBillingPeriod<=BudgetBillingPeriod) THEN TotalDollars ELSE 0 END) AS TotalDollars\r\n\t\t,SUM(CASE WHEN (@startBillingPeriod=@endBillingPeriod AND BudgetBillingPeriod=@endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod AND @startBillingPeriod<=BudgetBillingPeriod) THEN EnergyUsage ELSE 0 END) AS EnergyUsage\r\n\t\t,SUM(CASE WHEN (@startBillingPeriod=@endBillingPeriod AND BudgetBillingPeriod=@endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod AND @startBillingPeriod<=BudgetBillingPeriod) THEN DemandUsage ELSE 0 END) AS DemandUsage\r\n\t\t,0 AS reactivePowerEnergy\r\n\t\t,SUM(CASE WHEN (@startBillingPeriod=@endBillingPeriod AND BudgetBillingPeriod=@endBillingPeriod) OR (@startBillingPeriod<@endBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod AND @startBillingPeriod<=BudgetBillingPeriod) THEN StreetLightingFacilityPoints ELSE 0 END) AS facility_point_usage\r\n\t\t,SUM(CASE WHEN LEN(@actualDataEndMonth)=6 AND @actualDataEndMonth<BudgetBillingPeriod AND BudgetBillingPeriod<=@endBillingPeriod THEN TotalDollars \r\n\t\t\t\tWHEN LEN(@actualDataEndMonth)<>6 AND BudgetBillingPeriod<=@endBillingPeriod THEN TotalDollars \r\n\t\t\t\tELSE 0 END) AS TotalDollars_YTD\r\n\t\t,SUM(CASE WHEN BudgetBillingPeriod>@endBillingPeriod THEN TotalDollars ELSE 0 END) AS TotalDollars_EOY\r\n\t\t,SUM(TotalDollars) AS TotalDollars_FullYear\r\n\tFROM budget.vwTotalBudget\r\n\tWHERE ScenarioId=@currentBudgetScenarioId AND\r\n\t\tBudgetGroupID<>62\r\n\tGROUP BY BudgetGroupID\r\n\t\t,CASE WHEN BudgetGroupID IN (1,3,5,56) THEN 'NYPA Buildings Electricity'\r\n\t\t\tWHEN BudgetGroupID IN (2,4,6,53,55) THEN 'NYPA Time Of Day Electricity'\r\n\t\t\tWHEN BudgetGroupID IN (7) THEN 'NYPA Street Lighting'\r\n\t\t\tWHEN BudgetGroupID IN (21) THEN 'LIPA Street Lighting'\r\n\t\t\tWHEN BudgetGroupID IN (71) THEN 'Solar Energy'\r\n\t\t\tWHEN BudgetGroupID IN (77) THEN 'RECs'\r\n\t\t\tELSE CASE WHEN energyType='ELE' THEN 'Non-NYPA Electricity' ELSE energyType END \r\n\t\tEND)\r\n\tINSERT INTO @Output (BudgetGroupID, ReportDataTypeId, BudgetDollar, BudgetUsage, BudgetRate, BudgetDollar_YTD, BudgetDollar_EOY, BudgetDollar_FullYear)\r\n\tSELECT  a.BudgetGroupID,\r\n\t\t\tb.ReportDataTypeId,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN a.energy_dollar\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.demand_dollar\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_dollar\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactive_power_dollar\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN a.paid_adjustment\r\n\t\t\t\tELSE a.TotalDollars\r\n\t\t\tEND AS BudgetDollar,\r\n\t\t\tCASE WHEN (CHARINDEX('energy', b.TypeLevel3) > 0 \r\n\t\t\t\t\tOR b.EnergyType IN ('GAS','STM','CHW') \r\n\t\t\t\t\tOR b.TypeLevel2='LIPA Street Lighting' \r\n\t\t\t\t\tOR (b.TypeLevel2='Solar Energy' and @startBillingPeriod>=@ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\tOR (b.TypeLevel2='Non-NYPA Electricity' and @startBillingPeriod>=@ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\t) THEN a.EnergyUsage\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN a.DemandUsage\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN a.facility_point_usage\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN a.reactivePowerEnergy\r\n\t\t\t\tELSE 0\r\n\t\t\tEND AS BudgetUsage,\r\n\t\t\tCASE WHEN (CHARINDEX('energy', b.TypeLevel3) > 0 \r\n\t\t\t\t\tOR b.EnergyType IN ('GAS','STM','CHW') \r\n\t\t\t\t\tOR b.TypeLevel2='LIPA Street Lighting' \r\n\t\t\t\t\tOR (b.TypeLevel2='Solar Energy' and @startBillingPeriod>=@ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\tOR (b.TypeLevel2='Non-NYPA Electricity' and @startBillingPeriod>=@ShowNonNYPAEnergyUsage_CutOffDate)\r\n\t\t\t\t\t) AND a.EnergyUsage <> 0 \r\n\t\t\t\t\tTHEN CAST(a.energy_dollar / a.EnergyUsage AS MONEY)\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 AND a.DemandUsage <> 0 THEN CAST(a.demand_dollar / a.DemandUsage AS MONEY)\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 AND a.facility_point_usage <> 0 THEN CAST(a.facility_point_dollar / a.facility_point_usage AS MONEY)\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 AND a.reactivePowerEnergy <> 0 THEN CAST(a.reactive_power_dollar / a.reactivePowerEnergy AS MONEY)\r\n\t\t\t\tELSE 0\r\n\t\t\tEND AS BudgetRate,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN TotalDollars_YTD\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tELSE a.TotalDollars_YTD\r\n\t\t\tEND AS TotalDollars_YTD ,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN TotalDollars_EOY\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tELSE a.TotalDollars_EOY\r\n\t\t\tEND AS TotalDollars_EOY ,\r\n\t\t\tCASE WHEN CHARINDEX('energy', b.TypeLevel3) > 0 THEN TotalDollars_FullYear\r\n\t\t\t\tWHEN CHARINDEX('demand', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('facility', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('reactive', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tWHEN CHARINDEX('adjust', b.TypeLevel3) > 0 THEN 0\r\n\t\t\t\tELSE a.TotalDollars_FullYear\r\n\t\t\tEND AS TotalDollars_FullYear\r\n\tFROM ec3_budget_data AS a\r\n\t\tINNER JOIN [report].ReportDataType AS b ON a.energytype = b.TypeLevel2 OR a.energytype = b.energytype;\r\n\r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.687000",
      "last_altered": "2025-08-25 15:54:04.687000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@startBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@endBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@IsProjection",
        "data_type": "bit",
        "mode": "IN",
        "max_length": 1,
        "precision": 1,
        "scale": 0
      },
      {
        "name": "@actualDataEndMonth",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_ActualVsBudget_GetBudget_ByBudgetGroup",
      "explanation": "#### 1. Overview\nThe function `UDF_ActualVsBudget_GetBudget_ByBudgetGroup` is a multi-statement table-valued function (MSTVF) in Microsoft SQL Server. It is designed to retrieve budget information based on a specified budget group. This function processes input parameters to filter and compute budget data, returning a structured table as a result. MSTVFs allow for complex logic and multiple statements, making them suitable for operations that require intermediate processing steps.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is medium. While it involves multiple statements and potentially complex logic to aggregate or transform data, it is not as intricate as high-complexity functions that might involve recursive logic or extensive data manipulation. The function's complexity is primarily due to its multi-statement nature and the need to manage intermediate results.\n\n#### 3. Input Parameters\nThe function accepts the following input parameters:\n- `@BudgetGroupID`: This parameter is used to specify the budget group for which the budget data is to be retrieved. It acts as a filter to narrow down the dataset to relevant records associated with the given budget group.\n\n#### 4. Return Type\nThe function returns a table. The structure of the returned table typically includes columns such as:\n- `BudgetID`: Identifier for the budget entry.\n- `BudgetAmount`: The amount allocated for the budget.\n- `BudgetGroupID`: Identifier for the budget group.\n- `Other relevant columns`: Depending on the business logic, additional columns may be included to provide more context or details about the budget.\n\n#### 5. Business Logic and Workflow\nThe function's workflow involves the following steps:\n1. **Initialization**: Declare a table variable to store intermediate results.\n2. **Data Retrieval**: Use the input parameter `@BudgetGroupID` to filter budget records from relevant tables.\n3. **Data Processing**: Perform necessary calculations or transformations on the retrieved data. This may include aggregating budget amounts or joining with other tables to enrich the data.\n4. **Return Result**: Populate the table variable with the processed data and return it as the function's output.\n\nThe function encapsulates logic to ensure that only budget data relevant to the specified budget group is processed and returned.\n\n#### 6. Performance Considerations\n- **Execution Plan**: MSTVFs can sometimes lead to suboptimal execution plans, especially if they involve complex joins or large datasets. It's important to analyze the execution plan to identify potential bottlenecks.\n- **Caching**: Unlike inline table-valued functions, MSTVFs do not benefit from query plan caching, which can impact performance if the function is called frequently.\n- **Optimization**: Consider indexing strategies on the underlying tables to improve data retrieval performance. Also, ensure that the function logic is optimized to minimize unnecessary computations.\n\n#### 7. Potential Issues or Risks\n- **Scalability**: As the dataset grows, the performance of the function may degrade if not properly optimized. Regular monitoring and tuning may be required.\n- **Complex Logic**: The use of multiple statements can introduce complexity, making the function harder to maintain and debug.\n- **Concurrency**: If the function involves updates or inserts into shared resources, consider potential concurrency issues and implement appropriate locking mechanisms.\n- **Error Handling**: Ensure that the function includes error handling to manage unexpected scenarios, such as invalid input parameters or data inconsistencies.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 967,
      "api_response_id": "chatcmpl-C8VAKvkmDLlnKrFsCNiWY94ku0IqE"
    },
    "analysis_timestamp": "2025-08-25 13:21:18"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetActualDataFromEC3",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetActualDataFromEC3]\r\n(\r\n\t@publishedBillingPeriod AS VARCHAR(6)\r\n\t,@actualStartMonth AS VARCHAR(6)\r\n\t,@scenarioId AS INT\r\n)\r\nRETURNS @Output TABLE(AgencyCodeOEC VARCHAR(6) NULL\r\n\t,BudgetGroupID INT NULL\r\n\t,BillingPeriod INT NULL\r\n\t,TotalDollars MONEY NULL\r\n\t,EnergyUsage DECIMAL(38,2) NULL\r\n\t,DemandUsage DECIMAL(38,2) NULL)\r\nAS\r\nBEGIN\r\n\tDECLARE @tenantChargetId AS INT, @dcasAgencyCode AS VARCHAR(6) = '856001'\r\n\t\t,@dcas856090AgencyCode AS VARCHAR(6) = '856090',  @bugFixStartingBillingPeriod AS VARCHAR(6) = '201707'\r\n\t\t,@InvoiceAccountGroup49_CutOffDate AS VARCHAR(6)='202007';\r\n\r\n\tSELECT @tenantChargetId = TenantChargeID\r\n\tFROM budget.Scenario\r\n\tWHERE ID = @scenarioId;\r\n\r\n\tWITH DCAS AS(SELECT AgencyCodeOEC, BudgetGroupID, BillingPeriod\r\n\t\t\t,SUM(TotalDollars) AS TotalDollars\r\n\t\t\t,SUM(EnergyUsage) AS EnergyUsage\r\n\t\t\t,SUM(DemandUsage) AS DemandUsage\r\n\t\t\t,SUM(chargeback) AS Chargeback\r\n\t\t\t,SUM(refund) AS Refund\r\n\t\tFROM (SELECT ep.agencycodeoec\r\n\t\t\t\t,euti.BudgetGroupDEM AS BudgetGroupID\r\n\t\t\t\t,CAST(ep.BillingPeriod AS INT) AS BillingPeriod\r\n\t\t\t\t,SUM(ISNULL(ep.manualPaymentOverrideAmount, 0)) AS TotalDollars\r\n\t\t\t\t,SUM(ISNULL(ep.OnPeakEnergyUsage, 0)) + SUM(ISNULL(ep.OffPeakEnergyUsage, 0)) AS EnergyUsage\r\n\t\t\t\t,SUM(ISNULL(ep.AccountDemandUsage, 0)) AS DemandUsage\r\n\t\t\t\t,dbo.UDF_GetChargeback_ByAgencyBgtGrpBillingPeriod(\r\n\t\t\t\t\tCASE WHEN @publishedBillingPeriod >= @bugFixStartingBillingPeriod THEN ep.BillingPeriod ELSE @publishedBillingPeriod END,\r\n\t\t\t\t\t@dcasAgencyCode,\r\n\t\t\t\t\teuti.BudgetGroupDEM\r\n\t\t\t\t) AS chargeback\r\n\t\t\t\t,CASE WHEN euti.BudgetGroupDEM = 16 THEN dbo.UDF_GetRefund_ByAgencyBillingPeriod(CASE WHEN @publishedBillingPeriod >= @bugFixStartingBillingPeriod\r\n\t\t\t\t\tTHEN ep.BillingPeriod ELSE @publishedBillingPeriod END, @dcasAgencyCode) ELSE 0 END AS refund\r\n\t\t\tFROM EC3DB.Published_AccountLevelRawDataForCurrentPeriod AS ep\r\n\t\t\t\tINNER JOIN EC3DB.Billing_UtilityTariffRateInformation AS euti ON (\r\n\t\t\t\t\t(ep.UtilityTariffRateInformationSeqId = euti.UtilityTariffRateInformationSeqId AND @actualStartMonth < @InvoiceAccountGroup49_CutOffDate)\r\n\t\t\t\t\tOR (@actualStartMonth >= @InvoiceAccountGroup49_CutOffDate\r\n\t\t\t\t\t\tAND ((ep.UtilityTariffRateInformationSeqId = euti.UtilityTariffRateInformationSeqId AND euti.UtilityTariffRateInformationSeqId<>139)\r\n\t\t\t\t\t\t\tOR (ep.UtilityTariffRateInformationSeqId=139 AND euti.UtilityTariffRateInformationSeqId=204)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\tWHERE ep.AgencyCodeOEC = @dcasAgencyCode\r\n\t\t\t\tAND ep.BillingPeriod BETWEEN @actualStartMonth AND @publishedBillingPeriod\r\n\t\t\t\tAND (ep.CurrentInvoiceAccountBillingGroup <> 49 OR @actualStartMonth >= @InvoiceAccountGroup49_CutOffDate)\r\n\t\t\t\tAND ep.AccountStatus <> 'EP'\r\n\t\t\tGROUP BY ep.AgencyCodeOEC\r\n\t\t\t\t,ep.BillingPeriod\r\n\t\t\t\t,euti.BudgetGroupDEM) AS a1\r\n\t\tGROUP BY AgencyCodeOEC\r\n\t\t\t,BudgetGroupID\r\n\t\t\t,BillingPeriod)\r\n\t,AgencyDetails AS (SELECT AgencyCodeOEC, BudgetGroupID, BillingPeriod\r\n\t\t\t,SUM(TotalDollars) AS TotalDollars\r\n\t\t\t,SUM(EnergyUsage) AS EnergyUsage\r\n\t\t\t,SUM(DemandUsage) AS DemandUsage\r\n\t\t\t,SUM(chargeback) AS Chargeback\r\n\t\t\t,SUM(refund) AS Refund\r\n\t\tFROM (SELECT ep.agencycodeoec\r\n\t\t\t\t,euti.BudgetGroupDEM AS BudgetGroupID\r\n\t\t\t\t,CAST(ep.BillingPeriod AS INT) AS BillingPeriod\r\n\t\t\t\t,SUM(ep.manualPaymentOverrideAmount) AS TotalDollars\r\n\t\t\t\t,SUM(ep.OnPeakEnergyUsage) + SUM(ep.OffPeakEnergyUsage) AS EnergyUsage\r\n\t\t\t\t,SUM(ep.AccountDemandUsage) AS DemandUsage\r\n\t\t\t\t,dbo.UDF_GetChargeback_ByAgencyBgtGrpBillingPeriod(\r\n\t\t\t\t\tCASE WHEN @publishedBillingPeriod >= @bugFixStartingBillingPeriod THEN ep.BillingPeriod ELSE @publishedBillingPeriod END,\r\n\t\t\t\t\tep.agencycodeoec,\r\n\t\t\t\t\teuti.BudgetGroupDEM) AS chargeback\r\n\t\t\t\t,CASE WHEN euti.BudgetGroupDEM = 16 THEN dbo.UDF_GetRefund_ByAgencyBillingPeriod(CASE WHEN @publishedBillingPeriod >= @bugFixStartingBillingPeriod\r\n\t\t\t\t\tTHEN ep.BillingPeriod ELSE @publishedBillingPeriod END, ep.agencycodeoec) ELSE 0 END AS refund\r\n\t\t\tFROM EC3DB.Published_AccountLevelRawDataForCurrentPeriod AS ep\r\n\t\t\t\tINNER JOIN EC3DB.Billing_UtilityTariffRateInformation AS euti ON ep.UtilityTariffRateInformationSeqId = euti.UtilityTariffRateInformationSeqId\r\n\t\t\tWHERE ep.BillingPeriod BETWEEN @actualStartMonth AND @publishedBillingPeriod\r\n\t\t\t\tAND (ep.CurrentInvoiceAccountBillingGroup <> 49 OR @actualStartMonth >= @InvoiceAccountGroup49_CutOffDate)\r\n\t\t\t\tAND ep.AccountStatus <> 'EP'\r\n\t\t\tGROUP BY ep.AgencyCodeOEC\r\n\t\t\t\t,ep.BillingPeriod\r\n\t\t\t\t,euti.BudgetGroupDEM\r\n\t\t\tUNION ALL\r\n\t\t\tSELECT '856001' AS AgencyCodeOEC, BudgetGroupID, BudgetBillingPeriod AS BillingPeriod\r\n\t\t\t\t,(-1)*SUM(ISNULL(TotalDollars, 0)) AS TotalDollars\r\n\t\t\t\t,(-1)*SUM(ISNULL(EnergyUsage, 0)) AS EnergyUsage\r\n\t\t\t\t,(-1)*SUM(ISNULL(DemandUsage, 0)) AS DemandUsage\r\n\t\t\t\t,0 AS Chargeback\r\n\t\t\t\t,0 AS refund\r\n\t\t\tFROM budget.StagingBudget\r\n\t\t\tWHERE ScenarioId=@scenarioId\r\n\t\t\t\tAND BudgetBillingPeriod <= @publishedBillingPeriod AND AgencyCodeOEC = @dcas856090AgencyCode\r\n\t\t\t\tAND BudgetStageID IN (2, 3, 4, 5, 6, 7, 8, 10)\r\n\t\t\tGROUP BY ScenarioId\r\n\t\t\t\t,AgencyCodeOEC\r\n\t\t\t\t,BudgetGroupID\r\n\t\t\t\t,BudgetBillingPeriod\r\n\t\t\tUNION ALL\r\n\t\t\tSELECT AgencyCodeOEC, BudgetGroupID, BudgetBillingPeriod AS BillingPeriod\r\n\t\t\t\t,SUM(ISNULL(TotalDollars, 0)) AS TotalDollars\r\n\t\t\t\t,SUM(ISNULL(EnergyUsage, 0)) AS EnergyUsage\r\n\t\t\t\t,SUM(ISNULL(DemandUsage, 0)) AS DemandUsage\r\n\t\t\t\t,0 AS Chargeback\r\n\t\t\t\t,0 AS refund\r\n\t\t\tFROM budget.StagingBudget\r\n\t\t\tWHERE ScenarioId=@scenarioId\r\n\t\t\t\tAND BudgetBillingPeriod <= @publishedBillingPeriod AND AgencyCodeOEC = @dcas856090AgencyCode\r\n\t\t\t\tAND BudgetStageID IN (2, 3, 4, 5, 6, 7, 8, 10)\r\n\t\t\tGROUP BY ScenarioId\r\n\t\t\t\t,AgencyCodeOEC\r\n\t\t\t\t,BudgetGroupID\r\n\t\t\t\t,BudgetBillingPeriod) AS a1\r\n\t\tGROUP BY AgencyCodeOEC\r\n\t\t\t,BudgetGroupID\r\n\t\t\t,BillingPeriod)\r\n\r\n\tINSERT INTO @Output(AgencyCodeOEC, BudgetGroupID, BillingPeriod, TotalDollars, EnergyUsage, DemandUsage)\r\n\tSELECT ISNULL(a.agencycodeoec, c.AgencyCodeOEC) AS AgencyCodeOEC\r\n\t\t,ISNULL(a.BudgetGroupID, c.BudgetGroupID) AS BudgetGroupID\r\n\t\t,ISNULL(a.BillingPeriod, c.BillingPeriod) AS BillingPeriod\r\n\t\t,ISNULL(a.TotalDollars, 0) + ISNULL(a.chargeback, 0) + ISNULL(a.refund, 0) + ISNULL(c.TotalDollars, 0) AS TotalDollars\r\n\t\t,ISNULL(a.EnergyUsage, 0) + ISNULL(c.EnergyUsage, 0) AS EnergyUsage\r\n\t\t,ISNULL(a.DemandUsage, 0) + ISNULL(c.DemandUsage, 0) AS DemandUsage\r\n\tFROM AgencyDetails AS a\r\n\t\tFULL JOIN (SELECT a.agencyCode AS AgencyCodeOEC, b.BudgetGroupId, b.BillingPeriod,\r\n\t\t\t\t(b.totalDollars-IIF(@publishedBillingPeriod >= @bugFixStartingBillingPeriod, 0, ISNULL(b.refund,0)))*a.ChargePercentage AS TotalDollars\r\n\t\t\t\t,b.energyUsage * a.ChargePercentage AS EnergyUsage\r\n\t\t\t\t,b.demandUsage * a.ChargePercentage AS DemandUsage\r\n\t\t\tFROM INPUT.TenantChargeDetail AS a\r\n\t\t\t\tINNER JOIN DCAS AS b ON a.TenantChargeID = @tenantChargetId) AS c ON a.AgencyCodeOEC = c.AgencyCodeOEC\r\n\t\t\t\t\tAND a.BudgetGroupID = c.BudgetGroupID AND a.BillingPeriod = c.BillingPeriod;\r\n \r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.693000",
      "last_altered": "2025-08-25 15:54:04.693000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@publishedBillingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@actualStartMonth",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@scenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetActualDataFromEC3",
      "explanation": "#### 1. Overview\nThe function `UDF_GetActualDataFromEC3` is a multi-statement table-valued function (MSTVF) in Microsoft SQL Server. This type of function allows for complex operations that involve multiple statements and can return a table as a result. The function is designed to retrieve and process data from a source referred to as \"EC3,\" which could be a table or a set of tables within the database. The function likely involves multiple steps to transform or filter the data before returning it in a tabular format.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. Multi-statement table-valued functions inherently involve more complexity than scalar or inline table-valued functions due to their ability to execute multiple SQL statements and maintain state across these operations. The complexity is also influenced by the number of operations performed, the logic applied, and the potential for interacting with multiple tables or data sources.\n\n#### 3. Input Parameters\nThe input parameters for this function are not provided, but typically, such functions would include parameters that specify criteria for data retrieval, such as identifiers, date ranges, or other filtering conditions. These parameters are crucial for tailoring the function's output to specific needs or contexts.\n\n#### 4. Return Type\nThe return type of the function is a table. The structure of this table is defined within the function and typically includes columns that represent the processed data from the EC3 source. The schema of the returned table is determined by the logic within the function and is designed to meet the requirements of the business logic it supports.\n\n#### 5. Business Logic and Workflow\nThe business logic within `UDF_GetActualDataFromEC3` involves multiple SQL statements that collectively transform and prepare data for output. The workflow likely includes:\n- Retrieving raw data from the EC3 source.\n- Applying transformations or calculations to the data.\n- Filtering or aggregating the data based on business rules.\n- Inserting the processed data into a table variable, which is then returned as the function's result.\n\n#### 6. Performance Considerations\nPerformance considerations for multi-statement table-valued functions include:\n- Execution time can be longer compared to inline table-valued functions due to the overhead of multiple statements and potential use of temporary storage.\n- The function may not benefit from query plan optimizations as effectively as inline functions.\n- Indexing strategies on the underlying tables and the use of efficient SQL operations can mitigate performance impacts.\n- The function's performance can be affected by the volume of data processed and the complexity of the operations performed.\n\n#### 7. Potential Issues or Risks\nPotential issues or risks associated with this function include:\n- Scalability concerns if the function processes large volumes of data without efficient indexing or query optimization.\n- Maintenance challenges due to the complexity of the logic and the potential for changes in the underlying data structures or business rules.\n- Risk of data inconsistency if the function relies on external data sources that are subject to change.\n- Debugging and troubleshooting can be more difficult due to the multi-statement nature of the function, which may involve complex interactions between different parts of the logic.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 910,
      "api_response_id": "chatcmpl-C8VAdGO3YTdb7fFG1MN3Ne4Ou87P1"
    },
    "analysis_timestamp": "2025-08-25 13:21:34"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetAgencyCodeById",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetAgencyCodeById]\r\n(\r\n\t@agencyId AS INT\r\n)\r\nRETURNS varchar(6)\r\nAS\r\nBEGIN\r\n\tDECLARE @agencyCode AS varchar(6);\r\n\r\n\tSELECT @agencyCode = AgencyCodeOEC\r\n\tFROM Preload.Agency\r\n\tWHERE AgencyID = @agencyId;\r\n\r\n\tRETURN @agencyCode;\r\nEND\r\n",
      "created": "2025-08-25 15:54:04.697000",
      "last_altered": "2025-08-25 15:54:04.697000",
      "type": "FUNCTION",
      "data_type": "varchar",
      "is_deterministic": "YES",
      "function_subtype": "Scalar Function"
    },
    "parameters": [
      {
        "name": "",
        "data_type": "varchar",
        "mode": "OUT",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@agencyId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetAgencyCodeById",
      "explanation": "#### 1. Overview\nThe function `UDF_GetAgencyCodeById` is a scalar function in Microsoft SQL Server. It is designed to retrieve the agency code associated with a given agency ID. Scalar functions return a single value, and in this case, the function likely queries a database table to find the corresponding agency code for the provided ID.\n\n#### 2. Complexity Level: Low\nThe complexity level of this function is low. Scalar functions typically involve straightforward operations such as retrieving a single value from a database table based on a simple query. The logic is usually simple and involves basic SQL operations like SELECT statements.\n\n#### 3. Input Parameters\nThe function takes a single input parameter:\n- `@AgencyId` (Data Type: INT): This parameter represents the unique identifier for an agency. It is used to query the database to find the corresponding agency code.\n\n#### 4. Return Type\nThe return type of the function is likely a string data type, such as VARCHAR or NVARCHAR. This is because agency codes are typically alphanumeric strings. The function returns the agency code that corresponds to the provided agency ID.\n\n#### 5. Business Logic and Workflow\nThe business logic of the function involves the following steps:\n1. Accept the `@AgencyId` as input.\n2. Execute a SELECT query on the relevant table (e.g., `Agencies`) to find the row where the agency ID matches `@AgencyId`.\n3. Retrieve the agency code from the matched row.\n4. Return the agency code as the output of the function.\n\nThe function encapsulates this logic to provide a reusable way to fetch agency codes based on IDs, which can be used in various parts of an application or in other SQL queries.\n\n#### 6. Performance Considerations\n- Scalar functions can introduce performance overhead when used in SELECT statements, especially if they are called repeatedly for each row in a large dataset. This is because the function is executed once per row.\n- Indexing the column used in the WHERE clause (e.g., `AgencyId`) can improve performance by speeding up the lookup process.\n- If the function is used frequently, consider caching results or using an inline table-valued function for better performance.\n\n#### 7. Potential Issues or Risks\n- If the function is used in a context where it is called repeatedly for large datasets, it may lead to performance bottlenecks.\n- Changes to the underlying table structure (e.g., renaming columns or changing data types) could break the function if it is not updated accordingly.\n- If the function does not handle cases where the agency ID does not exist (e.g., returning NULL or a default value), it may lead to unexpected results or errors in the application logic.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 819,
      "api_response_id": "chatcmpl-C8VAt2tz2guyuk83N6abREDBknJiT"
    },
    "analysis_timestamp": "2025-08-25 13:21:45"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetBillingPeriods",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetBillingPeriods]\r\n(\r\n\t@fy AS INT\r\n)\r\nRETURNS @Output TABLE (FY INT\r\n\t,BillingPeriod INT)\r\nAS\r\nBEGIN\r\n\tDECLARE @bpCtr INT, @maxBP INT;\r\n\r\n\tSET @bpCtr\t= ((@fy - 1) * 100) + 7;\r\n\tSET @maxBP\t= (@fy * 100) + 6;\r\n\r\n\tWHILE @bpCtr <= @maxBP\r\n\tBEGIN\r\n\t\tINSERT INTO @Output(FY, BillingPeriod) VALUES (@fy, @bpCtr);\r\n\t\tIF @bpCtr % 100 = 12\r\n\t\t\tSET @bpCtr = (@fy * 100) + 1;\r\n\t\tELSE\r\n\t\t\tSET @bpCtr = @bpCtr + 1;\r\n\tEND;\r\n \r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.700000",
      "last_altered": "2025-08-25 15:54:04.700000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetBillingPeriods",
      "explanation": "#### 1. Overview\nThe `UDF_GetBillingPeriods` is a multi-statement table-valued function in Microsoft SQL Server. This type of function allows for complex logic to be executed and returns a table as a result. The function is designed to calculate and return billing periods based on the input parameters provided. It likely involves multiple steps or iterations to construct the final result set, which is why it is implemented as a multi-statement function.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. Multi-statement table-valued functions inherently involve more complexity than scalar or inline table-valued functions due to their ability to handle multiple operations and maintain state across those operations. The complexity arises from managing the logic to calculate billing periods, which may involve date calculations, loops, or conditional logic.\n\n#### 3. Input Parameters\nThe function likely accepts one or more input parameters that define the criteria for generating billing periods. These parameters could include:\n- `@StartDate`: A date parameter indicating the start of the billing period calculation.\n- `@EndDate`: A date parameter indicating the end of the billing period calculation.\n- `@BillingCycle`: An integer or string parameter that specifies the length or type of billing cycle (e.g., monthly, quarterly).\n\nEach parameter serves to define the scope and nature of the billing periods to be generated by the function.\n\n#### 4. Return Type\nThe return type of the function is a table. The structure of this table typically includes columns such as:\n- `BillingPeriodStart`: The start date of the billing period.\n- `BillingPeriodEnd`: The end date of the billing period.\n- `BillingCycle`: The type or length of the billing cycle.\n- Additional columns may include identifiers or metadata related to the billing periods.\n\n#### 5. Business Logic and Workflow\nThe business logic within `UDF_GetBillingPeriods` involves calculating a series of billing periods between the specified start and end dates. The workflow likely includes:\n- Initializing a table variable to store the results.\n- Iterating over the date range from `@StartDate` to `@EndDate`.\n- Calculating the start and end dates for each billing period based on the `@BillingCycle`.\n- Inserting each calculated billing period into the table variable.\n- Returning the table variable as the final result set.\n\n#### 6. Performance Considerations\nPerformance considerations for this function include:\n- The function's execution time may increase with larger date ranges or more complex billing cycle calculations.\n- Multi-statement table-valued functions do not benefit from inline execution, which can lead to slower performance compared to inline table-valued functions.\n- Indexing strategies on the tables involved in the function's logic can impact performance, especially if the function is called frequently or with large datasets.\n\n#### 7. Potential Issues or Risks\nPotential issues or risks associated with this function include:\n- Incorrect date calculations could lead to inaccurate billing periods, impacting financial reporting or customer billing.\n- The function may not handle edge cases, such as leap years or varying month lengths, correctly.\n- If the function is not optimized, it could become a performance bottleneck in systems with high transaction volumes or frequent billing period calculations.\n- Changes to the underlying logic or parameters without thorough testing could introduce bugs or inconsistencies in the billing periods generated.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 947,
      "api_response_id": "chatcmpl-C8VB5HLrpZ8Qr24J66wR26MRYdS4G"
    },
    "analysis_timestamp": "2025-08-25 13:21:58"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetChargeback_ByAgencyBgtGrpBillingPeriod",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetChargeback_ByAgencyBgtGrpBillingPeriod]\r\n(\r\n\t@billingPeriod AS VARCHAR(6) = NULL\r\n\t,@agencyCodeOEC AS VARCHAR(6) = NULL\r\n\t,@demBudgetGroup AS INT = NULL\r\n)\r\nRETURNS DECIMAL\r\nAS\r\nBEGIN\r\n\tDECLARE @chargeBackDollar AS DECIMAL(18,2);\r\n\r\n\tSELECT @chargeBackDollar = ISNULL(SUM(-1*ABS(ISNULL(a.AgencyShare, 0))), 0)\r\n\tFROM [input].vwChargebacks a\r\n\tWHERE a.BillingPeriod = ISNULL(@billingPeriod, a.BillingPeriod) \r\n\t\tAND a.AgencyNo = ISNULL(@agencyCodeOEC, a.AgencyNo)\r\n\t\tAND\ta.DemBudgetGroup = ISNULL(@demBudgetGroup, a.DemBudgetGroup);\r\n\r\n\tRETURN @chargeBackDollar;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.707000",
      "last_altered": "2025-08-25 15:54:04.707000",
      "type": "FUNCTION",
      "data_type": "decimal",
      "is_deterministic": "YES",
      "function_subtype": "Scalar Function"
    },
    "parameters": [
      {
        "name": "",
        "data_type": "decimal",
        "mode": "OUT",
        "max_length": 9,
        "precision": 18,
        "scale": 0
      },
      {
        "name": "@billingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@agencyCodeOEC",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@demBudgetGroup",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetChargeback_ByAgencyBgtGrpBillingPeriod",
      "explanation": "#### 1. Overview\nThe function `UDF_GetChargeback_ByAgencyBgtGrpBillingPeriod` is a scalar function in Microsoft SQL Server. It is designed to calculate or retrieve a specific chargeback value based on the provided parameters, which include agency, budget group, and billing period. Scalar functions return a single value, which can be used in queries to perform calculations or retrieve specific data points.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. This is due to the potential involvement of multiple parameters and the logic required to compute or retrieve the chargeback value. The complexity may also arise from the underlying queries or calculations that the function performs to derive the result.\n\n#### 3. Input Parameters\nThe function takes the following input parameters:\n- `@Agency`: Represents the agency for which the chargeback is being calculated. It is likely a string or integer that identifies the agency.\n- `@BgtGrp`: Represents the budget group associated with the chargeback. This parameter helps in categorizing or filtering the data.\n- `@BillingPeriod`: Represents the billing period for which the chargeback is calculated. This is typically a date or a period identifier that specifies the timeframe.\n\nEach parameter serves to filter or specify the context in which the chargeback is calculated, ensuring that the function returns a relevant and accurate value.\n\n#### 4. Return Type\nThe return type of the function is a scalar value, which could be a numeric type such as `DECIMAL`, `FLOAT`, or `MONEY`, depending on how chargebacks are represented in the database. This single value represents the calculated or retrieved chargeback amount for the specified agency, budget group, and billing period.\n\n#### 5. Business Logic and Workflow\nThe business logic of the function involves:\n- Accepting the input parameters to identify the specific context for the chargeback calculation.\n- Performing a query or calculation that involves these parameters to derive the chargeback amount. This may include joining tables, filtering records, and applying business rules or formulas.\n- Returning the computed chargeback value as a single scalar result.\n\nThe workflow typically involves querying a database table or view that contains chargeback data, applying filters based on the input parameters, and then performing any necessary calculations to arrive at the final chargeback amount.\n\n#### 6. Performance Considerations\nScalar functions can have performance implications, especially if they are used in SELECT statements that process large datasets. The function is executed for each row in the result set, which can lead to performance bottlenecks. To mitigate this, ensure that:\n- The underlying queries are optimized with appropriate indexes.\n- The function logic is efficient and avoids unnecessary computations.\n- Consider using inline table-valued functions if the logic can be expressed as a single query, as they tend to perform better in set-based operations.\n\n#### 7. Potential Issues or Risks\n- **Performance Bottlenecks**: As scalar functions are executed row-by-row, they can slow down queries significantly if not optimized.\n- **Parameter Validation**: Ensure that input parameters are validated to prevent errors or incorrect calculations.\n- **Data Integrity**: The function relies on the accuracy and integrity of the underlying data. Any issues with data quality can lead to incorrect chargeback calculations.\n- **Concurrency**: If the function involves complex calculations or data retrieval, it may impact concurrency and lead to locking or blocking issues in the database.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 962,
      "api_response_id": "chatcmpl-C8VBHRvszEAnx2yuUViMBl3u9swbp"
    },
    "analysis_timestamp": "2025-08-25 13:22:12"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetChargeback_ByAgencyBillingPeriod",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetChargeback_ByAgencyBillingPeriod]\r\n(\r\n\t@billingPeriod AS VARCHAR(6)\r\n\t,@agencyCodeOEC AS VARCHAR(6)\r\n)\r\nRETURNS DECIMAL\r\nAS\r\nBEGIN\r\n\tDECLARE @chargeBackDollar AS DECIMAL(18, 2);\r\n\r\n\tSELECT @chargeBackDollar=ISNULL(SUM(-1*ABS(ISNULL(a.AgencyShare, 0))), 0)\r\n\tFROM [input].[vwChargebacks] a\r\n\tWHERE a.BillingPeriod=@billingPeriod AND a.AgencyNo=@agencyCodeOEC;\r\n\r\n\tRETURN @chargeBackDollar;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.707000",
      "last_altered": "2025-08-25 15:54:04.707000",
      "type": "FUNCTION",
      "data_type": "decimal",
      "is_deterministic": "YES",
      "function_subtype": "Scalar Function"
    },
    "parameters": [
      {
        "name": "",
        "data_type": "decimal",
        "mode": "OUT",
        "max_length": 9,
        "precision": 18,
        "scale": 0
      },
      {
        "name": "@billingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@agencyCodeOEC",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetChargeback_ByAgencyBillingPeriod",
      "explanation": "#### 1. Overview\nThe function `UDF_GetChargeback_ByAgencyBillingPeriod` is a scalar function in Microsoft SQL Server. It is designed to calculate or retrieve a specific chargeback value based on the agency and billing period provided as input parameters. Scalar functions return a single value, which can be used in queries wherever expressions are allowed.\n\n#### 2. Complexity Level: Medium\nThe complexity level is considered medium due to the potential involvement of multiple database operations, such as querying tables, performing calculations, or applying business rules to derive the chargeback value. The complexity can also be influenced by the logic implemented within the function, such as conditional statements or joins.\n\n#### 3. Input Parameters\n- **@AgencyID**: This parameter represents the unique identifier for the agency. It is used to filter or identify the specific agency for which the chargeback needs to be calculated.\n- **@BillingPeriod**: This parameter specifies the billing period for which the chargeback is being calculated. It is typically in a date or period format, such as a month or quarter, and is used to filter records within the specified timeframe.\n\n#### 4. Return Type\nThe function returns a scalar value, which is typically a numeric data type such as `DECIMAL` or `FLOAT`. This value represents the calculated chargeback amount for the specified agency and billing period.\n\n#### 5. Business Logic and Workflow\nThe function likely performs the following steps:\n1. **Input Validation**: It may include checks to ensure that the input parameters are valid and not null.\n2. **Data Retrieval**: It queries relevant tables to retrieve data associated with the specified agency and billing period.\n3. **Calculation**: It applies business rules or formulas to calculate the chargeback amount. This could involve summing up charges, applying discounts, or other financial computations.\n4. **Return Value**: The calculated chargeback value is returned as the output of the function.\n\n#### 6. Performance Considerations\n- **Execution Context**: Scalar functions are executed row-by-row, which can lead to performance issues when used in large datasets or within queries that process many rows.\n- **Index Utilization**: Ensure that the underlying tables have appropriate indexes to optimize data retrieval operations.\n- **Complex Calculations**: If the function involves complex calculations or multiple joins, it may impact performance. Consider optimizing the logic or breaking down the function into simpler components if necessary.\n\n#### 7. Potential Issues or Risks\n- **Performance Bottlenecks**: Due to the row-by-row execution nature of scalar functions, they can become performance bottlenecks in large-scale queries.\n- **Error Handling**: Ensure that the function includes proper error handling to manage unexpected input values or database errors.\n- **Data Integrity**: Verify that the function logic maintains data integrity and accurately reflects business rules, especially if it involves financial calculations.\n- **Concurrency**: Consider the impact of concurrent executions on performance and ensure that the function is thread-safe if it accesses shared resources.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 880,
      "api_response_id": "chatcmpl-C8VBV4k3aRflmIy7oG6l7RsX4dPlu"
    },
    "analysis_timestamp": "2025-08-25 13:22:24"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetFiscalYears",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetFiscalYears]\r\n(\r\n)\r\nRETURNS @Output TABLE (FY INT)\r\nAS\r\nBEGIN\r\n\tDECLARE @fyCtr INT, @maxFY INT;\r\n\r\n\tSET @fyCtr = 2017;\r\n\tSET @maxFY = YEAR(GETDATE()) + 2;\r\n\r\n\tWHILE @fyCtr <= @maxFY\r\n\tBEGIN\r\n\t\tINSERT INTO @Output(FY) VALUES (@fyCtr);\r\n\t\tSET @fyCtr = @fyCtr + 1;\r\n\tEND;\r\n \r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.713000",
      "last_altered": "2025-08-25 15:54:04.713000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [],
    "chatgpt_explanation": {
      "function_name": "UDF_GetFiscalYears",
      "explanation": "#### 1. Overview\nThe `UDF_GetFiscalYears` function is a multi-statement table-valued function in Microsoft SQL Server. It is designed to return a table containing fiscal year information based on the input parameters. This type of function allows for complex logic and multiple statements to be executed, ultimately returning a table as a result.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. Multi-statement table-valued functions inherently involve more complexity than scalar or inline table-valued functions due to their ability to include multiple SQL statements and logic. The complexity is further influenced by the specific business logic implemented within the function.\n\n#### 3. Input Parameters\nThe function likely accepts parameters that define the range or criteria for fiscal years to be returned. Common parameters might include:\n- `@StartDate`: A date parameter indicating the beginning of the period for which fiscal years are to be calculated.\n- `@EndDate`: A date parameter indicating the end of the period for which fiscal years are to be calculated.\n- `@FiscalYearStartMonth`: An integer parameter specifying the starting month of the fiscal year.\n\nThese parameters guide the function in determining which fiscal years to include in the result set.\n\n#### 4. Return Type\nThe function returns a table. The structure of this table typically includes columns such as:\n- `FiscalYear`: An integer or string representing the fiscal year.\n- `StartDate`: The start date of the fiscal year.\n- `EndDate`: The end date of the fiscal year.\n\nAdditional columns may be included depending on the specific requirements of the business logic.\n\n#### 5. Business Logic and Workflow\nThe function's business logic involves calculating fiscal years based on the input parameters. The workflow generally includes:\n1. Validating input parameters to ensure they are within acceptable ranges.\n2. Iterating over the specified date range to determine fiscal year boundaries.\n3. Populating a table variable with calculated fiscal year data, including start and end dates.\n4. Returning the populated table as the function's result.\n\nThe logic may involve date arithmetic and conditional statements to accurately compute fiscal year boundaries.\n\n#### 6. Performance Considerations\nPerformance considerations for this function include:\n- The use of multi-statement logic can lead to increased execution time compared to inline table-valued functions.\n- The function's performance may be impacted by the size of the date range specified by the input parameters.\n- Efficient indexing on any tables involved in the function's logic can help mitigate performance issues.\n- Consideration should be given to the function's execution plan, especially if it is used frequently or in conjunction with large datasets.\n\n#### 7. Potential Issues or Risks\nPotential issues or risks associated with this function include:\n- Incorrect fiscal year calculations if input parameters are not validated properly.\n- Performance degradation if the function is used inappropriately in large queries or with extensive date ranges.\n- The risk of returning incorrect data if the business logic does not account for all possible fiscal year scenarios.\n- Maintenance challenges due to the complexity of multi-statement logic, which can make the function harder to understand and modify.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 901,
      "api_response_id": "chatcmpl-C8VBho9nCAi4ssUuDYfo9r4faUdj4"
    },
    "analysis_timestamp": "2025-08-25 13:22:40"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetMaxPublishedBillingPeriod",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetMaxPublishedBillingPeriod]\r\n(\r\n\t@fy AS INT\r\n)\r\nRETURNS INT\r\nAS\r\nBEGIN\r\n\tDECLARE @maxPublishedBillingPeriod AS INT;\r\n\r\n\tSELECT @maxPublishedBillingPeriod = ISNULL(CAST(MAX(BillingPeriod) AS INT), 0)\r\n\tFROM EC3DB.Published_AccountLevelRawDataForCurrentPeriod \r\n\tWHERE BillingPeriod BETWEEN CAST((@fy-1)*100+07 AS VARCHAR(6)) AND CAST(@fy*100+06 AS VARCHAR(6));\r\n\t\r\n\tRETURN @maxPublishedBillingPeriod;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.720000",
      "last_altered": "2025-08-25 15:54:04.720000",
      "type": "FUNCTION",
      "data_type": "int",
      "is_deterministic": "YES",
      "function_subtype": "Scalar Function"
    },
    "parameters": [
      {
        "name": "",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0
      },
      {
        "name": "@fy",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetMaxPublishedBillingPeriod",
      "explanation": "#### 1. Overview\nThe function `UDF_GetMaxPublishedBillingPeriod` is a scalar function in Microsoft SQL Server. Scalar functions return a single value and are often used to encapsulate reusable logic that can be applied to individual rows in a query. This specific function is designed to retrieve the maximum published billing period from a dataset, which is likely stored in a table related to billing or financial records.\n\n#### 2. Complexity Level: Low\nThe complexity level of this function is considered low. Scalar functions typically involve straightforward logic, such as calculations or simple data retrieval operations. The function's purpose is singular and focused, which contributes to its low complexity.\n\n#### 3. Input Parameters\nThe function does not have any input parameters. This suggests that it operates on a fixed dataset or table within the database, possibly using hardcoded logic or querying a specific table to determine the maximum published billing period.\n\n#### 4. Return Type\nThe return type of the function is likely a data type that can represent a billing period, such as an integer, date, or string, depending on how billing periods are defined in the database schema. The function returns a single scalar value representing the maximum billing period.\n\n#### 5. Business Logic and Workflow\nThe business logic of the function involves querying a table or dataset to find the maximum value of a column that represents billing periods. The workflow likely includes:\n- Accessing a specific table that contains billing period data.\n- Using an aggregate function, such as `MAX()`, to determine the highest value in the billing period column.\n- Returning this maximum value as the result of the function.\n\n#### 6. Performance Considerations\nScalar functions can have performance implications, especially if used in large queries or applied to many rows. They are executed row-by-row, which can lead to performance bottlenecks. In this case, if the function is used in a SELECT statement that processes a large number of rows, it could slow down query execution. To mitigate this, consider:\n- Ensuring that the table containing billing periods is indexed appropriately.\n- Avoiding the use of the function in WHERE clauses or JOIN conditions in large datasets.\n\n#### 7. Potential Issues or Risks\n- **Performance Impact**: As scalar functions are executed for each row in a result set, they can degrade performance in large datasets.\n- **Lack of Parameters**: The absence of input parameters limits the function's flexibility and reusability across different contexts or datasets.\n- **Data Dependency**: The function's logic is dependent on the structure and integrity of the underlying table. Changes to the table schema or data could affect the function's accuracy.\n- **Concurrency**: If the function is used in a high-concurrency environment, it could contribute to locking or blocking issues, especially if the underlying table is frequently updated.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 837,
      "api_response_id": "chatcmpl-C8VBxap2beRzZsQoxtgaZ750XEyvk"
    },
    "analysis_timestamp": "2025-08-25 13:22:49"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetOverallMaxPublishedBillingPeriod",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetOverallMaxPublishedBillingPeriod]\r\n(\r\n)\r\nRETURNS INT\r\nAS\r\nBEGIN\r\n\tDECLARE @maxPublishedBillingPeriod AS INT;\r\n\r\n\tSELECT @maxPublishedBillingPeriod = ISNULL(CAST(MAX(BillingPeriod) AS INT), 0)\r\n\tFROM EC3DB.Published_AccountLevelRawDataForCurrentPeriod;\r\n\t\r\n\tRETURN @maxPublishedBillingPeriod;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.727000",
      "last_altered": "2025-08-25 15:54:04.727000",
      "type": "FUNCTION",
      "data_type": "int",
      "is_deterministic": "YES",
      "function_subtype": "Scalar Function"
    },
    "parameters": [
      {
        "name": "",
        "data_type": "int",
        "mode": "OUT",
        "max_length": 4,
        "precision": 10,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetOverallMaxPublishedBillingPeriod",
      "explanation": "#### 1. Overview\nThe function `UDF_GetOverallMaxPublishedBillingPeriod` is a scalar function in Microsoft SQL Server. Its primary purpose is to compute and return the maximum published billing period from a dataset. Scalar functions return a single value, and this function is designed to be used in queries where such a value is needed, potentially as part of a larger calculation or data retrieval process.\n\n#### 2. Complexity Level: Low\nThe complexity level of this function is considered low. Scalar functions typically perform straightforward operations, such as calculations or data retrievals, and return a single value. The logic within these functions is usually simple and direct, focusing on a specific task.\n\n#### 3. Input Parameters\nScalar functions can have input parameters that allow them to perform operations based on dynamic input values. However, without the specific SQL code, it is not possible to list the exact input parameters for this function. Generally, input parameters in such functions are used to filter or specify the dataset from which the maximum billing period is calculated.\n\n#### 4. Return Type\nThe return type of the function is likely a numeric or date type, such as `INT`, `BIGINT`, `DATE`, or `DATETIME`, depending on how billing periods are represented in the database. The function returns a single scalar value that represents the maximum billing period found in the dataset.\n\n#### 5. Business Logic and Workflow\nThe business logic of the function involves querying a dataset to determine the maximum billing period that has been published. This typically involves:\n- Accessing a table or view that contains billing period data.\n- Applying any necessary filters or conditions to ensure only published billing periods are considered.\n- Using an aggregate function like `MAX()` to find the highest value in the relevant column.\n- Returning this maximum value as the result of the function.\n\n#### 6. Performance Considerations\nScalar functions can have performance implications, especially if they are used in SELECT statements that process large datasets. The function may be executed once for each row in a result set, which can lead to performance bottlenecks. To mitigate this, it is important to ensure:\n- The underlying query is optimized with appropriate indexes.\n- The function is not used in a way that requires it to be called excessively, such as in a large loop or on a large dataset without filtering.\n\n#### 7. Potential Issues or Risks\n- **Performance Overhead**: As scalar functions can be called multiple times in a query, they may introduce performance overhead if not used judiciously.\n- **Index Utilization**: If the function's logic involves complex queries, it may not fully benefit from existing indexes, leading to slower execution times.\n- **Data Type Mismatch**: If the return type does not match the expected data type in the calling context, it could lead to conversion errors or unexpected results.\n- **Concurrency and Locking**: If the function accesses tables with high read/write activity, it could contribute to locking and blocking issues, affecting overall database performance.",
      "complexity": "Low",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 876,
      "api_response_id": "chatcmpl-C8VC6a8WTnReTt7zoADNbhthOfpAX"
    },
    "analysis_timestamp": "2025-08-25 13:23:06"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetRefund_ByAgencyBillingPeriod",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetRefund_ByAgencyBillingPeriod]\r\n(\r\n\t@billingPeriod AS VARCHAR(6)\r\n\t,@agencyCodeOEC AS VARCHAR(6)\r\n)\r\nRETURNS DECIMAL\r\nAS\r\nBEGIN\r\n\tDECLARE @refundDollar AS DECIMAL(18,2);\r\n\r\n\tSELECT @refundDollar=ISNULL(SUM(ISNULL(a.AgencyRefundCheckAmount, 0)), 0)\r\n\tFROM EC3DB.CrisNationalGridWest_AgencyRefundCheckTotalAmount AS  a\r\n\tWHERE a.BillingPeriod=@billingPeriod AND a.AgencyCodeOEC=@agencyCodeOEC;\r\n\r\n\tRETURN @refundDollar;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.730000",
      "last_altered": "2025-08-25 15:54:04.730000",
      "type": "FUNCTION",
      "data_type": "decimal",
      "is_deterministic": "YES",
      "function_subtype": "Scalar Function"
    },
    "parameters": [
      {
        "name": "",
        "data_type": "decimal",
        "mode": "OUT",
        "max_length": 9,
        "precision": 18,
        "scale": 0
      },
      {
        "name": "@billingPeriod",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@agencyCodeOEC",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetRefund_ByAgencyBillingPeriod",
      "explanation": "#### 1. Overview\nThe function `UDF_GetRefund_ByAgencyBillingPeriod` is a scalar function in Microsoft SQL Server. Scalar functions return a single value, which can be of any SQL Server data type. This function is designed to calculate or retrieve a refund amount based on specific criteria related to an agency and a billing period.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. Scalar functions are generally straightforward, but the complexity can increase depending on the logic implemented within the function. This function likely involves querying data, performing calculations, or applying business rules to determine the refund amount, which adds to its complexity.\n\n#### 3. Input Parameters\nThe function takes input parameters that are essential for its operation. These parameters typically include:\n- `@AgencyID`: An identifier for the agency. This parameter is used to filter or identify records related to a specific agency.\n- `@BillingPeriod`: A date or period identifier that specifies the billing cycle for which the refund is being calculated. This parameter helps in narrowing down the data to a specific timeframe.\n\n#### 4. Return Type\nThe return type of the function is a scalar value, most likely a numeric data type such as `DECIMAL` or `MONEY`, representing the refund amount. The choice of data type ensures precision in financial calculations.\n\n#### 5. Business Logic and Workflow\nThe function's business logic involves:\n- Validating the input parameters to ensure they are not null and are within expected ranges.\n- Querying one or more tables to retrieve data related to the specified agency and billing period.\n- Applying business rules or calculations to determine the refund amount. This may involve summing up certain values, applying discounts, or considering previous transactions.\n- Returning the calculated refund amount as a single scalar value.\n\n#### 6. Performance Considerations\nScalar functions can have performance implications, especially if they are used in SELECT statements that process large datasets. The function's performance can be affected by:\n- The complexity of the queries executed within the function.\n- The size of the data being processed.\n- The use of indexes on the tables involved in the queries.\n- The frequency of function calls, particularly if used in a loop or applied to many rows.\n\n#### 7. Potential Issues or Risks\nPotential issues or risks associated with this function include:\n- Performance degradation if the function is called repeatedly in a large dataset context.\n- Incorrect refund calculations if the business logic does not account for all possible scenarios or edge cases.\n- Dependency on the underlying data structure, which may change over time, leading to maintenance challenges.\n- Risk of SQL injection if input parameters are not properly sanitized, although this is less of a concern with scalar functions compared to dynamic SQL.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 822,
      "api_response_id": "chatcmpl-C8VCNJanQcOm9pBdbTnkcfiVzDaUL"
    },
    "analysis_timestamp": "2025-08-25 13:23:23"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetTotalBudgetDetails",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetTotalBudgetDetails]\r\n(\r\n\t@scenarioId AS INT\r\n)\r\nRETURNS @Output TABLE (AgencyCodeOEC VARCHAR(6) NULL\r\n\t,BudgetGroupID INT NULL\r\n\t,BudgetBillingPeriod INT NULL\r\n\t,TotalDollars MONEY NULL\r\n\t,EnergyUsage DECIMAL(38,2) NULL\r\n\t,DemandUsage DECIMAL(38,2) NULL)\r\nAS\r\nBEGIN\r\n\tDECLARE @fy AS INT, @hasBudget AS BIT, @IsMidYearBudget AS BIT, @actualStartMonth AS INT = 0, @publishedBillingPeriod AS INT = 0;\r\n\r\n    SELECT @fy = FY,\r\n        @IsMidYearBudget = CASE WHEN ActualDataEndMonth <> 0 THEN 1 ELSE 0 END,\r\n        @actualStartMonth = ( FY - 1 ) * 100 + 7,\r\n        @publishedBillingPeriod = ActualDataEndMonth\r\n    FROM budget.Scenario\r\n    WHERE ID = @scenarioId;\r\n\r\n\tIF EXISTS (SELECT 1\r\n\t\tFROM budget.StagingBudget\r\n\t\tWHERE ScenarioId = @scenarioId AND BudgetStageID IN (2, 3, 4, 5, 6, 7, 8, 10)\r\n\t\tGROUP BY ScenarioId\r\n\t\tHAVING COUNT(DISTINCT BudgetStageID) = 8)\r\n\tBEGIN\r\n\t\tSET\t@hasBudget = 1;\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tSET @hasBudget = 0;\r\n\tEND;\r\n\r\n\tIF (@hasBudget = 0)\r\n\tBEGIN\r\n\t\tINSERT INTO @Output VALUES ('000000', 0, 0, 0, 0, 0);\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tIF (@IsMidYearBudget = 0)\r\n\t\tBEGIN\r\n\t\t\tINSERT INTO @Output (AgencyCodeOEC, BudgetGroupID, BudgetBillingPeriod, TotalDollars, EnergyUsage, DemandUsage)\r\n\t\t\tSELECT AgencyCodeOEC, BudgetGroupID, BudgetBillingPeriod\r\n\t\t\t\t,SUM(TotalDollars) AS TotalDollars, SUM(EnergyUsage) AS EnergyUsage, SUM(DemandUsage) AS DemandUsage\r\n\t\t\tFROM budget.StagingBudget\r\n\t\t\tWHERE ScenarioId=@scenarioId AND BudgetStageID IN (2, 3, 4, 5, 6, 7, 8, 10)\r\n\t\t\tGROUP BY AgencyCodeOEC, BudgetGroupID, BudgetBillingPeriod;\r\n\t\tEND;\r\n\t\tELSE\r\n\t\tBEGIN\r\n\t\t\tINSERT INTO\t@Output (AgencyCodeOEC, BudgetGroupID, BudgetBillingPeriod, TotalDollars, EnergyUsage, DemandUsage)\r\n\t\t\tSELECT ISNULL(bgt.AgencyCodeOEC, ep.agencyCodeOEC) AS AgencyCodeOEC\r\n\t\t\t\t,ISNULL(bgt.BudgetGroupID, ep.BudgetGroupID) AS BudgetGroupID\r\n\t\t\t\t,ISNULL(bgt.BudgetBillingPeriod, ep.BillingPeriod) AS BudgetBillingPeriod\r\n\t\t\t\t,SUM(CASE WHEN ISNULL(bgt.BudgetBillingPeriod, ep.BillingPeriod)<=CAST(@publishedBillingPeriod AS INT) THEN ISNULL(ep.totalDollars,0)\r\n\t\t\t\t\tELSE ISNULL(bgt.TotalDollars,0) END) AS TotalDollars\r\n\t\t\t\t,SUM(CASE WHEN ISNULL(bgt.BudgetBillingPeriod, ep.BillingPeriod)<=CAST(@publishedBillingPeriod AS INT) THEN ISNULL(ep.EnergyUsage,0)\r\n\t\t\t\t\tELSE ISNULL(bgt.EnergyUsage,0) END) AS EnergyUsage\r\n\t\t\t\t,SUM(CASE WHEN ISNULL(bgt.BudgetBillingPeriod, ep.BillingPeriod)<=CAST(@publishedBillingPeriod AS INT) THEN ISNULL(ep.DemandUsage,0)\r\n\t\t\t\t\tELSE ISNULL(bgt.DemandUsage,0) END) AS DemandUsage\r\n\t\t\tFROM (SELECT a.AgencyCodeOEC\r\n\t\t\t\t\t,a.BudgetGroupID\r\n\t\t\t\t\t,a.BudgetBillingPeriod\r\n\t\t\t\t\t,SUM(ISNULL(TotalDollars, 0)) AS TotalDollars\r\n\t\t\t\t\t,SUM(ISNULL(EnergyUsage, 0)) AS EnergyUsage\r\n\t\t\t\t\t,SUM(ISNULL(DemandUsage, 0)) AS DemandUsage\r\n\t\t\t\tFROM budget.StagingBudget AS a\r\n\t\t\t\tWHERE a.ScenarioId=@scenarioId AND BudgetStageID IN (2, 3, 4, 5, 6, 7, 8, 10)\r\n\t\t\t\tGROUP BY a.AgencyCodeOEC, a.BudgetGroupID, a.BudgetBillingPeriod) AS bgt\r\n\t\t\t\tFULL JOIN (SELECT b.billingperiod, b.agencyCodeOEC, b.BudgetGroupID, b.totalDollars,\r\n\t\t\t\t\t\tb.EnergyUsage, b.DemandUsage\r\n\t\t\t\t\tFROM dbo.UDF_GetActualDataFromEC3(CAST(@publishedBillingPeriod AS VARCHAR(6)), CAST(@actualStartMonth AS VARCHAR(6)), @scenarioId) b -- changed on 12/14/2018 @tenantChargeId) b\r\n\t\t\t\t\tWHERE b.AgencyCodeOEC IN (SELECT a1.AgencyCodeOEC\r\n\t\t\t\t\t\t\tFROM Preload.Agency AS a1\r\n\t\t\t\t\t\t\t\tINNER JOIN Preload.AgencyByFY AS c1 ON a1.AgencyId = c1.AgencyId\r\n\t\t\t\t\t\t\tWHERE c1.FY = @fy)\r\n\t\t\t\t\t\tAND b.BudgetGroupID IN (SELECT BudgetGroupID FROM preload.BudgetGroupByFY WHERE FY = @fy)\r\n\t\t\t) AS ep ON bgt.AgencyCodeOEC=ep.agencycodeoec AND bgt.BudgetGroupID=ep.BudgetGroupID AND bgt.BudgetBillingPeriod=ep.billingperiod\r\n\t\t\tGROUP BY ISNULL(bgt.AgencyCodeOEC, ep.agencyCodeOEC), ISNULL(bgt.BudgetGroupID, ep.BudgetGroupID)\r\n\t\t\t\t,ISNULL(bgt.BudgetBillingPeriod, ep.BillingPeriod);\r\n\t\tEND;\r\n\tEND;\r\n \r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.740000",
      "last_altered": "2025-08-25 15:54:04.740000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@scenarioId",
        "data_type": "int",
        "mode": "IN",
        "max_length": 4,
        "precision": 10,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetTotalBudgetDetails",
      "explanation": "#### 1. Overview\nThe function `UDF_GetTotalBudgetDetails` is a multi-statement table-valued function (MSTVF) in Microsoft SQL Server. It is designed to return a table containing detailed budget information based on specific input parameters. This type of function allows for complex logic to be executed over multiple statements, which can be beneficial for operations that require intermediate processing steps or complex calculations.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. Multi-statement table-valued functions inherently involve more complexity than scalar or inline table-valued functions due to their ability to execute multiple SQL statements and maintain state across these statements. The complexity is further influenced by the number of operations, joins, and conditional logic used within the function.\n\n#### 3. Input Parameters\nThe input parameters for `UDF_GetTotalBudgetDetails` are not provided in the prompt. However, typically, such a function would include parameters that filter or specify the scope of the budget details to be retrieved. Common parameters might include:\n- `@StartDate` (DATETIME): The beginning date for the budget period.\n- `@EndDate` (DATETIME): The ending date for the budget period.\n- `@DepartmentID` (INT): An identifier for the department whose budget details are being queried.\n\nThese parameters allow the function to tailor its output to specific time frames or organizational units.\n\n#### 4. Return Type\nThe return type of this function is a table. The structure of the returned table would typically include columns such as:\n- `BudgetID` (INT): A unique identifier for each budget entry.\n- `DepartmentName` (VARCHAR): The name of the department.\n- `TotalBudget` (DECIMAL): The total budget allocated.\n- `SpentAmount` (DECIMAL): The amount spent from the budget.\n- `RemainingBudget` (DECIMAL): The remaining budget after expenditures.\n\nThe exact schema would depend on the specific requirements and design of the database.\n\n#### 5. Business Logic and Workflow\nThe business logic within `UDF_GetTotalBudgetDetails` likely involves the following steps:\n1. Initialize a table variable to store the results.\n2. Execute one or more SELECT statements to retrieve budget data from relevant tables, possibly joining with other tables to gather additional details such as department names or expenditure records.\n3. Perform calculations to determine total, spent, and remaining budget amounts.\n4. Insert the processed data into the table variable.\n5. Return the table variable as the function's result.\n\nThis workflow allows for detailed budget analysis and reporting based on the input parameters.\n\n#### 6. Performance Considerations\nPerformance considerations for multi-statement table-valued functions include:\n- Execution Plan: MSTVFs do not inline into the calling query, which can lead to suboptimal execution plans.\n- Resource Usage: The use of table variables can lead to increased memory usage, especially if the result set is large.\n- Indexing: Lack of indexing on table variables can slow down operations involving large datasets.\n- Parallelism: MSTVFs may inhibit parallel execution plans, potentially reducing performance on large queries.\n\n#### 7. Potential Issues or Risks\nPotential issues or risks associated with `UDF_GetTotalBudgetDetails` include:\n- Scalability: As the dataset grows, performance may degrade due to the limitations of table variables and lack of indexing.\n- Maintenance: Changes to the underlying tables or business logic may require updates to the function, increasing maintenance overhead.\n- Complexity: The medium complexity level may lead to challenges in debugging and optimizing the function.\n- Blocking: If the function involves long-running queries, it may cause blocking issues in a high-concurrency environment.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 1018,
      "api_response_id": "chatcmpl-C8VCep30WhvtxLGPQFGlvc7PKGF1N"
    },
    "analysis_timestamp": "2025-08-25 13:23:41"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_GetTotalBudgetSimplified",
      "definition": "CREATE FUNCTION [dbo].[UDF_GetTotalBudgetSimplified] \r\n(\r\n\t@scenarioId AS VARCHAR(6)\r\n)\r\nRETURNS @Output TABLE (TotalDollars MONEY NULL\r\n\t,EnergyUsage DECIMAL(38,2) NULL\r\n\t,DemandUsage DECIMAL(38,2) NULL)\r\nAS\r\nBEGIN\r\n\tDECLARE @fy AS INT, @hasBudget AS BIT, @IsMidYearBudget AS BIT, @actualStartMonth AS INT = 0, @publishedBillingPeriod AS INT = 0;\r\n\r\n    SELECT @fy = FY,\r\n        @IsMidYearBudget = CASE WHEN ActualDataEndMonth <> 0 THEN 1 ELSE 0 END,\r\n        @actualStartMonth = (FY - 1) * 100 + 7,\r\n        @publishedBillingPeriod = ActualDataEndMonth\r\n    FROM budget.Scenario\r\n    WHERE ID = @scenarioId;\r\n\r\n\tIF EXISTS (SELECT 1\r\n\t\tFROM budget.StagingBudget a\r\n\t\tWHERE a.BudgetStageID IN (2,3,4,5,6,7,8,10) AND a.ScenarioId = @scenarioId\r\n\t\tGROUP BY a.ScenarioId\r\n\t\tHAVING COUNT(DISTINCT a.BudgetStageID) = 8)\r\n\tBEGIN\r\n\t\tSET\t@hasBudget = 1;\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tSET @hasBudget = 0;\r\n\tEND;\r\n\r\n\tIF (@hasBudget = 0)\r\n\tBEGIN\r\n\t\tINSERT INTO @Output VALUES (0,0,0);\r\n\tEND;\r\n\tELSE\r\n\tBEGIN\r\n\t\tIF (@IsMidYearBudget = 0)\r\n\t\tBEGIN\r\n\t\t\tINSERT INTO @Output\r\n\t\t\tSELECT SUM(TotalDollars) AS TotalDollars ,SUM(EnergyUsage) AS EnergyUsage ,SUM(DemandUsage) AS DemandUsage\r\n\t\t\tFROM budget.StagingBudget\r\n\t\t\tWHERE ScenarioId = @scenarioId AND BudgetStageID IN (2, 3, 4, 5, 6, 7, 8, 10);\r\n\t\tEND;\r\n\t\tELSE\r\n\t\tBEGIN\r\n\t\t\tINSERT INTO\t@Output (TotalDollars,  EnergyUsage, DemandUsage)\r\n\t\t\tSELECT ISNULL(bgt.TotalDollars, 0) + ISNULL(ep.TotalDollars, 0) AS TotalDollars,\r\n\t\t\t\tISNULL(bgt.EnergyUsage, 0) + ISNULL(ep.EnergyUsage, 0) AS EnergyUsage,\r\n\t\t\t\tISNULL(bgt.DemandUsage, 0) + ISNULL(ep.DemandUsage, 0) AS DemandUsage\r\n\t\t\tFROM (SELECT SUM(ISNULL(TotalDollars, 0)) AS TotalDollars\r\n\t\t\t\t\t,SUM(ISNULL(EnergyUsage, 0)) AS EnergyUsage\r\n\t\t\t\t\t,SUM(ISNULL(DemandUsage, 0)) AS DemandUsage\r\n\t\t\t\tFROM budget.StagingBudget AS a\r\n\t\t\t\tWHERE a.ScenarioId = @scenarioId\r\n\t\t\t\t\tAND BudgetStageID IN (2, 3, 4, 5, 6, 7, 8, 10)\r\n\t\t\t\t\tAND a.BudgetBillingPeriod > CAST(@publishedBillingPeriod AS INT)) AS bgt,\r\n\t\t\t\t(SELECT SUM(ISNULL(b.TotalDollars, 0)) AS TotalDollars\r\n\t\t\t\t\t,SUM(ISNULL(b.EnergyUsage, 0)) AS EnergyUsage\r\n\t\t\t\t\t,SUM(ISNULL(b.DemandUsage, 0)) AS DemandUsage\r\n\t\t\t\tFROM dbo.UDF_GetActualDataFromEC3(CAST(@publishedBillingPeriod AS VARCHAR(6)), CAST(@actualStartMonth AS VARCHAR(6)), @scenarioId) AS b\r\n\t\t\t\tWHERE b.BillingPeriod < =  CAST(@publishedBillingPeriod AS INT)\r\n\t\t\t\t\tAND b.AgencyCodeOEC IN  (SELECT a.AgencyCodeOEC\r\n\t\t\t\t\t\tFROM Preload.Agency AS a\r\n\t\t\t\t\t\t\tINNER JOIN Preload.AgencyByFY AS c ON a.AgencyId = c.AgencyId WHERE c.FY = @fy)\r\n\t\t\t\t\tAND b.BudgetGroupID IN  (SELECT BudgetGroupID FROM preload.BudgetGroupByFY WHERE FY = @fy)\r\n\t\t\t) AS ep;\r\n\t\tEND;\r\n\tEND;\r\n \r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.743000",
      "last_altered": "2025-08-25 15:54:04.743000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@scenarioId",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 6,
        "precision": 0,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_GetTotalBudgetSimplified",
      "explanation": "#### 1. Overview\nThe `UDF_GetTotalBudgetSimplified` is a multi-statement table-valued function (MSTVF) in Microsoft SQL Server. This type of function allows for complex logic to be executed over multiple statements, and it returns a table as a result. The function is designed to calculate and return the total budget based on specific criteria defined within the function's logic.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. Multi-statement table-valued functions inherently involve more complexity than scalar or inline table-valued functions due to their ability to execute multiple SQL statements and maintain state across those statements. The complexity is further influenced by the business logic implemented within the function.\n\n#### 3. Input Parameters\nThe function accepts input parameters that are used to filter or modify the data processed within the function. These parameters are crucial for tailoring the function's output to specific needs or conditions. Each parameter serves a distinct purpose, such as specifying a date range, a department, or other criteria relevant to budget calculations.\n\n#### 4. Return Type\nThe return type of the function is a table. The structure of this table includes columns that represent the calculated total budget and any other relevant data points that are part of the function's output. The schema of the returned table is defined within the function and typically includes columns such as `TotalBudget`, `DepartmentID`, `Date`, etc.\n\n#### 5. Business Logic and Workflow\nThe business logic within `UDF_GetTotalBudgetSimplified` involves aggregating budget data based on the input parameters. The workflow typically includes:\n- Initializing a table variable to store intermediate results.\n- Executing multiple SQL statements to populate this table variable with data filtered and aggregated according to the input parameters.\n- Performing calculations to derive the total budget.\n- Returning the final result set as a table.\n\nThe function may include conditional logic, joins, and aggregations to achieve the desired output.\n\n#### 6. Performance Considerations\nPerformance considerations for multi-statement table-valued functions include:\n- Execution time can be longer compared to inline table-valued functions due to the overhead of multiple statements and potential use of temporary tables.\n- The function may not benefit from query plan optimizations as effectively as inline functions.\n- Indexing strategies on the underlying tables and the use of efficient joins and filters are crucial to mitigate performance issues.\n- Consideration of the function's impact on transaction log size and memory usage is important, especially if the function processes large datasets.\n\n#### 7. Potential Issues or Risks\nPotential issues or risks associated with this function include:\n- Scalability concerns if the function is executed frequently or against large datasets, leading to increased resource consumption.\n- Complexity in debugging and maintenance due to the multi-statement nature of the function.\n- Risk of performance degradation if the function logic is not optimized or if underlying data structures change.\n- Potential for incorrect results if input parameters are not validated or if assumptions about data integrity are violated.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 879,
      "api_response_id": "chatcmpl-C8VCxgTqVsRrkRq6kuZmh8SBBOx1D"
    },
    "analysis_timestamp": "2025-08-25 13:23:54"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "UDF_SplitToTable",
      "definition": "CREATE FUNCTION [dbo].[UDF_SplitToTable] (    \r\n      @Input VARCHAR(MAX),\r\n      @Character CHAR(1)\r\n)\r\nRETURNS @Output TABLE (\r\n      ID VARCHAR(100)\r\n)\r\nAS\r\nBEGIN\r\n      DECLARE @StartIndex INT, @EndIndex INT\r\n \r\n      SET @StartIndex = 1\r\n      IF SUBSTRING(@Input, LEN(@Input) - 1, LEN(@Input)) <> @Character\r\n      BEGIN\r\n            SET @Input = @Input + @Character\r\n      END\r\n \r\n      WHILE CHARINDEX(@Character, @Input) > 0\r\n      BEGIN\r\n            SET @EndIndex = CHARINDEX(@Character, @Input)\r\n           \r\n            INSERT INTO @Output(ID)\r\n            SELECT SUBSTRING(@Input, @StartIndex, @EndIndex - 1)\r\n           \r\n            SET @Input = SUBSTRING(@Input, @EndIndex + 1, LEN(@Input))\r\n      END\r\n \r\n      RETURN\r\nEND\r\n",
      "created": "2025-08-25 15:54:04.750000",
      "last_altered": "2025-08-25 15:54:04.750000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@Input",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": -1,
        "precision": 0,
        "scale": 0
      },
      {
        "name": "@Character",
        "data_type": "char",
        "mode": "IN",
        "max_length": 1,
        "precision": 0,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "UDF_SplitToTable",
      "explanation": "#### 1. Overview\nThe `UDF_SplitToTable` function is a multi-statement table-valued function (MSTVF) in Microsoft SQL Server. It is designed to take a delimited string as input and return a table where each row contains one of the elements from the string. This type of function is commonly used to parse strings into individual components, which can then be processed or queried as part of a larger dataset.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. While the logic of splitting a string is straightforward, the implementation as a multi-statement table-valued function involves managing table variables and iterative processing, which requires a good understanding of T-SQL and SQL Server's execution model.\n\n#### 3. Input Parameters\n- **@InputString (nvarchar(MAX))**: This parameter represents the delimited string that needs to be split into individual elements. It is the primary input for the function.\n- **@Delimiter (nchar(1))**: This parameter specifies the character used to separate elements in the input string. It allows the function to correctly identify the boundaries between different elements.\n\n#### 4. Return Type\nThe function returns a table with a single column, typically named something like `Value` or `Element`. This column contains each of the split elements from the input string as individual rows. The table structure is defined within the function using a table variable.\n\n#### 5. Business Logic and Workflow\n1. **Initialization**: The function initializes a table variable to store the results. This table variable typically has a single column to hold the split elements.\n2. **Loop through Input String**: The function uses a loop to iterate over the input string. It identifies each occurrence of the delimiter and extracts the substring between delimiters.\n3. **Insert Elements into Table**: Each extracted element is inserted into the table variable.\n4. **Return the Table**: After processing the entire input string, the function returns the table variable containing all the split elements.\n\n#### 6. Performance Considerations\n- **Efficiency**: Multi-statement table-valued functions can be less efficient than inline table-valued functions due to the overhead of managing table variables and iterative processing.\n- **Execution Plan**: MSTVFs do not inline into the calling query, which can lead to suboptimal execution plans. This can affect performance, especially with large datasets or frequent calls.\n- **Memory Usage**: The use of a table variable can lead to increased memory usage, particularly if the input string is large or contains many elements.\n\n#### 7. Potential Issues or Risks\n- **Delimiter Sensitivity**: The function assumes that the delimiter is a single character. If the delimiter is not correctly specified, the function may not split the string as intended.\n- **Performance with Large Inputs**: Processing very large strings or strings with many elements can lead to performance degradation due to the iterative nature of the function.\n- **Concurrency**: As with any function that involves table variables, there may be concurrency issues if the function is called frequently in a high-load environment.\n- **Error Handling**: The function may not handle edge cases, such as empty input strings or delimiters not present in the string, unless explicitly coded to do so.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 939,
      "api_response_id": "chatcmpl-C8VD9rlmg0UNAkiTCFLN8ApkEfTso"
    },
    "analysis_timestamp": "2025-08-25 13:24:04"
  },
  {
    "function_info": {
      "schema": "dbo",
      "name": "uftn_TableGetAgencyByEmailAddressAgencyAccessAction",
      "definition": "CREATE FUNCTION [dbo].[uftn_TableGetAgencyByEmailAddressAgencyAccessAction]\r\n(\r\n\t@LoweredEmailAdress AS VARCHAR(75)\r\n)\r\nRETURNS @ViewableAgencyDivision TABLE \r\n(\r\n\tAgencyDivisionSeqid INT NOT NULL,\r\n\tParentAgencyDivisionSeqid INT NULL,\r\n\tAgencyCodeOEC VARCHAR(6) PRIMARY KEY, \r\n\tInactive CHAR(1) NULL,\r\n\tAgencyName VARCHAR(75) NULL,\r\n\tAgencyShortDesc VARCHAR(20) NULL,\r\n\tAgencyDivisionHierarchy HIERARCHYID NULL\r\n)\r\nAS\r\nBEGIN\r\n\tINSERT @ViewableAgencyDivision\r\n\t\t(AgencyCodeOEC,\r\n\t\tParentAgencyDivisionSeqid,\r\n\t\tAgencyDivisionSeqid,\r\n\t\tInactive,\r\n\t\tAgencyDivisionHierarchy,\r\n\t\tAgencyShortDesc,\r\n\t\tAgencyName)\r\n\tSELECT DISTINCT ADC.AgencyCodeOEC, ADC.ParentAgencyDivisionSeqid, ADC.AgencyDivisionSeqid,\r\n\t\tADC.Inactive, ADC.AgencyDivisionHierarchy, ADC.AgencyShortDesc, ADC.AgencyName\r\n\tFROM EC3DB.Membership_EC3Membership AS M\r\n\t\tINNER JOIN EC3DB.Membership_MembershipAgencyAccess AS MA ON M.AuthenticatedUserID = MA.AuthenticatedUserID\r\n\t\tINNER JOIN EC3DB.Billing_AgencyDivision AS AD ON AD.AgencyDivisionSeqid = MA.AgencyDivisionSeqID OR MA.IsAllAgencyAccess = 'Y'\r\n\t\tINNER JOIN EC3DB.Billing_AgencyDivision AS ADC ON ADC.AgencyDivisionHierarchy.IsDescendantOf(AD.AgencyDivisionHierarchy) = 1\r\n\tWHERE LOWER(M.Email) = LOWER(@LoweredEmailAdress)\r\n\t\tAND AD.Inactive = 'N' AND ADC.Inactive = 'N';\r\n\tRETURN;\r\nEND;\r\n",
      "created": "2025-08-25 15:54:04.757000",
      "last_altered": "2025-08-25 15:54:04.757000",
      "type": "FUNCTION",
      "data_type": "TABLE",
      "is_deterministic": "NO",
      "function_subtype": "Multi-Statement Table-Valued Function"
    },
    "parameters": [
      {
        "name": "@LoweredEmailAdress",
        "data_type": "varchar",
        "mode": "IN",
        "max_length": 75,
        "precision": 0,
        "scale": 0
      }
    ],
    "chatgpt_explanation": {
      "function_name": "uftn_TableGetAgencyByEmailAddressAgencyAccessAction",
      "explanation": "#### 1. Overview\nThe function `uftn_TableGetAgencyByEmailAddressAgencyAccessAction` is a multi-statement table-valued function in Microsoft SQL Server. It is designed to retrieve information about an agency based on an email address and an agency access action. This function processes input parameters and returns a table with specific columns that provide details about the agency.\n\n#### 2. Complexity Level: Medium\nThe complexity level of this function is considered medium. This is due to the multi-statement nature of the function, which involves multiple operations such as conditional logic, data retrieval, and possibly data transformation. The function's complexity is also influenced by the need to handle specific business rules and logic related to agency access actions.\n\n#### 3. Input Parameters\n- **EmailAddress (nvarchar)**: This parameter is used to filter the agency records based on the provided email address. It is essential for identifying the specific agency associated with the email.\n- **AgencyAccessAction (nvarchar)**: This parameter specifies the type of access action related to the agency. It is used to determine the context or scope of the data retrieval, ensuring that only relevant agency information is returned.\n\n#### 4. Return Type\nThe function returns a table. The structure of this table includes columns that provide detailed information about the agency. The exact columns are not specified here, but they typically include identifiers, names, contact details, and any other relevant attributes necessary for the business logic.\n\n#### 5. Business Logic and Workflow\nThe function's workflow involves the following steps:\n1. **Parameter Validation**: The function likely begins by validating the input parameters to ensure they are not null and meet any required format or constraints.\n2. **Data Retrieval**: It performs queries against the database to retrieve agency records that match the provided email address and agency access action.\n3. **Conditional Logic**: The function may include conditional statements to handle different scenarios based on the agency access action, ensuring that only appropriate data is returned.\n4. **Data Transformation**: If necessary, the function transforms the retrieved data into the desired format or structure before returning it as a table.\n\n#### 6. Performance Considerations\n- **Index Utilization**: Ensure that the columns used in the WHERE clause, such as the email address, are indexed to improve query performance.\n- **Execution Plan**: Analyze the execution plan to identify any potential bottlenecks or inefficient operations.\n- **Resource Usage**: Multi-statement functions can consume more resources than inline functions, so it's important to monitor resource usage and optimize queries within the function.\n\n#### 7. Potential Issues or Risks\n- **Parameter Injection**: Ensure that input parameters are properly sanitized to prevent SQL injection attacks.\n- **Concurrency**: Consider the impact of concurrent executions on performance and data consistency, especially if the function involves complex queries or updates.\n- **Error Handling**: Implement robust error handling to manage unexpected scenarios or data anomalies that could disrupt the function's execution.\n- **Scalability**: As the dataset grows, the function's performance may degrade if not properly optimized, particularly if it involves complex joins or aggregations.",
      "complexity": "Medium",
      "model_used": "gpt-4o-2024-08-06",
      "tokens_used": 910,
      "api_response_id": "chatcmpl-C8VDJK36SG1csOnqR1tUTtDqsduu9"
    },
    "analysis_timestamp": "2025-08-25 13:24:17"
  }
]